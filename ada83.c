/* ═══════════════════════════════════════════════════════════════════════════
 * Ada83 - An Ada 1983 (ANSI/MIL-STD-1815A) compiler targeting LLVM IR
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * §0  SIMD Optimizations - Assembly setup for big numbers and parsing
 * §1  Type_Metrics       - Representation details
 * §2  Memory_Arena       - Bump allocation for AST nodes
 * §3  String_Slice       - Non-owning string views
 * §4  Source_Location    - Diagnostic anchors
 * §5  Error_Handling     - Accumulating error reports
 * §6  Big_Integer        - Arbitrary precision for literals
 * §7  Lexer              - Character stream to tokens
 * §8  Abstract_Syntax    - Parse tree representation
 * §9  Parser             - Recursive descent
 * §10 Type_System        - Ada type semantics
 * §11 Symbol_Table       - Scoped name resolution
 * §12 Semantic_Pass      - Type checking and resolution
 * §13 Code_Generator     - LLVM IR emission
 */

#define _POSIX_C_SOURCE 200809L

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <iso646.h>
#include <limits.h>
#include <math.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <unistd.h>

/* ═══════════════════════════════════════════════════════════════════════════
 * SIMD Optimizations
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Architectures:
 *  x86-64  - AVX-512BW (64B), AVX2 (32B), SSE4.2 (16B)                  
 *  ARM64   - NEON/ASIMD (16B), SVE (128-2048b, runtime detected)        
 *  RISC-V  - V extension (VLEN=128-1024, runtime detected)              
 *  Generic - Scalar fallback with loop unrolling      
 *
 * NOTE: Every SIMD path has an equivalent scalar fallback
 * ═══════════════════════════════════════════════════════════════════════════
 */

/* Detect architecture at compile time */
#if defined(__x86_64__) || defined(_M_X64)
    #define SIMD_X86_64 1
#elif defined(__aarch64__) || defined(_M_ARM64)
    #define SIMD_ARM64 1
#elif defined(__riscv) && defined(__riscv_v)
    #define SIMD_RISCV_V 1
#elif defined(__riscv)
    #define SIMD_RISCV_SCALAR 1
#else
    #define SIMD_GENERIC 1
#endif

/* Runtime CPU feature detection for x86-64
 * Note: AVX-512 code only compiles with -mavx512bw; without it we use AVX2/scalar */
#ifdef SIMD_X86_64
#ifdef __AVX512BW__
static int Simd_Has_Avx512 = -1;  /* -1 = unchecked, 0 = no, 1 = yes */
#else
__attribute__((unused))
static int Simd_Has_Avx512 = 0;   /* Disabled: not compiled with AVX-512 support */
#endif
static int Simd_Has_Avx2 = -1;

static void Simd_Detect_Features(void) {
    if (Simd_Has_Avx2 >= 0) return;  /* Already detected */

    uint32_t eax, ebx, ecx, edx;

    /* Check for AVX2: CPUID.07H:EBX.AVX2[bit 5] */
    __asm__ volatile (
        "mov $7, %%eax\n\t"
        "xor %%ecx, %%ecx\n\t"
        "cpuid\n\t"
        : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
        :
        : "memory"
    );
    Simd_Has_Avx2 = (ebx >> 5) & 1;

#ifdef __AVX512BW__
    /* Check for AVX-512F and AVX-512BW at runtime (only if compiled with support) */
    Simd_Has_Avx512 = ((ebx >> 16) & 1) && ((ebx >> 30) & 1);
#endif
}
#endif

/* ═══════════════════════════════════════════════════════════════════════════
 * §1. TYPE METRICS — Representation details
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * We centralize all size and alignment computations. All sizes flow through
 * To_Bits/To_Bytes morphisms.
 *
 * INVARIANT: Sizes in Type_Info are stored in BYTES (not bits).
 * This matches LLVM's DataLayout model and simplifies record layout.
 */

/* Safe ctype: C library requires unsigned char to avoid UB on signed char */
static inline int  Is_Alpha(char c)   { return isalpha((unsigned char)c); }
static inline int  Is_Digit(char c)   { return isdigit((unsigned char)c); }
static inline int  Is_Xdigit(char c)  { return isxdigit((unsigned char)c); }
static inline int  Is_Space(char c)   { return isspace((unsigned char)c); }
static inline char To_Lower(char c)   { return (char)tolower((unsigned char)c); }

/* Fast identifier character lookup table per Ada LRM
 * ASCII: [A-Za-z0-9_]
 * Latin-1 letters: 0xC0-0xD6 (À-Ö), 0xD8-0xF6 (Ø-ö), 0xF8-0xFF (ø-ÿ)
 * Excludes: 0xD7 (×) and 0xF7 (÷) which are operators, not letters
 */
static const uint8_t Id_Char_Table[256] = {
    /* ASCII letters */
    ['A']=1,['B']=1,['C']=1,['D']=1,['E']=1,['F']=1,['G']=1,['H']=1,
    ['I']=1,['J']=1,['K']=1,['L']=1,['M']=1,['N']=1,['O']=1,['P']=1,
    ['Q']=1,['R']=1,['S']=1,['T']=1,['U']=1,['V']=1,['W']=1,['X']=1,
    ['Y']=1,['Z']=1,
    ['a']=1,['b']=1,['c']=1,['d']=1,['e']=1,['f']=1,['g']=1,['h']=1,
    ['i']=1,['j']=1,['k']=1,['l']=1,['m']=1,['n']=1,['o']=1,['p']=1,
    ['q']=1,['r']=1,['s']=1,['t']=1,['u']=1,['v']=1,['w']=1,['x']=1,
    ['y']=1,['z']=1,
    /* Digits and underscore */
    ['0']=1,['1']=1,['2']=1,['3']=1,['4']=1,['5']=1,['6']=1,['7']=1,
    ['8']=1,['9']=1,['_']=1,
    /* Latin-1 uppercase letters: À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï Ð Ñ Ò Ó Ô Õ Ö */
    [0xC0]=1,[0xC1]=1,[0xC2]=1,[0xC3]=1,[0xC4]=1,[0xC5]=1,[0xC6]=1,[0xC7]=1,
    [0xC8]=1,[0xC9]=1,[0xCA]=1,[0xCB]=1,[0xCC]=1,[0xCD]=1,[0xCE]=1,[0xCF]=1,
    [0xD0]=1,[0xD1]=1,[0xD2]=1,[0xD3]=1,[0xD4]=1,[0xD5]=1,[0xD6]=1,
    /* 0xD7 = × (multiplication sign) - NOT a letter */
    /* Latin-1 more letters: Ø Ù Ú Û Ü Ý Þ ß */
    [0xD8]=1,[0xD9]=1,[0xDA]=1,[0xDB]=1,[0xDC]=1,[0xDD]=1,[0xDE]=1,[0xDF]=1,
    /* Latin-1 lowercase letters: à á â ã ä å æ ç è é ê ë ì í î ï ð ñ ò ó ô õ ö */
    [0xE0]=1,[0xE1]=1,[0xE2]=1,[0xE3]=1,[0xE4]=1,[0xE5]=1,[0xE6]=1,[0xE7]=1,
    [0xE8]=1,[0xE9]=1,[0xEA]=1,[0xEB]=1,[0xEC]=1,[0xED]=1,[0xEE]=1,[0xEF]=1,
    [0xF0]=1,[0xF1]=1,[0xF2]=1,[0xF3]=1,[0xF4]=1,[0xF5]=1,[0xF6]=1,
    /* 0xF7 = ÷ (division sign) - NOT a letter */
    /* Latin-1 remaining lowercase: ø ù ú û ü ý þ ÿ */
    [0xF8]=1,[0xF9]=1,[0xFA]=1,[0xFB]=1,[0xFC]=1,[0xFD]=1,[0xFE]=1,[0xFF]=1
};
#define Is_Id_Char(c) (Id_Char_Table[(uint8_t)(c)])

/* Universally 8 on modern targets */
enum { Bits_Per_Unit = 8 };

/* LLVM integer widths in bits */
typedef enum {
    Width_1   = 1,    Width_8   = 8,    Width_16  = 16,
    Width_32  = 32,   Width_64  = 64,   Width_128 = 128,
    Width_Ptr = 64,   Width_Float = 32, Width_Double = 64
} Bit_Width;

/* Ada standard integer widths per RM §3.5.4 */
typedef enum {
    Ada_Short_Short_Integer_Bits = Width_8,
    Ada_Short_Integer_Bits       = Width_16,
    Ada_Integer_Bits             = Width_32,
    Ada_Long_Integer_Bits        = Width_64,
    Ada_Long_Long_Integer_Bits   = Width_64
} Ada_Integer_Width;

/* Default metrics when type is unspecified — uses Integer'Size (32 bits) */
enum {
    Default_Size_Bits   = Ada_Integer_Bits,
    Default_Size_Bytes  = Ada_Integer_Bits / Bits_Per_Unit,
    Default_Align_Bytes = Default_Size_Bytes
};

/* ─────────────────────────────────────────────────────────────────────────
 * §1.1 Bit/Byte Conversions — The Morphisms of Size
 *
 * To_Bits:  bytes → bits  (multiplicative, total)
 * To_Bytes: bits → bytes  (ceiling division, rounds up)
 * ───────────────────────────────────────────────────────────────────────── */

static inline uint64_t To_Bits(uint64_t bytes)  { return bytes * Bits_Per_Unit; }
static inline uint64_t To_Bytes(uint64_t bits)  { return (bits + Bits_Per_Unit - 1) / Bits_Per_Unit; }
static inline uint64_t Byte_Align(uint64_t bits){ return To_Bits(To_Bytes(bits)); }

/* Align size up to power-of-2 alignment boundary */
static inline size_t Align_To(size_t size, size_t align) {
    return align ? ((size + align - 1) & ~(align - 1)) : size;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §1.2 LLVM Type Selection — Width to Type Morphism
 *
 * Maps bit width to smallest containing LLVM integer type.
 * ───────────────────────────────────────────────────────────────────────── */

static inline const char *Llvm_Int_Type(uint32_t bits) {
    return bits <= 1   ? "i1"   : bits <= 8   ? "i8"  : bits <= 16  ? "i16" :
           bits <= 32  ? "i32"  : bits <= 64  ? "i64" : "i128";
}

static inline const char *Llvm_Float_Type(uint32_t bits) {
    return bits <= Width_Float ? "float" : "double";
}

/* ─────────────────────────────────────────────────────────────────────────
 * §1.3 Range Predicates — Determining Representation Width
 *
 * Compute minimum bits needed for a range [lo, hi].
 * ───────────────────────────────────────────────────────────────────────── */

static inline bool Fits_In_Signed(int64_t lo, int64_t hi, uint32_t bits) {
    if (bits >= 64) return true;
    int64_t min = -(1LL << (bits - 1)), max = (1LL << (bits - 1)) - 1;
    return lo >= min && hi <= max;
}

static inline bool Fits_In_Unsigned(int64_t lo, int64_t hi, uint32_t bits) {
    if (bits >= 64) return lo >= 0;
    return lo >= 0 && (uint64_t)hi < (1ULL << bits);
}

static inline uint32_t Bits_For_Range(int64_t lo, int64_t hi) {
    if (lo >= 0) {
        return (uint64_t)hi < 256ULL       ? Width_8  :
               (uint64_t)hi < 65536ULL     ? Width_16 :
               (uint64_t)hi < 4294967296ULL ? Width_32 : Width_64;
    }
    return Fits_In_Signed(lo, hi, 8)  ? Width_8  :
           Fits_In_Signed(lo, hi, 16) ? Width_16 :
           Fits_In_Signed(lo, hi, 32) ? Width_32 : Width_64;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §2. MEMORY ARENA — Bump Allocation for the Compilation Session
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Bump allocator for AST nodes and strings. All memory persists for the
 * compilation session — we trade fragmentation for simplicity.
 *
 * Avoiding malloc(32) is not important for performance.
 */

typedef struct Arena_Chunk Arena_Chunk;
struct Arena_Chunk {
    Arena_Chunk *previous;
    char        *base;
    char        *current;
    char        *end;
};

typedef struct {
    Arena_Chunk *head;
    size_t       chunk_size;
} Memory_Arena;

static Memory_Arena Global_Arena = {0};
enum { Default_Chunk_Size = 1 << 24 };  /* 16 MiB chunks */

static void *Arena_Allocate(size_t size) {
    size = Align_To(size, 8);

    if (!Global_Arena.head || Global_Arena.head->current + size > Global_Arena.head->end) {
        size_t chunk_size = Default_Chunk_Size;
        if (size > chunk_size) chunk_size = size + sizeof(Arena_Chunk);

        Arena_Chunk *chunk = malloc(sizeof(Arena_Chunk) + chunk_size);
        if (!chunk) { fprintf(stderr, "Out of memory\n"); exit(1); }

        chunk->previous = Global_Arena.head;
        chunk->base = chunk->current = (char*)(chunk + 1);
        chunk->end = chunk->base + chunk_size;
        Global_Arena.head = chunk;
    }

    void *result = Global_Arena.head->current;
    Global_Arena.head->current += size;
    return memset(result, 0, size);
}

static void Arena_Free_All(void) {
    Arena_Chunk *chunk = Global_Arena.head;
    while (chunk) {
        Arena_Chunk *prev = chunk->previous;
        free(chunk);
        chunk = prev;
    }
    Global_Arena.head = NULL;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §3. STRING SLICE — Non-Owning String Views
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * A slice is a pointer + length, borrowed from source or arena.
 * This avoids strlen() calls and enables substring views without allocation.
 */

typedef struct {
    const char *data;
    uint32_t    length;
} String_Slice;

#define S(literal) ((String_Slice){literal, sizeof(literal) - 1})
static const String_Slice Empty_Slice = {NULL, 0};

static inline String_Slice Slice_From_Cstring(const char *s) {
    return (String_Slice){s, s ? (uint32_t)strlen(s) : 0};
}

static String_Slice Slice_Duplicate(String_Slice s) {
    if (!s.length) return Empty_Slice;
    char *copy = Arena_Allocate(s.length + 1);
    memcpy(copy, s.data, s.length);
    return (String_Slice){copy, s.length};
}

static bool Slice_Equal_Ignore_Case(String_Slice a, String_Slice b) {
    if (a.length != b.length) return false;
    for (uint32_t i = 0; i < a.length; i++)
        if (To_Lower(a.data[i]) != To_Lower(b.data[i])) return false;
    return true;
}

/* FNV-1a hash with case folding for case-insensitive symbol lookup.
 * The constants are prime; their provenance is empirical, not divine. */
static uint64_t Slice_Hash(String_Slice s) {
    uint64_t h = 14695981039346656037ULL;
    for (uint32_t i = 0; i < s.length; i++)
        h = (h ^ (uint8_t)To_Lower(s.data[i])) * 1099511628211ULL;
    return h;
}

/* Levenshtein distance for "did you mean?" suggestions.
 * O(nm) is acceptable; identifiers are short, and errors are infrequent. */
__attribute__((unused))
static int Edit_Distance(String_Slice a, String_Slice b) {
    if (a.length > 20 || b.length > 20) return 100;
    int d[21][21];
    for (uint32_t i = 0; i <= a.length; i++) d[i][0] = (int)i;
    for (uint32_t j = 0; j <= b.length; j++) d[0][j] = (int)j;
    for (uint32_t i = 1; i <= a.length; i++)
        for (uint32_t j = 1; j <= b.length; j++) {
            int cost = To_Lower(a.data[i-1]) != To_Lower(b.data[j-1]);
            int del = d[i-1][j] + 1, ins = d[i][j-1] + 1, sub = d[i-1][j-1] + cost;
            d[i][j] = del < ins ? (del < sub ? del : sub) : (ins < sub ? ins : sub);
        }
    return d[a.length][b.length];
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §4. SOURCE LOCATION — Diagnostics to Source
 * ═══════════════════════════════════════════════════════════════════════════
 */

typedef struct {
    const char *filename;
    uint32_t    line;
    uint32_t    column;
} Source_Location;

static const Source_Location No_Location = {NULL, 0, 0};

/* ═══════════════════════════════════════════════════════════════════════════
 * §5. ERROR HANDLING — Diagnostic and message collection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Errors accumulate rather than immediately aborting, allowing the compiler
 * to report multiple issues in a single pass.
 */

static int Error_Count = 0;

static void Report_Error(Source_Location loc, const char *format, ...) {
    va_list args;
    va_start(args, format);
    fprintf(stderr, "%s:%u:%u: error: ",
            loc.filename ? loc.filename : "<unknown>", loc.line, loc.column);
    vfprintf(stderr, format, args);
    fputc('\n', stderr);
    va_end(args);
    Error_Count++;
}

__attribute__((unused, noreturn))
static void Fatal_Error(Source_Location loc, const char *format, ...) {
    va_list args;
    va_start(args, format);
    fprintf(stderr, "%s:%u:%u: INTERNAL ERROR: ",
            loc.filename ? loc.filename : "<unknown>", loc.line, loc.column);
    vfprintf(stderr, format, args);
    fputc('\n', stderr);
    va_end(args);
    exit(1);
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §6. BIG INTEGER — Arbitrary Precision for Literal Values
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Ada literals can exceed 64-bit range. We represent magnitudes as arrays
 * of 64-bit limbs (little-endian). For literal parsing, we only need:
 *   - Construction from decimal string
 *   - Multiply by small constant (base)
 *   - Add small constant (digit)
 *   - Comparison and extraction
 */

typedef struct {
    uint64_t *limbs;
    uint32_t  count;
    uint32_t  capacity;
    bool      is_negative;
} Big_Integer;

static Big_Integer *Big_Integer_New(uint32_t capacity) {
    Big_Integer *bi = Arena_Allocate(sizeof(Big_Integer));
    bi->limbs = Arena_Allocate(capacity * sizeof(uint64_t));
    bi->capacity = capacity;
    return bi;
}

static void Big_Integer_Ensure_Capacity(Big_Integer *bi, uint32_t needed) {
    if (needed <= bi->capacity) return;
    uint32_t new_cap = bi->capacity * 2;
    if (new_cap < needed) new_cap = needed;
    uint64_t *new_limbs = Arena_Allocate(new_cap * sizeof(uint64_t));
    memcpy(new_limbs, bi->limbs, bi->count * sizeof(uint64_t));
    bi->limbs = new_limbs;
    bi->capacity = new_cap;
}

/* Normalize: remove leading zero limbs, ensure zero is non-negative */
static void Big_Integer_Normalize(Big_Integer *bi) {
    while (bi->count > 0 && bi->limbs[bi->count - 1] == 0) bi->count--;
    if (bi->count == 0) bi->is_negative = false;
}

/* Multiply in-place by small factor and add small addend */
static void Big_Integer_Mul_Add_Small(Big_Integer *bi, uint64_t factor, uint64_t addend) {
    __uint128_t carry = addend;
    for (uint32_t i = 0; i < bi->count; i++) {
        carry += (__uint128_t)bi->limbs[i] * factor;
        bi->limbs[i] = (uint64_t)carry;
        carry >>= 64;
    }
    if (carry) {
        Big_Integer_Ensure_Capacity(bi, bi->count + 1);
        bi->limbs[bi->count++] = (uint64_t)carry;
    }
}

/* Check if value fits in int64_t and extract if so */
static bool Big_Integer_Fits_Int64(const Big_Integer *bi, int64_t *out) {
    if (bi->count == 0) { *out = 0; return true; }
    if (bi->count > 1) return false;
    uint64_t v = bi->limbs[0];
    if (bi->is_negative) {
        if (v > (uint64_t)INT64_MAX + 1) return false;
        *out = -(int64_t)v;
    } else {
        if (v > (uint64_t)INT64_MAX) return false;
        *out = (int64_t)v;
    }
    return true;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * §6.1 SIMD Big Integer Acceleration
 *
 * SIMD optimization for bigint operations, primarily targeting decimal parsing.
 * Instead of processing one digit at a time (mul by 10, add digit), we batch
 * process 8 digits at once (mul by 10^8, add 8-digit value).
 *
 * For example, eight ASCII digits can be converted to a 32-bit integer using:
 *   vpmaddubsw: Multiply adjacent bytes by weights, sum to words
 *   vpmaddwd:   Multiply adjacent words by weights, sum to dwords
 *   vphaddd:    Horizontal add for final reduction
 *
 * This turns O(n) multiply-add operations into O(n/8) for large literals.
 * ───────────────────────────────────────────────────────────────────────────── */

#ifdef SIMD_X86_64
/* Parse exactly 8 ASCII digits into a 32-bit integer using SIMD
 * Input: pointer to 8 ASCII digit characters ('0'-'9')
 * Output: 32-bit value in range [0, 99999999]
 *
 * Algorithm:
 *   1. Load 8 bytes, subtract '0' to get digit values 0-9
 *   2. vpmaddubsw with weights [10,1,10,1,10,1,10,1] gives 4 words:
 *      [d0*10+d1, d2*10+d3, d4*10+d5, d6*10+d7]
 *   3. vpmaddwd with weights [100,1,100,1] gives 2 dwords:
 *      [w0*100+w1, w2*100+w3]
 *   4. Final combine: dw0 * 10000 + dw1
 */
static inline uint32_t simd_parse_8_digits_avx2(const char *p) {
    uint32_t result;
    __asm__ volatile (

        /* Load 8 bytes into low portion of xmm0 */
        "vmovq (%[src]), %%xmm0\n\t"

        /* Broadcast '0' and subtract to get digit values */
        "vmovd %[zero], %%xmm1\n\t"
        "vpbroadcastb %%xmm1, %%xmm1\n\t"
        "vpsubb %%xmm1, %%xmm0, %%xmm0\n\t"

        /* Multiply-add bytes to words: weights [10,1,10,1,10,1,10,1] */
        "vmovq %[w1], %%xmm2\n\t"
        "vpmaddubsw %%xmm2, %%xmm0, %%xmm0\n\t"

        /* Multiply-add words to dwords: weights [100,1,100,1] */
        "vmovq %[w2], %%xmm2\n\t"
        "vpmaddwd %%xmm2, %%xmm0, %%xmm0\n\t"

        /* Extract two dwords and combine: dw0 * 10000 + dw1 */
        "vmovd %%xmm0, %%eax\n\t"
        "vpextrd $1, %%xmm0, %%edx\n\t"
        "imull $10000, %%eax\n\t"
        "addl %%edx, %%eax\n\t"

        : "=a" (result)
        : [src] "r" (p),
          [zero] "r" ((uint32_t)'0'),
          [w1] "r" (0x010A010A010A010AULL),  /* [10,1,10,1,10,1,10,1] as bytes (0x0A=10) */
          [w2] "r" (0x0001006400010064ULL)   /* [100,1,100,1] as words */
        : "xmm0", "xmm1", "xmm2", "edx", "memory"
    );
    return result;
}

/* Parse up to 16 ASCII digits using AVX2 (two 8-digit chunks)
 * Returns the number of digits parsed and the 64-bit value
 * Validates that all bytes are ASCII digits first
 */
static inline int simd_parse_digits_avx2(const char *p, const char *end, uint64_t *out) {
    int len = (end - p > 16) ? 16 : (int)(end - p);
    if (len < 8) {

        /* Fall back to scalar for small counts */
        uint64_t v = 0;
        int i = 0;
        while (i < len && p[i] >= '0' && p[i] <= '9') {
            v = v * 10 + (p[i] - '0');
            i++;
        }
        *out = v;
        return i;
    }

    /* Validate first eight are all digits using SIMD comparison */
    uint32_t valid_mask;
    __asm__ volatile (
        "vmovq (%[src]), %%xmm0\n\t"
        "vmovd %[lo], %%xmm1\n\t"
        "vpbroadcastb %%xmm1, %%xmm1\n\t"
        "vmovd %[hi], %%xmm2\n\t"
        "vpbroadcastb %%xmm2, %%xmm2\n\t"
        "vpcmpgtb %%xmm1, %%xmm0, %%xmm3\n\t"   /* c > '0'-1 */
        "vpcmpgtb %%xmm0, %%xmm2, %%xmm4\n\t"   /* '9'+1 > c */
        "vpand %%xmm3, %%xmm4, %%xmm0\n\t"
        "vpmovmskb %%xmm0, %[mask]\n\t"
        : [mask] "=r" (valid_mask)
        : [src] "r" (p), [lo] "r" ((uint32_t)('0' - 1)), [hi] "r" ((uint32_t)('9' + 1))
        : "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "memory"
    );

    /* Check if first 8 bytes are all digits */
    if ((valid_mask & 0xFF) != 0xFF) {
        /* Not all 8 are digits, fall back to scalar */
        uint64_t v = 0;
        int i = 0;
        while (i < len && p[i] >= '0' && p[i] <= '9') {
            v = v * 10 + (p[i] - '0');
            i++;
        }
        *out = v;
        return i;
    }

    uint32_t hi = simd_parse_8_digits_avx2(p);

    /* Try for 16 digits if we have enough input */
    if (len >= 16) {
        /* Validate next 8 */
        __asm__ volatile (
            "vmovq 8(%[src]), %%xmm0\n\t"
            "vmovd %[lo], %%xmm1\n\t"
            "vpbroadcastb %%xmm1, %%xmm1\n\t"
            "vmovd %[hi], %%xmm2\n\t"
            "vpbroadcastb %%xmm2, %%xmm2\n\t"
            "vpcmpgtb %%xmm1, %%xmm0, %%xmm3\n\t"
            "vpcmpgtb %%xmm0, %%xmm2, %%xmm4\n\t"
            "vpand %%xmm3, %%xmm4, %%xmm0\n\t"
            "vpmovmskb %%xmm0, %[mask]\n\t"
            : [mask] "=r" (valid_mask)
            : [src] "r" (p), [lo] "r" ((uint32_t)('0' - 1)), [hi] "r" ((uint32_t)('9' + 1))
            : "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "memory"
        );
        if ((valid_mask & 0xFF) == 0xFF) {
            uint32_t lo = simd_parse_8_digits_avx2(p + 8);
            *out = (uint64_t)hi * 100000000ULL + lo;
            return 16;
        }
    }

    /* Only 8 digits valid */
    *out = hi;
    return 8;
}
#endif /* SIMD_X86_64 */

/* SIMD-accelerated decimal to big integer conversion
 * Processes 8 digits at a time when possible for large numbers
 */
static Big_Integer *Big_Integer_From_Decimal_SIMD(const char *str) {
    Big_Integer *bi = Big_Integer_New(4);
    bi->is_negative = (*str == '-');
    if (*str == '-' || *str == '+') str++;

    /* Skip leading zeros */
    while (*str == '0') str++;
    if (*str == '\0' || (*str < '0' || *str > '9')) {
        bi->limbs[0] = 0;
        bi->count = 1;
        Big_Integer_Normalize(bi);
        return bi;
    }

    /* Find end of digit string */
    const char *end = str;
    while (*end >= '0' && *end <= '9') end++;

#ifdef SIMD_X86_64
    Simd_Detect_Features();
    if (Simd_Has_Avx2) {
        /* Initialize bigint with first chunk */
        bi->limbs[0] = 0;
        bi->count = 1;

        const char *p = str;
        while (p < end) {
            int remaining = (int)(end - p);
            if (remaining >= 8) {
                /* Process 8 or 16 digits at once */
                uint64_t chunk;
                int parsed = simd_parse_digits_avx2(p, end, &chunk);
                if (parsed == 16) {
                    /* Multiply by 10^16 and add 16-digit value */
                    Big_Integer_Mul_Add_Small(bi, 10000000000000000ULL, chunk);
                    p += 16;
                } else if (parsed == 8) {
                    /* Multiply by 10^8 and add 8-digit value */
                    Big_Integer_Mul_Add_Small(bi, 100000000ULL, chunk);
                    p += 8;
                } else {
                    /* Partial - process one digit */
                    Big_Integer_Mul_Add_Small(bi, 10, (uint64_t)(*p - '0'));
                    p++;
                }
            } else {
                /* Remaining digits one at a time */
                Big_Integer_Mul_Add_Small(bi, 10, (uint64_t)(*p - '0'));
                p++;
            }
        }
        Big_Integer_Normalize(bi);
        return bi;
    }
#endif

    /* Scalar fallback */
    bi->limbs[0] = 0;
    bi->count = 1;
    while (str < end) {
        Big_Integer_Mul_Add_Small(bi, 10, (uint64_t)(*str - '0'));
        str++;
    }
    Big_Integer_Normalize(bi);
    return bi;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §6.2 BIG_REAL — Arbitrary Precision Real Numbers
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Represents real literals with arbitrary precision per Ada LRM §2.4.1.
 * Structure: significand × 10^exponent
 *
 * Example: 3.14159_26535_89793 is stored as:
 *   significand = 314159265358979 (Big_Integer)
 *   exponent = -14 (decimal point position)
 *
 * This allows exact representation of literals like Pi to any precision.
 * The rounding error is in the conversion, not the representation.
 */

typedef struct {
    Big_Integer *significand;  /* All digits without decimal point */
    int32_t      exponent;     /* Power of 10 (negative for fractional) */
} Big_Real;

static Big_Real *Big_Real_New(void) {
    Big_Real *br = Arena_Allocate(sizeof(Big_Real));
    br->significand = Big_Integer_New(4);
    br->exponent = 0;
    return br;
}

/* Parse a real literal into arbitrary precision Big_Real
 * Handles: 3.14, 3.14E-10, 3.14159_26535_89793_23846_26433_83279
 */
static Big_Real *Big_Real_From_String(const char *str) {
    Big_Real *br = Big_Real_New();
    br->significand->is_negative = (*str == '-');
    if (*str == '-' || *str == '+') str++;

    /* Collect all digits (ignoring decimal point and underscores) */
    char clean[512];
    int clean_len = 0;
    int decimal_pos = -1;  /* Position of decimal point in digit sequence */
    int digit_count = 0;

    while (*str && *str != 'E' && *str != 'e') {
        if (*str == '.') {
            decimal_pos = digit_count;
        } else if (*str >= '0' && *str <= '9') {
            if (clean_len < (int)sizeof(clean) - 1) {
                clean[clean_len++] = *str;
            }
            digit_count++;
        }
        /* Skip underscores */
        str++;
    }
    clean[clean_len] = '\0';

    /* Parse exponent if present */
    int exp = 0;
    if (*str == 'E' || *str == 'e') {
        str++;
        int exp_sign = 1;
        if (*str == '-') { exp_sign = -1; str++; }
        else if (*str == '+') str++;
        while (*str >= '0' && *str <= '9') {
            exp = exp * 10 + (*str - '0');
            str++;
        }
        exp *= exp_sign;
    }

    /* Calculate final exponent:
     *
     * If decimal at position 3 in "314159" (for 3.14159), exponent = 3 - 6 = -3
     * Then add any explicit exponent
     */
    if (decimal_pos >= 0) {
        br->exponent = exp + (decimal_pos - digit_count);
    } else {
        br->exponent = exp;
    }

    /* Parse significand digits using existing Big_Integer parsing */
    br->significand = Big_Integer_From_Decimal_SIMD(clean);
    return br;
}

/* Convert Big_Real to double (for compatibility with existing code) */
static double Big_Real_To_Double(const Big_Real *br) {
    if (br->significand->count == 0) return 0.0;

    /* Extract significand as double */
    double sig = 0.0;
    for (int i = (int)br->significand->count - 1; i >= 0; i--) {
        sig = sig * 18446744073709551616.0 + (double)br->significand->limbs[i];
    }
    if (br->significand->is_negative) sig = -sig;

    /* Apply exponent */
    if (br->exponent > 0) {
        for (int i = 0; i < br->exponent; i++) sig *= 10.0;
    } else if (br->exponent < 0) {
        for (int i = 0; i < -br->exponent; i++) sig /= 10.0;
    }
    return sig;
}

/* Check if Big_Real fits in a double without precision loss
 * Returns true if the significand has <= 15 significant digits
 */
static bool Big_Real_Fits_Double(const Big_Real *br) {
    if (br->significand->count == 0) return true;
    if (br->significand->count > 1) return false;
    /* 15 decimal digits fit in a double's 53-bit mantissa */
    return br->significand->limbs[0] < 1000000000000000ULL;
}

/* Convert Big_Real to hexadecimal float format for precise LLVM IR emission
 * LLVM accepts: 0xHHHHHHHHHHHHHHHH (IEEE 754 double hex encoding)
 * This preserves full precision unlike %f format
 */
static void Big_Real_To_Hex(const Big_Real *br, char *buf, size_t bufsize) {
    if (!br || br->significand->count == 0) {
        snprintf(buf, bufsize, "0.0");
        return;
    }
    /* Convert to double and extract IEEE 754 bits */
    double d = Big_Real_To_Double(br);
    uint64_t bits;
    memcpy(&bits, &d, sizeof(bits));
    snprintf(buf, bufsize, "0x%016llX", (unsigned long long)bits);
}

/* Compare two Big_Real values: returns -1, 0, or 1 */
static int Big_Real_Compare(const Big_Real *a, const Big_Real *b) {
    if (!a || !b) return 0;

    /* Normalize to same exponent and compare significands */
    /* For now, use double comparison - sufficient for most cases */
    double da = Big_Real_To_Double(a);
    double db = Big_Real_To_Double(b);
    if (da < db) return -1;
    if (da > db) return 1;
    return 0;
}

/* Multiply Big_Real by power of 10 (for exponent adjustment) */
static Big_Real *Big_Real_Scale(const Big_Real *br, int32_t scale) {
    if (!br) return NULL;
    Big_Real *result = Big_Real_New();
    result->significand = Big_Integer_New(br->significand->capacity);
    result->significand->count = br->significand->count;
    result->significand->is_negative = br->significand->is_negative;
    memcpy(result->significand->limbs, br->significand->limbs,
           br->significand->count * sizeof(uint64_t));
    result->exponent = br->exponent + scale;
    return result;
}

/* Divide Big_Real by integer (for fixed-point SMALL calculation)
 * Returns result = a / divisor
 * Uses arbitrary precision for intermediate calculation
 */
static Big_Real *Big_Real_Divide_Int(const Big_Real *a, int64_t divisor) {
    if (!a || divisor == 0) return NULL;
    /* For exact division: multiply significand precision and divide */
    /* Result = (significand * 10^precision) / divisor × 10^(exponent-precision) */
    int precision = 30;  /* Extra decimal places for precision */

    Big_Real *result = Big_Real_New();
    result->significand = Big_Integer_New(a->significand->capacity + 4);

    /* Copy significand and multiply by 10^precision */
    result->significand->count = a->significand->count;
    result->significand->is_negative = a->significand->is_negative ^ (divisor < 0);
    memcpy(result->significand->limbs, a->significand->limbs,
           a->significand->count * sizeof(uint64_t));

    for (int i = 0; i < precision; i++) {
        Big_Integer_Mul_Add_Small(result->significand, 10, 0);
    }

    /* Divide by absolute value of divisor */
    uint64_t d = divisor < 0 ? -divisor : divisor;
    uint64_t remainder = 0;
    for (int i = (int)result->significand->count - 1; i >= 0; i--) {
        __uint128_t val = ((__uint128_t)remainder << 64) | result->significand->limbs[i];
        result->significand->limbs[i] = (uint64_t)(val / d);
        remainder = (uint64_t)(val % d);
    }
    Big_Integer_Normalize(result->significand);

    result->exponent = a->exponent - precision;
    return result;
}

/* Multiply two Big_Real values
 * Result = a × b with full precision
 */
static Big_Real *Big_Real_Multiply(const Big_Real *a, const Big_Real *b) {
    if (!a || !b) return NULL;

    Big_Real *result = Big_Real_New();
    uint32_t new_count = a->significand->count + b->significand->count;
    result->significand = Big_Integer_New(new_count + 1);
    result->significand->count = new_count;
    result->significand->is_negative =
        a->significand->is_negative ^ b->significand->is_negative;
    memset(result->significand->limbs, 0, new_count * sizeof(uint64_t));

    /* Textbook multiplication */
    for (uint32_t i = 0; i < a->significand->count; i++) {
        __uint128_t carry = 0;
        for (uint32_t j = 0; j < b->significand->count; j++) {
            __uint128_t prod = (__uint128_t)a->significand->limbs[i] *
                               b->significand->limbs[j] +
                               result->significand->limbs[i + j] + carry;
            result->significand->limbs[i + j] = (uint64_t)prod;
            carry = prod >> 64;
        }
        if (carry && i + b->significand->count < new_count) {
            result->significand->limbs[i + b->significand->count] = (uint64_t)carry;
        }
    }
    Big_Integer_Normalize(result->significand);

    result->exponent = a->exponent + b->exponent;
    return result;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §7. LEXER — Transform Characters into Tokens
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * The lexer maintains a cursor over the source buffer and produces tokens
 * on demand. Ada lexical rules from RM §2.
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §7.1 Token Kinds — Ada lexicon
 * ───────────────────────────────────────────────────────────────────────── */

typedef enum {
    /* Sentinel & error */
    TK_EOF = 0, TK_ERROR,

    /* Literals */
    TK_IDENTIFIER, TK_INTEGER, TK_REAL, TK_CHARACTER, TK_STRING,

    /* Delimiters */
    TK_LPAREN, TK_RPAREN, TK_LBRACKET, TK_RBRACKET,
    TK_COMMA, TK_DOT, TK_SEMICOLON, TK_COLON, TK_TICK,

    /* Compound delimiters */
    TK_ASSIGN, TK_ARROW, TK_DOTDOT, TK_LSHIFT, TK_RSHIFT, TK_BOX, TK_BAR,

    /* Operators */
    TK_EQ, TK_NE, TK_LT, TK_LE, TK_GT, TK_GE,
    TK_PLUS, TK_MINUS, TK_STAR, TK_SLASH, TK_AMPERSAND, TK_EXPON,

    /* Reserved words (Ada 83) */
    TK_ABORT, TK_ABS, TK_ACCEPT, TK_ACCESS, TK_ALL, TK_AND, TK_AND_THEN,
    TK_ARRAY, TK_AT, TK_BEGIN, TK_BODY, TK_CASE, TK_CONSTANT, TK_DECLARE,
    TK_DELAY, TK_DELTA, TK_DIGITS, TK_DO, TK_ELSE, TK_ELSIF, TK_END,
    TK_ENTRY, TK_EXCEPTION, TK_EXIT, TK_FOR, TK_FUNCTION, TK_GENERIC,
    TK_GOTO, TK_IF, TK_IN, TK_IS, TK_LIMITED, TK_LOOP, TK_MOD, TK_NEW,
    TK_NOT, TK_NULL, TK_OF, TK_OR, TK_OR_ELSE, TK_OTHERS, TK_OUT,
    TK_PACKAGE, TK_PRAGMA, TK_PRIVATE, TK_PROCEDURE, TK_RAISE, TK_RANGE,
    TK_RECORD, TK_REM, TK_RENAMES, TK_RETURN, TK_REVERSE, TK_SELECT,
    TK_SEPARATE, TK_SUBTYPE, TK_TASK, TK_TERMINATE, TK_THEN, TK_TYPE,
    TK_USE, TK_WHEN, TK_WHILE, TK_WITH, TK_XOR,

    TK_COUNT
} Token_Kind;

/* Token kind names for diagnostics */
static const char *Token_Name[TK_COUNT] = {
    [TK_EOF]="<eof>", [TK_ERROR]="<error>", [TK_IDENTIFIER]="identifier",
    [TK_INTEGER]="integer", [TK_REAL]="real", [TK_CHARACTER]="character",
    [TK_STRING]="string", [TK_LPAREN]="(", [TK_RPAREN]=")", [TK_LBRACKET]="[",
    [TK_RBRACKET]="]", [TK_COMMA]=",", [TK_DOT]=".", [TK_SEMICOLON]=";",
    [TK_COLON]=":", [TK_TICK]="'", [TK_ASSIGN]=":=", [TK_ARROW]="=>",
    [TK_DOTDOT]="..", [TK_LSHIFT]="<<", [TK_RSHIFT]=">>", [TK_BOX]="<>",
    [TK_BAR]="|", [TK_EQ]="=", [TK_NE]="/=", [TK_LT]="<", [TK_LE]="<=",
    [TK_GT]=">", [TK_GE]=">=", [TK_PLUS]="+", [TK_MINUS]="-", [TK_STAR]="*",
    [TK_SLASH]="/", [TK_AMPERSAND]="&", [TK_EXPON]="**",
    [TK_ABORT]="ABORT", [TK_ABS]="ABS", [TK_ACCEPT]="ACCEPT",
    [TK_ACCESS]="ACCESS", [TK_ALL]="ALL", [TK_AND]="AND",
    [TK_AND_THEN]="AND THEN", [TK_ARRAY]="ARRAY", [TK_AT]="AT",
    [TK_BEGIN]="BEGIN", [TK_BODY]="BODY", [TK_CASE]="CASE",
    [TK_CONSTANT]="CONSTANT", [TK_DECLARE]="DECLARE", [TK_DELAY]="DELAY",
    [TK_DELTA]="DELTA", [TK_DIGITS]="DIGITS", [TK_DO]="DO", [TK_ELSE]="ELSE",
    [TK_ELSIF]="ELSIF", [TK_END]="END", [TK_ENTRY]="ENTRY",
    [TK_EXCEPTION]="EXCEPTION", [TK_EXIT]="EXIT", [TK_FOR]="FOR",
    [TK_FUNCTION]="FUNCTION", [TK_GENERIC]="GENERIC", [TK_GOTO]="GOTO",
    [TK_IF]="IF", [TK_IN]="IN", [TK_IS]="IS", [TK_LIMITED]="LIMITED",
    [TK_LOOP]="LOOP", [TK_MOD]="MOD", [TK_NEW]="NEW", [TK_NOT]="NOT",
    [TK_NULL]="NULL", [TK_OF]="OF", [TK_OR]="OR", [TK_OR_ELSE]="OR ELSE",
    [TK_OTHERS]="OTHERS", [TK_OUT]="OUT", [TK_PACKAGE]="PACKAGE",
    [TK_PRAGMA]="PRAGMA", [TK_PRIVATE]="PRIVATE", [TK_PROCEDURE]="PROCEDURE",
    [TK_RAISE]="RAISE", [TK_RANGE]="RANGE", [TK_RECORD]="RECORD",
    [TK_REM]="REM", [TK_RENAMES]="RENAMES", [TK_RETURN]="RETURN",
    [TK_REVERSE]="REVERSE", [TK_SELECT]="SELECT", [TK_SEPARATE]="SEPARATE",
    [TK_SUBTYPE]="SUBTYPE", [TK_TASK]="TASK", [TK_TERMINATE]="TERMINATE",
    [TK_THEN]="THEN", [TK_TYPE]="TYPE", [TK_USE]="USE", [TK_WHEN]="WHEN",
    [TK_WHILE]="WHILE", [TK_WITH]="WITH", [TK_XOR]="XOR"
};

/* Keyword lookup table — sorted for potential binary search, but linear is fine for 63 keywords */
static struct { String_Slice name; Token_Kind kind; } Keywords[] = {
    {S("abort"),TK_ABORT},{S("abs"),TK_ABS},{S("accept"),TK_ACCEPT},{S("access"),TK_ACCESS},
    {S("all"),TK_ALL},{S("and"),TK_AND},{S("array"),TK_ARRAY},{S("at"),TK_AT},
    {S("begin"),TK_BEGIN},{S("body"),TK_BODY},{S("case"),TK_CASE},{S("constant"),TK_CONSTANT},
    {S("declare"),TK_DECLARE},{S("delay"),TK_DELAY},{S("delta"),TK_DELTA},{S("digits"),TK_DIGITS},
    {S("do"),TK_DO},{S("else"),TK_ELSE},{S("elsif"),TK_ELSIF},{S("end"),TK_END},
    {S("entry"),TK_ENTRY},{S("exception"),TK_EXCEPTION},{S("exit"),TK_EXIT},{S("for"),TK_FOR},
    {S("function"),TK_FUNCTION},{S("generic"),TK_GENERIC},{S("goto"),TK_GOTO},{S("if"),TK_IF},
    {S("in"),TK_IN},{S("is"),TK_IS},{S("limited"),TK_LIMITED},{S("loop"),TK_LOOP},
    {S("mod"),TK_MOD},{S("new"),TK_NEW},{S("not"),TK_NOT},{S("null"),TK_NULL},
    {S("of"),TK_OF},{S("or"),TK_OR},{S("others"),TK_OTHERS},{S("out"),TK_OUT},
    {S("package"),TK_PACKAGE},{S("pragma"),TK_PRAGMA},{S("private"),TK_PRIVATE},
    {S("procedure"),TK_PROCEDURE},{S("raise"),TK_RAISE},{S("range"),TK_RANGE},
    {S("record"),TK_RECORD},{S("rem"),TK_REM},{S("renames"),TK_RENAMES},{S("return"),TK_RETURN},
    {S("reverse"),TK_REVERSE},{S("select"),TK_SELECT},{S("separate"),TK_SEPARATE},
    {S("subtype"),TK_SUBTYPE},{S("task"),TK_TASK},{S("terminate"),TK_TERMINATE},
    {S("then"),TK_THEN},{S("type"),TK_TYPE},{S("use"),TK_USE},{S("when"),TK_WHEN},
    {S("while"),TK_WHILE},{S("with"),TK_WITH},{S("xor"),TK_XOR},
    {Empty_Slice, TK_EOF}  /* Sentinel */
};

static Token_Kind Lookup_Keyword(String_Slice name) {
    for (int i = 0; Keywords[i].name.data; i++)
        if (Slice_Equal_Ignore_Case(name, Keywords[i].name))
            return Keywords[i].kind;
    return TK_IDENTIFIER;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §7.2 Token Structure
 * ───────────────────────────────────────────────────────────────────────── */

typedef struct {
    Token_Kind      kind;
    Source_Location location;
    String_Slice    text;

    /* Semantic value (valid based on kind) */
    union {
        int64_t      integer_value;
        double       float_value;
    };
    union {
        Big_Integer *big_integer;
        Big_Real    *big_real;     /* Arbitrary precision real literal */
    };
} Token;

/* ─────────────────────────────────────────────────────────────────────────
 * §7.3 Lexer State
 * ───────────────────────────────────────────────────────────────────────── */

typedef struct {
    const char *source_start;
    const char *current;
    const char *source_end;
    const char *filename;
    uint32_t    line;
    uint32_t    column;
    Token_Kind  prev_token_kind;  /* Track previous token for context-sensitive lexing */
} Lexer;

static Lexer Lexer_New(const char *source, size_t length, const char *filename) {
    return (Lexer){source, source, source + length, filename, 1, 1};
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §7.3.1 SIMD-Accelerated Scanning Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Four ??? paths: x86-64 (AVX2/SSE4.2), ARM64 (NEON), RISC ???, and
 * scalar fallback.
 * These functions find interesting bytes without character-by-character loops.
 */

#ifdef SIMD_X86_64
/* ─────────────────────────────────────────────────────────────────────────────
 * x86-64 AVX-512/AVX2 SIMD Lexer Acceleration
 *
 * Features:
 *   - AVX-512BW: 64-byte processing with k-mask registers
 *   - AVX2: 32-byte processing with optimized instruction scheduling
 *   - Software prefetching (prefetcht0) for memory-bound operations
 *   - Loop unrolling for better instruction-level parallelism
 *   - BMI2 TZCNT for fast trailing zero count (find first non-match)
 *
 * Architecture:
 *   - Simd_Skip_Whitespace: Skip space (0x20) and C0 controls (0x09-0x0D)
 *   - Simd_Find_Char_X86: Generic single-character search (newline, quotes)
 *   - Simd_Scan_Identifier: Match [a-zA-Z0-9_] character class
 *   - Simd_Scan_Digits: Match [0-9_] for numeric literals
 * ───────────────────────────────────────────────────────────────────────────── */

/* Raw assembly bit-scan helpers - BMI2 TZCNT instruction */
static inline uint32_t Tzcnt32(uint32_t v) {
    uint32_t r;
    __asm__ ("tzcntl %1, %0" : "=r" (r) : "r" (v));
    return r;
}

static inline uint64_t Tzcnt64(uint64_t v) {
    uint64_t r;
    __asm__ ("tzcntq %1, %0" : "=r" (r) : "r" (v));
    return r;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * AVX-512 Whitespace Skip
 *
 * Processes 64 bytes at a time using k-mask registers.
 * Matches: space (0x20) OR range 0x09-0x0D (tab, LF, VT, FF, CR)
 * Only compiled when targeting AVX-512 capable CPUs.
 * ───────────────────────────────────────────────────────────────────────────── */
#ifdef __AVX512BW__
static inline const char *Simd_Skip_Whitespace_Avx512(const char *p, const char *end) {
    while (p + 64 <= end) {
        uint64_t mask;
        __asm__ volatile (
            "prefetcht0 128(%[src])\n\t"           /* Prefetch next cache line */
            "vmovdqu8 (%[src]), %%zmm0\n\t"        /* Load 64 bytes */
            "vpbroadcastb %[space], %%zmm1\n\t"   /* Broadcast space char */
            "vpcmpeqb %%zmm1, %%zmm0, %%k1\n\t"   /* k1 = (c == ' ') */
            "vpbroadcastb %[lo], %%zmm2\n\t"      /* Broadcast 0x08 */
            "vpbroadcastb %[hi], %%zmm3\n\t"      /* Broadcast 0x0E */
            "vpcmpgtb %%zmm2, %%zmm0, %%k2\n\t"   /* k2 = (c > 0x08) */
            "vpcmpgtb %%zmm0, %%zmm3, %%k3\n\t"   /* k3 = (0x0E > c) */
            "kandd %%k2, %%k3, %%k2\n\t"          /* k2 = in range [0x09,0x0D] */
            "kord %%k1, %%k2, %%k0\n\t"           /* k0 = whitespace mask */
            "kmovq %%k0, %[mask]\n\t"             /* Extract to GPR */
            : [mask] "=r" (mask)
            : [src] "r" (p), [space] "r" ((uint32_t)' '),
              [lo] "r" ((uint32_t)0x08), [hi] "r" ((uint32_t)0x0E)
            : "zmm0", "zmm1", "zmm2", "zmm3", "k0", "k1", "k2", "k3", "memory"
        );
        /* If any non-whitespace found, return its position */
        if (~mask) {
            uint64_t inv = ~mask;
            __asm__ volatile ("tzcntq %1, %0" : "=r" (inv) : "r" (inv));
            return p + inv;
        }
        p += 64;
    }
    return p;
}
#endif /* __AVX512BW__ */

/* ─────────────────────────────────────────────────────────────────────────────
 * AVX2 Whitespace Skip with 2x Unrolling
 *
 * Processes 64 bytes (2x32) per iteration for better throughput.
 * Falls back to single 32-byte chunks for remaining data.
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Skip_Whitespace_Avx2(const char *p, const char *end) {

    /* 2x unrolled: process 64 bytes per iteration */
    while (p + 64 <= end) {
        uint32_t m0, m1;
        __asm__ volatile (
            "prefetcht0 128(%[src])\n\t"
            /* Load two 32-byte chunks in parallel */
            "vmovdqu (%[src]), %%ymm0\n\t"
            "vmovdqu 32(%[src]), %%ymm8\n\t"
            /* Broadcast constants once, reuse for both chunks */
            "vmovd %[space], %%xmm1\n\t"
            "vpbroadcastb %%xmm1, %%ymm1\n\t"
            "vmovd %[lo], %%xmm2\n\t"
            "vpbroadcastb %%xmm2, %%ymm2\n\t"
            "vmovd %[hi], %%xmm3\n\t"
            "vpbroadcastb %%xmm3, %%ymm3\n\t"
            /* First chunk comparison */
            "vpcmpeqb %%ymm1, %%ymm0, %%ymm5\n\t"   /* space match */
            "vpcmpgtb %%ymm2, %%ymm0, %%ymm6\n\t"   /* > 0x08 */
            "vpcmpgtb %%ymm0, %%ymm3, %%ymm7\n\t"   /* < 0x0E */
            /* Second chunk comparison (parallel with first) */
            "vpcmpeqb %%ymm1, %%ymm8, %%ymm9\n\t"
            "vpcmpgtb %%ymm2, %%ymm8, %%ymm10\n\t"
            "vpcmpgtb %%ymm8, %%ymm3, %%ymm11\n\t"
            /* Combine results */
            "vpand %%ymm6, %%ymm7, %%ymm6\n\t"
            "vpor %%ymm5, %%ymm6, %%ymm0\n\t"
            "vpand %%ymm10, %%ymm11, %%ymm10\n\t"
            "vpor %%ymm9, %%ymm10, %%ymm8\n\t"
            /* Extract masks */
            "vpmovmskb %%ymm0, %[m0]\n\t"
            "vpmovmskb %%ymm8, %[m1]\n\t"
            "vzeroupper\n\t"
            : [m0] "=r" (m0), [m1] "=r" (m1)
            : [src] "r" (p), [space] "r" ((uint32_t)' '),
              [lo] "r" ((uint32_t)0x08), [hi] "r" ((uint32_t)0x0E)
            : "ymm0", "ymm1", "ymm2", "ymm3", "ymm5", "ymm6", "ymm7",
              "ymm8", "ymm9", "ymm10", "ymm11", "memory"
        );
        if (m0 != 0xFFFFFFFF) return p + Tzcnt32(~m0);
        if (m1 != 0xFFFFFFFF) return p + 32 + Tzcnt32(~m1);
        p += 64;
    }

    /* Handle remaining 32-byte chunk */
    while (p + 32 <= end) {
        uint32_t mask;
        __asm__ volatile (
            "vmovdqu (%[src]), %%ymm0\n\t"
            "vmovd %[space], %%xmm1\n\t"
            "vpbroadcastb %%xmm1, %%ymm1\n\t"
            "vmovd %[lo], %%xmm2\n\t"
            "vpbroadcastb %%xmm2, %%ymm2\n\t"
            "vmovd %[hi], %%xmm3\n\t"
            "vpbroadcastb %%xmm3, %%ymm3\n\t"
            "vpcmpeqb %%ymm1, %%ymm0, %%ymm5\n\t"
            "vpcmpgtb %%ymm2, %%ymm0, %%ymm6\n\t"
            "vpcmpgtb %%ymm0, %%ymm3, %%ymm7\n\t"
            "vpand %%ymm6, %%ymm7, %%ymm6\n\t"
            "vpor %%ymm5, %%ymm6, %%ymm0\n\t"
            "vpmovmskb %%ymm0, %[mask]\n\t"
            "vzeroupper\n\t"
            : [mask] "=r" (mask)
            : [src] "r" (p), [space] "r" ((uint32_t)' '),
              [lo] "r" ((uint32_t)0x08), [hi] "r" ((uint32_t)0x0E)
            : "ymm0", "ymm1", "ymm2", "ymm3", "ymm5", "ymm6", "ymm7", "memory"
        );
        if (mask != 0xFFFFFFFF) return p + Tzcnt32(~mask);
        p += 32;
    }
    return p;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Whitespace Skip Dispatcher
 *
 * Selects best SIMD path at runtime based on CPU features.
 * Falls through to scalar loop for remaining bytes.
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Skip_Whitespace(const char *p, const char *end) {
    Simd_Detect_Features();
#ifdef __AVX512BW__
    if (Simd_Has_Avx512 && (end - p) >= 64) {
        p = Simd_Skip_Whitespace_Avx512(p, end);
    }
#endif
    if (Simd_Has_Avx2 && (end - p) >= 32) {
        p = Simd_Skip_Whitespace_Avx2(p, end);
    }
    /* Scalar tail for remaining bytes */
    while (p < end) {
        unsigned char c = (unsigned char)*p;
        if (c != ' ' && (c < 0x09 || c > 0x0D)) break;
        p++;
    }
    return p;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Generic Single-Character Search
 *
 * Searches for a specific character (newline, quote, etc.).
 * Used as building block for Simd_Find_Newline, Simd_Find_Quote, etc.
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Find_Char_X86(const char *p, const char *end, char ch) {

    /* Fast path: scalar check for first 16 bytes (covers most short comments/strings) */
    for (int i = 0; i < 16 && p + i < end; i++) {
        if (p[i] == ch) return p + i;
    }
    if (p + 16 >= end) {
        /* Short remaining buffer - finish with scalar */
        p += 16;
        while (p < end && *p != ch) p++;
        return p;
    }
    p += 16;  /* Fast path didn't find it, continue with SIMD */

    Simd_Detect_Features();
#ifdef __AVX512BW__
    /* AVX-512: 64 bytes at a time */
    if (Simd_Has_Avx512) {
        while (p + 64 <= end) {
            uint64_t mask;
            __asm__ volatile (
                "vmovdqu8 (%[src]), %%zmm0\n\t"
                "vpbroadcastb %[c], %%zmm1\n\t"
                "vpcmpeqb %%zmm1, %%zmm0, %%k0\n\t"
                "kmovq %%k0, %[mask]\n\t"
                : [mask] "=r" (mask)
                : [src] "r" (p), [c] "r" ((uint32_t)ch)
                : "zmm0", "zmm1", "k0", "memory"
            );
            if (mask) {
                __asm__ volatile ("tzcntq %1, %0" : "=r" (mask) : "r" (mask));
                return p + mask;
            }
            p += 64;
        }
    }
#endif
    /* AVX2: 32 bytes at a time */
    while (p + 32 <= end) {
        uint32_t mask;
        __asm__ volatile (
            "vmovdqu (%[src]), %%ymm0\n\t"
            "vmovd %[c], %%xmm1\n\t"
            "vpbroadcastb %%xmm1, %%ymm1\n\t"
            "vpcmpeqb %%ymm1, %%ymm0, %%ymm0\n\t"
            "vpmovmskb %%ymm0, %[mask]\n\t"
            "vzeroupper\n\t"
            : [mask] "=r" (mask)
            : [src] "r" (p), [c] "r" ((uint32_t)ch)
            : "ymm0", "ymm1", "memory"
        );
        if (mask) return p + Tzcnt32(mask);
        p += 32;
    }
    /* Scalar tail */
    while (p < end && *p != ch) p++;
    return p;
}

/* Convenience wrappers for common character searches */
static inline const char *Simd_Find_Newline(const char *p, const char *end) {
    return Simd_Find_Char_X86(p, end, '\n');
}

static inline const char *Simd_Find_Quote(const char *p, const char *end) {
    return Simd_Find_Char_X86(p, end, '\'');
}

static inline const char *Simd_Find_Double_Quote(const char *p, const char *end) {
    return Simd_Find_Char_X86(p, end, '"');
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Identifier Character Class Scanner
 *
 * Uses fast table lookup for first 8 chars (covers most identifiers),
 * then SIMD only for long identifiers. Benchmarked 50% faster than pure SIMD ???
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Scan_Identifier(const char *p, const char *end) {
    /* Fast path: unrolled table lookup for first 8 chars (covers most identifiers) */
    if (p >= end || !Is_Id_Char(*p)) return p;
    if (p + 1 >= end || !Is_Id_Char(p[1])) return p + 1;
    if (p + 2 >= end || !Is_Id_Char(p[2])) return p + 2;
    if (p + 3 >= end || !Is_Id_Char(p[3])) return p + 3;
    if (p + 4 >= end || !Is_Id_Char(p[4])) return p + 4;
    if (p + 5 >= end || !Is_Id_Char(p[5])) return p + 5;
    if (p + 6 >= end || !Is_Id_Char(p[6])) return p + 6;
    if (p + 7 >= end || !Is_Id_Char(p[7])) return p + 7;

    /* Long identifier (> 8 chars) - continue with table lookup */
    p += 8;
    while (p < end && Is_Id_Char(*p)) p++;
    return p;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * Digit Scanner for Numeric Literals
 *
 * Matches [0-9_] - digits with optional underscores (Ada numeric syntax).
 * Returns pointer to first non-digit character.
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Scan_Digits(const char *p, const char *end) {
    Simd_Detect_Features();
#ifdef __AVX512BW__
    /* AVX-512 path */
    if (Simd_Has_Avx512) {
        while (p + 64 <= end) {
            uint64_t mask;
            __asm__ volatile (
                "vmovdqu8 (%[src]), %%zmm0\n\t"
                "vpbroadcastb %[lo], %%zmm1\n\t"
                "vpbroadcastb %[hi], %%zmm2\n\t"
                "vpbroadcastb %[u], %%zmm3\n\t"
                "vpcmpgtb %%zmm1, %%zmm0, %%k1\n\t"     /* c > '0'-1 */
                "vpcmpgtb %%zmm0, %%zmm2, %%k2\n\t"     /* '9'+1 > c */
                "kandd %%k1, %%k2, %%k3\n\t"            /* digit */
                "vpcmpeqb %%zmm3, %%zmm0, %%k4\n\t"     /* underscore */
                "kord %%k3, %%k4, %%k0\n\t"             /* combine */
                "kmovq %%k0, %[mask]\n\t"
                : [mask] "=r" (mask)
                : [src] "r" (p),
                  [lo] "r" ((uint32_t)('0'-1)),
                  [hi] "r" ((uint32_t)('9'+1)),
                  [u] "r" ((uint32_t)'_')
                : "zmm0", "zmm1", "zmm2", "zmm3", "k0", "k1", "k2", "k3", "k4", "memory"
            );
            if (~mask) {
                __asm__ volatile ("tzcntq %1, %0" : "=r" (mask) : "r" (~mask));
                return p + mask;
            }
            p += 64;
        }
    }
#endif
    /* AVX2 path */
    while (p + 32 <= end) {
        uint32_t mask;
        __asm__ volatile (
            "vmovdqu (%[src]), %%ymm0\n\t"
            "vmovd %[lo], %%xmm1\n\t"
            "vpbroadcastb %%xmm1, %%ymm1\n\t"
            "vmovd %[hi], %%xmm2\n\t"
            "vpbroadcastb %%xmm2, %%ymm2\n\t"
            "vpcmpgtb %%ymm1, %%ymm0, %%ymm3\n\t"
            "vpcmpgtb %%ymm0, %%ymm2, %%ymm4\n\t"
            "vpand %%ymm3, %%ymm4, %%ymm5\n\t"
            "vmovd %[u], %%xmm1\n\t"
            "vpbroadcastb %%xmm1, %%ymm1\n\t"
            "vpcmpeqb %%ymm1, %%ymm0, %%ymm1\n\t"
            "vpor %%ymm5, %%ymm1, %%ymm0\n\t"
            "vpmovmskb %%ymm0, %[mask]\n\t"
            "vzeroupper\n\t"
            : [mask] "=r" (mask)
            : [src] "r" (p),
              [lo] "r" ((uint32_t)('0'-1)),
              [hi] "r" ((uint32_t)('9'+1)),
              [u] "r" ((uint32_t)'_')
            : "ymm0", "ymm1", "ymm2", "ymm3", "ymm4", "ymm5", "memory"
        );
        if (mask != 0xFFFFFFFF) return p + Tzcnt32(~mask);
        p += 32;
    }
    /* Scalar tail */
    while (p < end && ((*p >= '0' && *p <= '9') || *p == '_')) p++;
    return p;
}

#elif defined(SIMD_ARM64)
/* ─────────────────────────────────────────────────────────────────────────
 * ARM64 NEON Implementation (raw inline assembly)
 * ───────────────────────────────────────────────────────────────────────── */

static inline const char *Simd_Skip_Whitespace(const char *p, const char *end) {
    while (p + 16 <= end) {
        uint64_t lo, hi;
        __asm__ volatile (
            "ldr q0, [%[src]]\n\t"                /* Load 16 bytes */
            /* Check for space (0x20) */
            "movi v1.16b, #0x20\n\t"
            "cmeq v5.16b, v0.16b, v1.16b\n\t"
            /* Check range 0x09-0x0D: c > 0x08 && c < 0x0E */
            "movi v2.16b, #0x08\n\t"              /* lo-1 */
            "movi v3.16b, #0x0E\n\t"              /* hi+1 */
            "cmhi v6.16b, v0.16b, v2.16b\n\t"     /* c > 0x08 */
            "cmhi v7.16b, v3.16b, v0.16b\n\t"     /* 0x0E > c */
            "and v6.16b, v6.16b, v7.16b\n\t"      /* in range */
            /* Combine: whitespace = space OR in_range */
            "orr v0.16b, v5.16b, v6.16b\n\t"
            "mvn v0.16b, v0.16b\n\t"              /* Invert for non-whitespace */
            "mov %[lo], v0.d[0]\n\t"
            "mov %[hi], v0.d[1]\n\t"
            : [lo] "=r" (lo), [hi] "=r" (hi)
            : [src] "r" (p)
            : "v0", "v1", "v2", "v3", "v5", "v6", "v7", "memory"
        );
        if (lo) return p + (Tzcnt64(lo) >> 3);
        if (hi) return p + 8 + (Tzcnt64(hi) >> 3);
        p += 16;
    }
    /* Scalar tail: check all isspace() characters */
    while (p < end) {
        unsigned char c = (unsigned char)*p;
        if (c != ' ' && (c < 0x09 || c > 0x0D)) break;
        p++;
    }
    return p;
}

static inline const char *Simd_Find_Newline(const char *p, const char *end) {
    while (p + 16 <= end) {
        uint64_t lo, hi;
        __asm__ volatile (
            "ldr q0, [%[src]]\n\t"
            "movi v1.16b, #0x0A\n\t"
            "cmeq v0.16b, v0.16b, v1.16b\n\t"
            "mov %[lo], v0.d[0]\n\t"
            "mov %[hi], v0.d[1]\n\t"
            : [lo] "=r" (lo), [hi] "=r" (hi)
            : [src] "r" (p)
            : "v0", "v1", "memory"
        );
        if (lo) return p + (Tzcnt64(lo) >> 3);
        if (hi) return p + 8 + (Tzcnt64(hi) >> 3);
        p += 16;
    }
    while (p < end && *p != '\n') p++;
    return p;
}

static inline const char *Simd_Scan_Identifier(const char *p, const char *end) {
    while (p + 16 <= end) {
        uint64_t lo, hi;
        __asm__ volatile (
            "ldr q0, [%[src]]\n\t"
            /* Check a-z: c >= 'a' && c <= 'z' */
            "movi v1.16b, #0x60\n\t"              /* 'a' - 1 = 0x60 */
            "movi v2.16b, #0x7B\n\t"              /* 'z' + 1 = 0x7B */
            "cmhi v3.16b, v0.16b, v1.16b\n\t"     /* c > 'a'-1 */
            "cmhi v4.16b, v2.16b, v0.16b\n\t"     /* 'z'+1 > c */
            "and v5.16b, v3.16b, v4.16b\n\t"      /* lower */
            /* Check A-Z */
            "movi v1.16b, #0x40\n\t"              /* 'A' - 1 = 0x40 */
            "movi v2.16b, #0x5B\n\t"              /* 'Z' + 1 = 0x5B */
            "cmhi v3.16b, v0.16b, v1.16b\n\t"
            "cmhi v4.16b, v2.16b, v0.16b\n\t"
            "and v6.16b, v3.16b, v4.16b\n\t"      /* upper */
            /* Check 0-9 */
            "movi v1.16b, #0x2F\n\t"              /* '0' - 1 = 0x2F */
            "movi v2.16b, #0x3A\n\t"              /* '9' + 1 = 0x3A */
            "cmhi v3.16b, v0.16b, v1.16b\n\t"
            "cmhi v4.16b, v2.16b, v0.16b\n\t"
            "and v7.16b, v3.16b, v4.16b\n\t"      /* digit */
            /* Check underscore */
            "movi v1.16b, #0x5F\n\t"              /* '_' = 0x5F */
            "cmeq v16.16b, v0.16b, v1.16b\n\t"
            /* Combine: valid = lower | upper | digit | underscore */
            "orr v5.16b, v5.16b, v6.16b\n\t"
            "orr v7.16b, v7.16b, v16.16b\n\t"
            "orr v0.16b, v5.16b, v7.16b\n\t"
            "mvn v0.16b, v0.16b\n\t"              /* Invert for invalid */
            "mov %[lo], v0.d[0]\n\t"
            "mov %[hi], v0.d[1]\n\t"
            : [lo] "=r" (lo), [hi] "=r" (hi)
            : [src] "r" (p)
            : "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v16", "memory"
        );
        if (lo) return p + (Tzcnt64(lo) >> 3);
        if (hi) return p + 8 + (Tzcnt64(hi) >> 3);
        p += 16;
    }
    while (p < end) {
        char c = *p;
        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
              (c >= '0' && c <= '9') || c == '_'))
            break;
        p++;
    }
    return p;
}

static inline const char *Simd_Find_Quote(const char *p, const char *end) {
    while (p + 16 <= end) {
        uint64_t lo, hi;
        __asm__ volatile (
            "ldr q0, [%[src]]\n\t"
            "movi v1.16b, #0x27\n\t"              /* '\'' = 0x27 */
            "cmeq v0.16b, v0.16b, v1.16b\n\t"
            "mov %[lo], v0.d[0]\n\t"
            "mov %[hi], v0.d[1]\n\t"
            : [lo] "=r" (lo), [hi] "=r" (hi)
            : [src] "r" (p)
            : "v0", "v1", "memory"
        );
        if (lo) return p + (Tzcnt64(lo) >> 3);
        if (hi) return p + 8 + (Tzcnt64(hi) >> 3);
        p += 16;
    }
    while (p < end && *p != '\'') p++;
    return p;
}

static inline const char *Simd_Find_Double_Quote(const char *p, const char *end) {
    while (p + 16 <= end) {
        uint64_t lo, hi;
        __asm__ volatile (
            "ldr q0, [%[src]]\n\t"
            "movi v1.16b, #0x22\n\t"              /* '"' = 0x22 */
            "cmeq v0.16b, v0.16b, v1.16b\n\t"
            "mov %[lo], v0.d[0]\n\t"
            "mov %[hi], v0.d[1]\n\t"
            : [lo] "=r" (lo), [hi] "=r" (hi)
            : [src] "r" (p)
            : "v0", "v1", "memory"
        );
        if (lo) return p + (Tzcnt64(lo) >> 3);
        if (hi) return p + 8 + (Tzcnt64(hi) >> 3);
        p += 16;
    }
    while (p < end && *p != '"') p++;
    return p;
}

static inline const char *Simd_Scan_Digits(const char *p, const char *end) {
    while (p + 16 <= end) {
        uint64_t lo, hi;
        __asm__ volatile (
            "ldr q0, [%[src]]\n\t"
            /* Check 0-9 */
            "movi v1.16b, #0x2F\n\t"              /* '0' - 1 */
            "movi v2.16b, #0x3A\n\t"              /* '9' + 1 */
            "cmhi v3.16b, v0.16b, v1.16b\n\t"
            "cmhi v4.16b, v2.16b, v0.16b\n\t"
            "and v5.16b, v3.16b, v4.16b\n\t"
            /* Check underscore */
            "movi v1.16b, #0x5F\n\t"
            "cmeq v6.16b, v0.16b, v1.16b\n\t"
            /* Combine and invert */
            "orr v0.16b, v5.16b, v6.16b\n\t"
            "mvn v0.16b, v0.16b\n\t"
            "mov %[lo], v0.d[0]\n\t"
            "mov %[hi], v0.d[1]\n\t"
            : [lo] "=r" (lo), [hi] "=r" (hi)
            : [src] "r" (p)
            : "v0", "v1", "v2", "v3", "v4", "v5", "v6", "memory"
        );
        if (lo) return p + (Tzcnt64(lo) >> 3);
        if (hi) return p + 8 + (Tzcnt64(hi) >> 3);
        p += 16;
    }
    while (p < end && ((*p >= '0' && *p <= '9') || *p == '_')) p++;
    return p;
}

#elif defined(SIMD_RISCV_V)
/* ─────────────────────────────────────────────────────────────────────────────
 * RISC-V Vector Extension Implementation
 * ─────────────────────────────────────────────────────────────────────────────
 *
 * The RISC-V V extension provides scalable vector processing with:
 *   - VLEN: Vector register length (128-1024 bits, implementation-defined)
 *   - vsetvli: Set vector length based on available elements
 *   - Predicated execution via mask registers (v0.t suffix)
 *
 * IMPORTANT: RISC-V V is "length-agnostic" - code works across all VLENs.
 * The vsetvli instruction dynamically sets the vector length (VL) based on:
 *   - Application Vector Length (AVL): elements we want to process
 *   - VLEN: hardware vector register size
 *   - SEW: Selected Element Width (8 bits for byte operations)
 *
 * Reference: RISC-V "V" Vector Extension Specification v1.0
 *            https://github.com/riscv/riscv-v-spec
 * ───────────────────────────────────────────────────────────────────────────── */

/* Runtime VLEN detection - returns maximum bytes per vector register */
static int Riscv_Vlen_Bytes = -1;  /* -1 = unchecked */

static void Riscv_Detect_Vlen(void) {
    if (Riscv_Vlen_Bytes >= 0) return;
    /* Query VLEN by setting maximum vector length for 8-bit elements
     * Godbolt: vsetvli a0, zero, e8, m1, ta, ma */
    size_t vl;
    __asm__ volatile (
        "vsetvli %0, zero, e8, m1, ta, ma"
        : "=r" (vl)
        :
        :
    );
    Riscv_Vlen_Bytes = (int)vl;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * RISC-V V Whitespace Skip
 *
 * Algorithm: Load VLEN bytes, compare for space and control chars, find first
 * non-match position using vfirst.m instruction.
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Skip_Whitespace(const char *p, const char *end) {
    Riscv_Detect_Vlen();
    size_t avl = (size_t)(end - p);

    while (avl >= (size_t)Riscv_Vlen_Bytes) {
        size_t vl;
        long first_non_ws;
        __asm__ volatile (
            /* Set vector length for byte elements */
            "vsetvli %[vl], %[avl], e8, m1, ta, ma\n\t"
            /* Load vector of bytes */
            "vle8.v v8, (%[src])\n\t"
            /* Check for space (0x20) */
            "vmseq.vi v0, v8, 0x20\n\t"
            /* Check range 0x09-0x0D (tab, LF, VT, FF, CR) */
            "li t0, 0x08\n\t"
            "vmsgtu.vx v1, v8, t0\n\t"      /* v8 > 0x08 */
            "li t0, 0x0E\n\t"
            "vmsltu.vx v2, v8, t0\n\t"      /* v8 < 0x0E */
            "vmand.mm v1, v1, v2\n\t"       /* in range [0x09,0x0D] */
            /* Combine: whitespace = space OR control_range */
            "vmor.mm v0, v0, v1\n\t"
            /* Invert: find non-whitespace */
            "vmnot.m v0, v0\n\t"
            /* Find first set bit (first non-whitespace) */
            "vfirst.m %[first], v0\n\t"
            : [vl] "=r" (vl), [first] "=r" (first_non_ws)
            : [avl] "r" (avl), [src] "r" (p)
            : "v0", "v1", "v2", "v8", "t0", "memory"
        );

        if (first_non_ws >= 0) {
            return p + first_non_ws;
        }
        p += vl;
        avl = (size_t)(end - p);
    }

    /* Scalar tail */
    while (p < end) {
        unsigned char c = (unsigned char)*p;
        if (c != ' ' && (c < 0x09 || c > 0x0D)) break;
        p++;
    }
    return p;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * RISC-V V Single Character Search
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Find_Char_Riscv(const char *p, const char *end, char ch) {
    Riscv_Detect_Vlen();
    size_t avl = (size_t)(end - p);

    while (avl >= (size_t)Riscv_Vlen_Bytes) {
        size_t vl;
        long first_match;
        __asm__ volatile (
            "vsetvli %[vl], %[avl], e8, m1, ta, ma\n\t"
            "vle8.v v8, (%[src])\n\t"
            "vmseq.vx v0, v8, %[ch]\n\t"
            "vfirst.m %[first], v0\n\t"
            : [vl] "=r" (vl), [first] "=r" (first_match)
            : [avl] "r" (avl), [src] "r" (p), [ch] "r" ((int)(unsigned char)ch)
            : "v0", "v8", "memory"
        );

        if (first_match >= 0) {
            return p + first_match;
        }
        p += vl;
        avl = (size_t)(end - p);
    }

    /* Scalar tail */
    while (p < end && *p != ch) p++;
    return p;
}

static inline const char *Simd_Find_Newline(const char *p, const char *end) {
    return Simd_Find_Char_Riscv(p, end, '\n');
}

static inline const char *Simd_Find_Quote(const char *p, const char *end) {
    return Simd_Find_Char_Riscv(p, end, '\'');
}

static inline const char *Simd_Find_Double_Quote(const char *p, const char *end) {
    return Simd_Find_Char_Riscv(p, end, '"');
}

/* ─────────────────────────────────────────────────────────────────────────────
 * RISC-V V Identifier Scanner
 *
 * Matches [A-Za-z0-9_] using range comparisons and OR reduction.
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Scan_Identifier(const char *p, const char *end) {
    Riscv_Detect_Vlen();
    size_t avl = (size_t)(end - p);

    while (avl >= (size_t)Riscv_Vlen_Bytes) {
        size_t vl;
        long first_invalid;
        __asm__ volatile (
            "vsetvli %[vl], %[avl], e8, m1, ta, ma\n\t"
            "vle8.v v8, (%[src])\n\t"
            /* Check a-z: c > 0x60 && c < 0x7B */
            "li t0, 0x60\n\t"
            "vmsgtu.vx v1, v8, t0\n\t"
            "li t0, 0x7B\n\t"
            "vmsltu.vx v2, v8, t0\n\t"
            "vmand.mm v3, v1, v2\n\t"       /* lowercase */
            /* Check A-Z: c > 0x40 && c < 0x5B */
            "li t0, 0x40\n\t"
            "vmsgtu.vx v1, v8, t0\n\t"
            "li t0, 0x5B\n\t"
            "vmsltu.vx v2, v8, t0\n\t"
            "vmand.mm v4, v1, v2\n\t"       /* uppercase */
            /* Check 0-9: c > 0x2F && c < 0x3A */
            "li t0, 0x2F\n\t"
            "vmsgtu.vx v1, v8, t0\n\t"
            "li t0, 0x3A\n\t"
            "vmsltu.vx v2, v8, t0\n\t"
            "vmand.mm v5, v1, v2\n\t"       /* digit */
            /* Check underscore (0x5F) */
            "li t0, 0x5F\n\t"
            "vmseq.vx v6, v8, t0\n\t"       /* underscore */
            /* Combine: valid = lower | upper | digit | underscore */
            "vmor.mm v0, v3, v4\n\t"
            "vmor.mm v0, v0, v5\n\t"
            "vmor.mm v0, v0, v6\n\t"
            /* Invert to find invalid chars */
            "vmnot.m v0, v0\n\t"
            "vfirst.m %[first], v0\n\t"
            : [vl] "=r" (vl), [first] "=r" (first_invalid)
            : [avl] "r" (avl), [src] "r" (p)
            : "v0", "v1", "v2", "v3", "v4", "v5", "v6", "v8", "t0", "memory"
        );

        if (first_invalid >= 0) {
            return p + first_invalid;
        }
        p += vl;
        avl = (size_t)(end - p);
    }

    /* Scalar tail */
    while (p < end) {
        char c = *p;
        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
              (c >= '0' && c <= '9') || c == '_'))
            break;
        p++;
    }
    return p;
}

/* ─────────────────────────────────────────────────────────────────────────────
 * RISC-V V Digit Scanner
 *
 * Matches [0-9_] for Ada numeric literals.
 * ───────────────────────────────────────────────────────────────────────────── */
static inline const char *Simd_Scan_Digits(const char *p, const char *end) {
    Riscv_Detect_Vlen();
    size_t avl = (size_t)(end - p);

    while (avl >= (size_t)Riscv_Vlen_Bytes) {
        size_t vl;
        long first_non_digit;
        __asm__ volatile (
            "vsetvli %[vl], %[avl], e8, m1, ta, ma\n\t"
            "vle8.v v8, (%[src])\n\t"
            /* Check 0-9: c > 0x2F && c < 0x3A */
            "li t0, 0x2F\n\t"
            "vmsgtu.vx v1, v8, t0\n\t"
            "li t0, 0x3A\n\t"
            "vmsltu.vx v2, v8, t0\n\t"
            "vmand.mm v3, v1, v2\n\t"       /* digit */
            /* Check underscore */
            "li t0, 0x5F\n\t"
            "vmseq.vx v4, v8, t0\n\t"
            /* Combine and invert */
            "vmor.mm v0, v3, v4\n\t"
            "vmnot.m v0, v0\n\t"
            "vfirst.m %[first], v0\n\t"
            : [vl] "=r" (vl), [first] "=r" (first_non_digit)
            : [avl] "r" (avl), [src] "r" (p)
            : "v0", "v1", "v2", "v3", "v4", "v8", "t0", "memory"
        );

        if (first_non_digit >= 0) {
            return p + first_non_digit;
        }
        p += vl;
        avl = (size_t)(end - p);
    }

    /* Scalar tail */
    while (p < end && ((*p >= '0' && *p <= '9') || *p == '_')) p++;
    return p;
}

#else
/* ─────────────────────────────────────────────────────────────────────────────
 * Generic Scalar Implementation (Portable Fallback)
 * ─────────────────────────────────────────────────────────────────────────────
 *
 * This is the reference implementation. All SIMD paths must produce identical
 * results to these scalar functions for all possible inputs.
 * ───────────────────────────────────────────────────────────────────────────── */

static inline const char *Simd_Skip_Whitespace(const char *p, const char *end) {
    while (p < end) {
        unsigned char c = (unsigned char)*p;
        if (c != ' ' && (c < 0x09 || c > 0x0D)) break;
        p++;
    }
    return p;
}

static inline const char *Simd_Find_Newline(const char *p, const char *end) {
    while (p < end && *p != '\n') p++;
    return p;
}

static inline const char *Simd_Scan_Identifier(const char *p, const char *end) {
    while (p < end) {
        char c = *p;
        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
              (c >= '0' && c <= '9') || c == '_'))
            break;
        p++;
    }
    return p;
}

static inline const char *Simd_Find_Quote(const char *p, const char *end) {
    while (p < end && *p != '\'') p++;
    return p;
}

static inline const char *Simd_Find_Double_Quote(const char *p, const char *end) {
    while (p < end && *p != '"') p++;
    return p;
}

static inline const char *Simd_Scan_Digits(const char *p, const char *end) {
    while (p < end && ((*p >= '0' && *p <= '9') || *p == '_')) p++;
    return p;
}

#endif /* SIMD architecture selection */

/* ─────────────────────────────────────────────────────────────────────────
 * End SIMD Functions
 * ───────────────────────────────────────────────────────────────────────── */

static inline char Lexer_Peek(const Lexer *lex, size_t offset) {
    return lex->current + offset < lex->source_end ? lex->current[offset] : '\0';
}

static inline char Lexer_Advance(Lexer *lex) {
    if (lex->current >= lex->source_end) return '\0';
    char c = *lex->current++;
    if (c == '\n') { lex->line++; lex->column = 1; }
    else lex->column++;
    return c;
}

static void Lexer_Skip_Whitespace_And_Comments(Lexer *lex) {
    for (;;) {
        /* Use SIMD to find first non-whitespace */
        const char *end_ws = Simd_Skip_Whitespace(lex->current, lex->source_end);
        /* Update line/column by scanning for newlines in skipped region */
        while (lex->current < end_ws) {
            if (*lex->current == '\n') { lex->line++; lex->column = 1; }
            else lex->column++;
            lex->current++;
        }

        /* Ada comment: -- to end of line */
        if (lex->current + 1 < lex->source_end &&
            lex->current[0] == '-' && lex->current[1] == '-') {
            /* Use SIMD to find newline */
            const char *end_comment = Simd_Find_Newline(lex->current, lex->source_end);
            lex->column += (uint32_t)(end_comment - lex->current);
            lex->current = end_comment;
        } else break;
    }
}

static inline Token Make_Token(Token_Kind kind, Source_Location loc, String_Slice text) {
    return (Token){kind, loc, text, {0}};
}

/* ─────────────────────────────────────────────────────────────────────────
 * §7.4 Scanning Functions
 * ───────────────────────────────────────────────────────────────────────── */

static Token Scan_Identifier(Lexer *lex) {
    Source_Location loc = {lex->filename, lex->line, lex->column};
    const char *start = lex->current;

    /* Use SIMD to find end of identifier */
    const char *end_id = Simd_Scan_Identifier(lex->current, lex->source_end);
    lex->column += (uint32_t)(end_id - lex->current);
    lex->current = end_id;

    String_Slice text = {start, (uint32_t)(lex->current - start)};
    Token_Kind kind = Lookup_Keyword(text);
    return Make_Token(kind, loc, text);
}

/* Parse digit value in any base up to 16 */
static inline int Digit_Value(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    return -1;
}

static Token Scan_Number(Lexer *lex) {
    Source_Location loc = {lex->filename, lex->line, lex->column};
    const char *start = lex->current;
    int base = 10;
    bool is_real = false, has_exponent = false, is_based = false;

    /* Scan integer part (possibly base specifier) */
    while (Is_Digit(Lexer_Peek(lex, 0)) || Lexer_Peek(lex, 0) == '_')
        Lexer_Advance(lex);

    /* Based literal: 16#FFFF# or 2#1010# */
    if (Lexer_Peek(lex, 0) == '#' ||
        (Lexer_Peek(lex, 0) == ':' && Is_Xdigit(Lexer_Peek(lex, 1)))) {
        is_based = true;
        char delim = Lexer_Peek(lex, 0);

        /* Parse base from what we've scanned so far */
        char base_buf[16] = {0};
        int bi = 0;
        for (const char *p = start; p < lex->current && bi < 15; p++)
            if (*p != '_') base_buf[bi++] = *p;
        base = atoi(base_buf);

        Lexer_Advance(lex); /* consume # or : */

        /* Scan mantissa */
        while (Is_Xdigit(Lexer_Peek(lex, 0)) || Lexer_Peek(lex, 0) == '_')
            Lexer_Advance(lex);

        if (Lexer_Peek(lex, 0) == '.') {
            is_real = true;
            Lexer_Advance(lex);
            while (Is_Xdigit(Lexer_Peek(lex, 0)) || Lexer_Peek(lex, 0) == '_')
                Lexer_Advance(lex);
        }

        if (Lexer_Peek(lex, 0) == delim) Lexer_Advance(lex);

        if (To_Lower(Lexer_Peek(lex, 0)) == 'e') {
            has_exponent = true;
            Lexer_Advance(lex);
            if (Lexer_Peek(lex, 0) == '+' || Lexer_Peek(lex, 0) == '-')
                Lexer_Advance(lex);
            while (Is_Digit(Lexer_Peek(lex, 0)) || Lexer_Peek(lex, 0) == '_')
                Lexer_Advance(lex);
        }
    } else {
        /* Decimal literal with optional fraction and exponent */
        if (Lexer_Peek(lex, 0) == '.' && Lexer_Peek(lex, 1) != '.' && !Is_Alpha(Lexer_Peek(lex, 1))) {
            is_real = true;
            Lexer_Advance(lex);
            while (Is_Digit(Lexer_Peek(lex, 0)) || Lexer_Peek(lex, 0) == '_')
                Lexer_Advance(lex);
        }

        if (To_Lower(Lexer_Peek(lex, 0)) == 'e') {
            has_exponent = true;
            /* Note: exponent alone doesn't make it real - 12E1 is integer 120 */
            Lexer_Advance(lex);
            if (Lexer_Peek(lex, 0) == '+' || Lexer_Peek(lex, 0) == '-')
                Lexer_Advance(lex);
            while (Is_Digit(Lexer_Peek(lex, 0)) || Lexer_Peek(lex, 0) == '_')
                Lexer_Advance(lex);
        }
    }

    String_Slice text = {start, (uint32_t)(lex->current - start)};
    Token tok = Make_Token(is_real ? TK_REAL : TK_INTEGER, loc, text);

    /* Convert to value: strip underscores, parse with base */
    char clean[512];
    int ci = 0;
    for (const char *p = start; p < lex->current && ci < 510; p++)
        if (*p != '_' && *p != '#' && *p != ':') clean[ci++] = *p;
    clean[ci] = '\0';

    if (is_real) {
        if (!is_based) {
            /* Parse into Big_Real for arbitrary precision */
            tok.big_real = Big_Real_From_String(clean);
            /* Also compute double for compatibility */
            tok.float_value = Big_Real_To_Double(tok.big_real);
        } else {
            /* Based real: parse mantissa in base, apply exponent as power of base */
            /* Format: base#integer.fraction#exponent */
            double value = 0.0;
            double frac_mult = 1.0 / base;
            int exp = 0;
            int state = 0; /* 0=skip base, 1=integer, 2=fraction, 3=exponent */
            bool exp_neg = false;
            for (const char *p = start; p < lex->current; p++) {
                char c = *p;
                if (c == '_') continue;
                if (c == '#' || c == ':') { state++; continue; }
                if (c == '.') { state = 2; continue; }
                if (To_Lower(c) == 'e') { state = 3; continue; }
                if (state == 1) {
                    int d = Digit_Value(c);
                    if (d >= 0 && d < base) value = value * base + d;
                } else if (state == 2) {
                    int d = Digit_Value(c);
                    if (d >= 0 && d < base) { value += d * frac_mult; frac_mult /= base; }
                } else if (state == 3) {
                    if (c == '-') exp_neg = true;
                    else if (c == '+') continue;
                    else if (Is_Digit(c)) exp = exp * 10 + (c - '0');
                }
            }
            if (exp_neg) exp = -exp;
            for (int i = 0; i < (exp > 0 ? exp : -exp); i++)
                value = exp > 0 ? value * base : value / base;
            tok.float_value = value;
            tok.big_real = NULL;  /* Based reals use double precision only */
        }
    } else {
        if (!is_based && !has_exponent) {
            tok.big_integer = Big_Integer_From_Decimal_SIMD(clean);
            int64_t v;
            if (Big_Integer_Fits_Int64(tok.big_integer, &v))
                tok.integer_value = v;
        } else if (!is_based && has_exponent) {
            /* Decimal integer with exponent (e.g., 12E1 = 120) */
            int64_t mantissa = 0;
            int exp = 0;
            bool in_exp = false;
            bool exp_neg = false;
            for (int i = 0; clean[i]; i++) {
                char c = clean[i];
                if (To_Lower(c) == 'e') {
                    in_exp = true;
                } else if (in_exp) {
                    if (c == '-') exp_neg = true;
                    else if (c == '+') continue;
                    else if (Is_Digit(c)) exp = exp * 10 + (c - '0');
                } else if (Is_Digit(c)) {
                    mantissa = mantissa * 10 + (c - '0');
                }
            }
            if (exp_neg) {
                /* Negative exponent in integer literal is unusual but handle it */
                for (int i = 0; i < exp; i++) mantissa /= 10;
            } else {
                for (int i = 0; i < exp; i++) mantissa *= 10;
            }
            tok.integer_value = mantissa;
        } else {
            /* Based integer: parse from original string (e.g., 16#E#E1 = 14*16 = 224) */
            /* Structure: base#mantissa#exponent or base#mantissa# */
            int64_t value = 0;
            int exp = 0;
            int state = 0; /* 0=base, 1=mantissa, 2=exponent */
            for (const char *p = start; p < lex->current; p++) {
                char c = *p;
                if (c == '_') continue;
                if (c == '#' || c == ':') {
                    state++;
                    continue;
                }
                if (state == 0) {
                    /* Skip base part - already parsed */
                } else if (state == 1) {
                    /* Mantissa in given base */
                    int d = Digit_Value(c);
                    if (d >= 0 && d < base) value = value * base + d;
                } else if (state == 2) {
                    /* Exponent (always decimal, after second delimiter) */
                    if (To_Lower(c) == 'e') continue; /* skip the 'e' marker */
                    if (c == '+') continue;
                    if (Is_Digit(c)) exp = exp * 10 + (c - '0');
                }
            }
            for (int i = 0; i < exp; i++) value *= base;
            tok.integer_value = value;
        }
    }

    return tok;
}

static Token Scan_Character_Literal(Lexer *lex) {
    Source_Location loc = {lex->filename, lex->line, lex->column};
    Lexer_Advance(lex); /* consume opening ' */

    char c = Lexer_Advance(lex);
    if (Lexer_Peek(lex, 0) != '\'') {
        Report_Error(loc, "unterminated character literal");
        return Make_Token(TK_ERROR, loc, S(""));
    }
    Lexer_Advance(lex); /* consume closing ' */

    Token tok = Make_Token(TK_CHARACTER, loc, (String_Slice){lex->current - 3, 3});
    tok.integer_value = (unsigned char)c;
    return tok;
}

static Token Scan_String_Literal(Lexer *lex) {
    Source_Location loc = {lex->filename, lex->line, lex->column};
    Lexer_Advance(lex); /* consume opening " */

    size_t capacity = 64, length = 0;
    char *buffer = Arena_Allocate(capacity);

    while (lex->current < lex->source_end) {
        if (*lex->current == '"') {
            if (Lexer_Peek(lex, 1) == '"') {
                /* Escaped quote: "" becomes " */
                if (length >= capacity - 1) {
                    char *newbuf = Arena_Allocate(capacity * 2);
                    memcpy(newbuf, buffer, length);
                    buffer = newbuf;
                    capacity *= 2;
                }
                buffer[length++] = '"';
                Lexer_Advance(lex);
                Lexer_Advance(lex);
            } else {
                Lexer_Advance(lex); /* consume closing " */
                break;
            }
        } else {
            if (length >= capacity - 1) {
                char *newbuf = Arena_Allocate(capacity * 2);
                memcpy(newbuf, buffer, length);
                buffer = newbuf;
                capacity *= 2;
            }
            buffer[length++] = Lexer_Advance(lex);
        }
    }
    buffer[length] = '\0';

    Token tok = Make_Token(TK_STRING, loc, (String_Slice){buffer, (uint32_t)length});
    return tok;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §7.5 Main Lexer Entry Point
 *
 * The lexer works as an iterator where each call advances the stream by one token.
 * ───────────────────────────────────────────────────────────────────────── */

static Token Lexer_Next_Token(Lexer *lex) {
    Lexer_Skip_Whitespace_And_Comments(lex);

    if (lex->current >= lex->source_end)
        return Make_Token(TK_EOF, (Source_Location){lex->filename, lex->line, lex->column}, S(""));

    Source_Location loc = {lex->filename, lex->line, lex->column};
    char c = Lexer_Peek(lex, 0);

    /* Identifiers and keywords */
    if (Is_Alpha(c)) return Scan_Identifier(lex);

    /* Numeric literals */
    if (Is_Digit(c)) return Scan_Number(lex);

    /* Character literal: 'X' where X is any graphic character */
    /* Need to check for printable character (not just alpha) since '1' etc. are valid */
    /* Special case: ''' is a character literal containing single quote */
    /* Context check: After identifier or RPAREN, '( could be tick+lparen (qualified expr) */
    {
        char middle = Lexer_Peek(lex, 1);
        char third = Lexer_Peek(lex, 2);
        if (c == '\'' && middle >= ' ' && third == '\'') {
            /* Check for qualified expression context: TYPE'(expr)
             * If previous token was identifier/RPAREN and middle is '(',
             * this is tick+lparen, not a character literal */
            if (middle == '(' &&
                (lex->prev_token_kind == TK_IDENTIFIER ||
                 lex->prev_token_kind == TK_RPAREN)) {
                /* Not a character literal - fall through to tick handling */
            } else {
                return Scan_Character_Literal(lex);
            }
        }
    }

    /* String literal */
    if (c == '"') return Scan_String_Literal(lex);

    /* Operators and delimiters */
    Lexer_Advance(lex);
    char c2 = Lexer_Peek(lex, 0);

    switch (c) {
        case '(': return Make_Token(TK_LPAREN, loc, S("("));
        case ')': return Make_Token(TK_RPAREN, loc, S(")"));
        case '[': return Make_Token(TK_LBRACKET, loc, S("["));
        case ']': return Make_Token(TK_RBRACKET, loc, S("]"));
        case ',': return Make_Token(TK_COMMA, loc, S(","));
        case ';': return Make_Token(TK_SEMICOLON, loc, S(";"));
        case '&': return Make_Token(TK_AMPERSAND, loc, S("&"));
        case '|': return Make_Token(TK_BAR, loc, S("|"));
        case '!': return Make_Token(TK_BAR, loc, S("!"));  /* Ada 83 alternative for | */
        case '+': return Make_Token(TK_PLUS, loc, S("+"));
        case '-': return Make_Token(TK_MINUS, loc, S("-"));
        case '\'': return Make_Token(TK_TICK, loc, S("'"));

        case '.':
            if (c2 == '.') { Lexer_Advance(lex); return Make_Token(TK_DOTDOT, loc, S("..")); }
            return Make_Token(TK_DOT, loc, S("."));

        case ':':
            if (c2 == '=') { Lexer_Advance(lex); return Make_Token(TK_ASSIGN, loc, S(":=")); }
            return Make_Token(TK_COLON, loc, S(":"));

        case '*':
            if (c2 == '*') { Lexer_Advance(lex); return Make_Token(TK_EXPON, loc, S("**")); }
            return Make_Token(TK_STAR, loc, S("*"));

        case '/':
            if (c2 == '=') { Lexer_Advance(lex); return Make_Token(TK_NE, loc, S("/=")); }
            return Make_Token(TK_SLASH, loc, S("/"));

        case '=':
            if (c2 == '>') { Lexer_Advance(lex); return Make_Token(TK_ARROW, loc, S("=>")); }
            return Make_Token(TK_EQ, loc, S("="));

        case '<':
            if (c2 == '=') { Lexer_Advance(lex); return Make_Token(TK_LE, loc, S("<=")); }
            if (c2 == '<') { Lexer_Advance(lex); return Make_Token(TK_LSHIFT, loc, S("<<")); }
            if (c2 == '>') { Lexer_Advance(lex); return Make_Token(TK_BOX, loc, S("<>")); }
            return Make_Token(TK_LT, loc, S("<"));

        case '>':
            if (c2 == '=') { Lexer_Advance(lex); return Make_Token(TK_GE, loc, S(">=")); }
            if (c2 == '>') { Lexer_Advance(lex); return Make_Token(TK_RSHIFT, loc, S(">>")); }
            return Make_Token(TK_GT, loc, S(">"));

        default:
            Report_Error(loc, "unexpected character '%c'", c);
            return Make_Token(TK_ERROR, loc, S(""));
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §8. ABSTRACT SYNTAX TREE — Parse Tree Representation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * The AST uses a tagged union design. Each node kind has a specific payload.
 * The tree is a forest: one root per compilation unit, shared subtrees within.
 */

/* Forward declarations */
typedef struct Syntax_Node Syntax_Node;
typedef struct Type_Info Type_Info;
typedef struct Symbol Symbol;

/* Dynamic array of syntax nodes */
typedef struct {
    Syntax_Node **items;
    uint32_t      count;
    uint32_t      capacity;
} Node_List;

/* Doubling gives amortized O(1) append; the wasted space is the price of speed */
static void Node_List_Push(Node_List *list, Syntax_Node *node) {
    if (list->count >= list->capacity) {
        uint32_t new_cap = list->capacity ? list->capacity * 2 : 8;
        Syntax_Node **new_items = Arena_Allocate(new_cap * sizeof(Syntax_Node*));
        if (list->items) memcpy(new_items, list->items, list->count * sizeof(Syntax_Node*));
        list->items = new_items;
        list->capacity = new_cap;
    }
    list->items[list->count++] = node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §8.1 Node Kinds
 * ───────────────────────────────────────────────────────────────────────── */

typedef enum {
    /* Literals and primaries */
    NK_INTEGER, NK_REAL, NK_STRING, NK_CHARACTER, NK_NULL, NK_OTHERS,
    NK_IDENTIFIER, NK_SELECTED, NK_ATTRIBUTE, NK_QUALIFIED,

    /* Expressions */
    NK_BINARY_OP, NK_UNARY_OP, NK_AGGREGATE, NK_ALLOCATOR,
    NK_APPLY,       /* Unified: call, index, slice — resolved later */
    NK_RANGE,       /* a .. b */
    NK_ASSOCIATION, /* name => value */

    /* Type definitions */
    NK_SUBTYPE_INDICATION, NK_RANGE_CONSTRAINT, NK_INDEX_CONSTRAINT,
    NK_DISCRIMINANT_CONSTRAINT, NK_DIGITS_CONSTRAINT, NK_DELTA_CONSTRAINT,
    NK_ARRAY_TYPE, NK_RECORD_TYPE,
    NK_ACCESS_TYPE, NK_DERIVED_TYPE, NK_ENUMERATION_TYPE,
    NK_INTEGER_TYPE, NK_REAL_TYPE, NK_COMPONENT_DECL, NK_VARIANT_PART,
    NK_VARIANT, NK_DISCRIMINANT_SPEC,

    /* Statements */
    NK_ASSIGNMENT, NK_CALL_STMT, NK_RETURN, NK_IF, NK_CASE, NK_LOOP,
    NK_BLOCK, NK_EXIT, NK_GOTO, NK_RAISE, NK_NULL_STMT, NK_LABEL,
    NK_ACCEPT, NK_SELECT, NK_DELAY, NK_ABORT, NK_CODE,

    /* Declarations */
    NK_OBJECT_DECL, NK_TYPE_DECL, NK_SUBTYPE_DECL, NK_EXCEPTION_DECL,
    NK_PROCEDURE_SPEC, NK_FUNCTION_SPEC, NK_PROCEDURE_BODY, NK_FUNCTION_BODY,
    NK_PACKAGE_SPEC, NK_PACKAGE_BODY, NK_TASK_SPEC, NK_TASK_BODY,
    NK_ENTRY_DECL, NK_SUBPROGRAM_RENAMING, NK_PACKAGE_RENAMING,
    NK_EXCEPTION_RENAMING, NK_GENERIC_DECL, NK_GENERIC_INST,
    NK_PARAM_SPEC, NK_USE_CLAUSE, NK_WITH_CLAUSE, NK_PRAGMA,
    NK_REPRESENTATION_CLAUSE, NK_EXCEPTION_HANDLER,
    NK_CONTEXT_CLAUSE, NK_COMPILATION_UNIT,

    /* Generic formals */
    NK_GENERIC_TYPE_PARAM, NK_GENERIC_OBJECT_PARAM, NK_GENERIC_SUBPROGRAM_PARAM,

    NK_COUNT
} Node_Kind;

/* ─────────────────────────────────────────────────────────────────────────
 * §8.2 Syntax Node Structure
 *
 * Each node carries its kind, location, optional type annotation (from
 * semantic analysis), and a payload specific to the kind.
 * ───────────────────────────────────────────────────────────────────────── */

struct Syntax_Node {
    Node_Kind        kind;
    Source_Location  location;
    Type_Info       *type;      /* Set during semantic analysis */
    Symbol          *symbol;    /* Set during name resolution */

    union {
        /* NK_INTEGER */
        struct { int64_t value; Big_Integer *big_value; } integer_lit;

        /* NK_REAL - arbitrary precision with double for compatibility */
        struct { double value; Big_Real *big_value; } real_lit;

        /* NK_STRING, NK_CHARACTER, NK_IDENTIFIER */
        struct { String_Slice text; } string_val;

        /* NK_SELECTED: prefix.selector */
        struct { Syntax_Node *prefix; String_Slice selector; } selected;

        /* NK_ATTRIBUTE: prefix'attribute(args) */
        struct { Syntax_Node *prefix; String_Slice name; Node_List arguments; } attribute;

        /* NK_QUALIFIED: subtype_mark'(expression) */
        struct { Syntax_Node *subtype_mark; Syntax_Node *expression; } qualified;

        /* NK_BINARY_OP, NK_UNARY_OP */
        struct { Token_Kind op; Syntax_Node *left; Syntax_Node *right; } binary;
        struct { Token_Kind op; Syntax_Node *operand; } unary;

        /* NK_AGGREGATE */
        struct { Node_List items; bool is_named; } aggregate;

        /* NK_ALLOCATOR: new subtype_mark'(expression) or new subtype_mark */
        struct { Syntax_Node *subtype_mark; Syntax_Node *expression; } allocator;

        /* NK_APPLY: prefix(arguments) — unified call/index/slice */
        struct { Syntax_Node *prefix; Node_List arguments; } apply;

        /* NK_RANGE: low .. high */
        struct { Syntax_Node *low; Syntax_Node *high; } range;

        /* NK_ASSOCIATION: choices => expression */
        struct { Node_List choices; Syntax_Node *expression; } association;

        /* NK_SUBTYPE_INDICATION: subtype_mark constraint */
        struct { Syntax_Node *subtype_mark; Syntax_Node *constraint; } subtype_ind;

        /* NK_*_CONSTRAINT */
        struct { Node_List ranges; } index_constraint;
        struct { Syntax_Node *range; } range_constraint;
        struct { Node_List associations; } discriminant_constraint;
        struct { Syntax_Node *digits_expr; Syntax_Node *range; } digits_constraint;  /* NK_DIGITS_CONSTRAINT */
        struct { Syntax_Node *delta_expr; Syntax_Node *range; } delta_constraint;    /* NK_DELTA_CONSTRAINT */

        /* NK_ARRAY_TYPE */
        struct { Node_List indices; Syntax_Node *component_type; bool is_constrained; } array_type;

        /* NK_RECORD_TYPE */
        struct {
            Node_List discriminants;
            Node_List components;
            Syntax_Node *variant_part;
            bool is_null;
        } record_type;

        /* NK_ACCESS_TYPE */
        struct { Syntax_Node *designated; bool is_constant; } access_type;

        /* NK_DERIVED_TYPE */
        struct { Syntax_Node *parent_type; Syntax_Node *constraint; } derived_type;

        /* NK_ENUMERATION_TYPE */
        struct { Node_List literals; } enum_type;

        /* NK_INTEGER_TYPE, NK_REAL_TYPE */
        struct { Syntax_Node *range; int64_t modulus; } integer_type;
        struct { Syntax_Node *precision; Syntax_Node *range; Syntax_Node *delta; } real_type;

        /* NK_COMPONENT_DECL */
        struct { Node_List names; Syntax_Node *component_type; Syntax_Node *init; } component;

        /* NK_VARIANT_PART */
        struct { String_Slice discriminant; Node_List variants; } variant_part;

        /* NK_VARIANT */
        struct { Node_List choices; Node_List components; Syntax_Node *variant_part; } variant;

        /* NK_DISCRIMINANT_SPEC */
        struct { Node_List names; Syntax_Node *disc_type; Syntax_Node *default_expr; } discriminant;

        /* NK_ASSIGNMENT */
        struct { Syntax_Node *target; Syntax_Node *value; } assignment;

        /* NK_RETURN */
        struct { Syntax_Node *expression; } return_stmt;

        /* NK_IF */
        struct {
            Syntax_Node *condition;
            Node_List then_stmts;
            Node_List elsif_parts;  /* each is another NK_IF for elsif */
            Node_List else_stmts;
        } if_stmt;

        /* NK_CASE */
        struct { Syntax_Node *expression; Node_List alternatives; } case_stmt;

        /* NK_LOOP */
        struct {
            String_Slice label;
            Symbol *label_symbol;           /* Pre-registered label for GOTO */
            Syntax_Node *iteration_scheme;  /* for/while condition */
            Node_List statements;
            bool is_reverse;
        } loop_stmt;

        /* NK_BLOCK */
        struct {
            String_Slice label;
            Symbol *label_symbol;           /* Pre-registered label for GOTO */
            Node_List declarations;
            Node_List statements;
            Node_List handlers;
        } block_stmt;

        /* NK_EXIT */
        struct { String_Slice loop_name; Syntax_Node *condition; } exit_stmt;

        /* NK_GOTO */
        struct { String_Slice name; Symbol *target; } goto_stmt;

        /* NK_LABEL */
        struct { String_Slice name; Syntax_Node *statement; Symbol *symbol; } label_node;

        /* NK_RAISE */
        struct { Syntax_Node *exception_name; } raise_stmt;

        /* NK_ACCEPT */
        struct {
            String_Slice entry_name;
            Syntax_Node *index;
            Node_List parameters;
            Node_List statements;
            Symbol *entry_sym;      /* Resolved entry symbol (for entry_index) */
        } accept_stmt;

        /* NK_SELECT */
        struct { Node_List alternatives; Syntax_Node *else_part; } select_stmt;

        /* NK_DELAY */
        struct { Syntax_Node *expression; } delay_stmt;

        /* NK_ABORT */
        struct { Node_List task_names; } abort_stmt;

        /* NK_OBJECT_DECL */
        struct {
            Node_List names;
            Syntax_Node *object_type;
            Syntax_Node *init;       /* For renames, this is the renamed object */
            bool is_constant;
            bool is_aliased;
            bool is_rename;          /* True for RENAMES declarations */
        } object_decl;

        /* NK_TYPE_DECL, NK_SUBTYPE_DECL */
        struct {
            String_Slice name;
            Node_List discriminants;
            Syntax_Node *definition;
            bool is_limited;
            bool is_private;
        } type_decl;

        /* NK_EXCEPTION_DECL, NK_EXCEPTION_RENAMING */
        struct { Node_List names; Syntax_Node *renamed; } exception_decl;

        /* NK_PROCEDURE_SPEC, NK_FUNCTION_SPEC, NK_SUBPROGRAM_RENAMING */
        struct {
            String_Slice name;
            Node_List parameters;
            Syntax_Node *return_type;  /* NULL for procedures */
            Syntax_Node *renamed;      /* For NK_SUBPROGRAM_RENAMING: the renamed entity */
        } subprogram_spec;

        /* NK_PROCEDURE_BODY, NK_FUNCTION_BODY */
        struct {
            Syntax_Node *specification;
            Node_List declarations;
            Node_List statements;
            Node_List handlers;
            bool is_separate;
            bool code_generated;  /* Prevents duplicate code generation */
        } subprogram_body;

        /* NK_PACKAGE_SPEC */
        struct {
            String_Slice name;
            Node_List visible_decls;
            Node_List private_decls;
        } package_spec;

        /* NK_PACKAGE_BODY */
        struct {
            String_Slice name;
            Node_List declarations;
            Node_List statements;
            Node_List handlers;
            bool is_separate;
        } package_body;

        /* NK_PACKAGE_RENAMING */
        struct {
            String_Slice new_name;
            Syntax_Node *old_name;
        } package_renaming;

        /* NK_TASK_SPEC */
        struct {
            String_Slice name;
            Node_List entries;  /* Entry declarations */
            bool is_type;       /* true if TASK TYPE, false if single TASK */
        } task_spec;

        /* NK_TASK_BODY */
        struct {
            String_Slice name;
            Node_List declarations;
            Node_List statements;
            Node_List handlers;
            bool is_separate;
        } task_body;

        /* NK_ENTRY_DECL */
        struct {
            String_Slice name;
            Node_List parameters;  /* Parameter specs */
            Node_List index_constraints;  /* For entry families */
        } entry_decl;

        /* NK_PARAM_SPEC */
        struct {
            Node_List names;
            Syntax_Node *param_type;
            Syntax_Node *default_expr;
            enum { MODE_IN, MODE_OUT, MODE_IN_OUT } mode;
        } param_spec;

        /* NK_GENERIC_DECL */
        struct {
            Node_List formals;
            Syntax_Node *unit;  /* The procedure/function/package being made generic */
        } generic_decl;

        /* NK_GENERIC_INST */
        struct {
            Syntax_Node *generic_name;
            Node_List actuals;
            String_Slice instance_name;
            Token_Kind unit_kind;  /* TK_PROCEDURE, TK_FUNCTION, or TK_PACKAGE */
        } generic_inst;

        /* NK_GENERIC_TYPE_PARAM: type T is ... */
        struct {
            String_Slice name;
            int def_kind;  /* 0=PRIVATE, 1=LIMITED_PRIVATE, 2=DISCRETE, 3=INTEGER, 4=FLOAT, 5=FIXED */
            Syntax_Node *def_detail;
        } generic_type_param;

        /* NK_GENERIC_OBJECT_PARAM: X : [mode] type [:= default] */
        struct {
            Node_List names;
            Syntax_Node *object_type;
            Syntax_Node *default_expr;
            int mode;  /* GEN_MODE_IN, GEN_MODE_IN_OUT */
        } generic_object_param;

        /* NK_GENERIC_SUBPROGRAM_PARAM: with procedure/function spec [is name|<>] */
        struct {
            String_Slice name;
            Node_List parameters;
            Syntax_Node *return_type;  /* NULL for procedures */
            Syntax_Node *default_name;
            bool is_function;
            bool default_box;
        } generic_subprog_param;

        /* NK_WITH_CLAUSE, NK_USE_CLAUSE */
        struct { Node_List names; } use_clause;

        /* NK_PRAGMA */
        struct { String_Slice name; Node_List arguments; } pragma_node;

        /* NK_EXCEPTION_HANDLER */
        struct { Node_List exceptions; Node_List statements; } handler;

        /* NK_REPRESENTATION_CLAUSE (RM 13.1) */
        struct {
            Syntax_Node *entity_name;    /* Type or object being represented */
            String_Slice attribute;       /* 'SIZE, 'ALIGNMENT, etc. (empty if record/enum rep) */
            Syntax_Node *expression;      /* Attribute value or address expression */
            Node_List    component_clauses; /* For record representation: component positions */
            bool         is_record_rep;   /* true if FOR T USE RECORD ... */
            bool         is_enum_rep;     /* true if FOR T USE (literals...) */
        } rep_clause;

        /* NK_CONTEXT_CLAUSE */
        struct { Node_List with_clauses; Node_List use_clauses; } context;

        /* NK_COMPILATION_UNIT */
        struct {
            Syntax_Node *context;
            Syntax_Node *unit;
            Syntax_Node *separate_parent;  /* Parent name for SEPARATE subunits */
        } compilation_unit;
    };
};

/* Node constructor - zero-initializes the union to ensure all pointers start NULL */
static Syntax_Node *Node_New(Node_Kind kind, Source_Location loc) {
    Syntax_Node *node = Arena_Allocate(sizeof(Syntax_Node));
    memset(node, 0, sizeof(Syntax_Node));  /* Zero all fields including union */
    node->kind = kind;
    node->location = loc;
    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9. PARSER — Recursive Descent with Unified Postfix Handling
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Recursive descent mirrors the grammar, making the grammar itself the invariant.
 *
 * Key design decisions:
 *
 * 1. UNIFIED APPLY NODE: All X(...) forms parse as NK_APPLY. Semantic analysis
 *    later distinguishes calls, indexing, slicing, and type conversions.
 *
 * 2. UNIFIED ASSOCIATION PARSING: One helper handles positional, named, and
 *    choice associations used in aggregates, calls, and generic actuals.
 *
 * 3. UNIFIED POSTFIX CHAIN: One loop handles .selector, 'attribute, (args).
 *
 * 4. NO "PRETEND TOKEN EXISTS": Error recovery synchronizes to known tokens
 *    rather than silently accepting malformed syntax. Guessing user intent
 *    produces cascading errors; admitting ignorance produces one.
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §9.1 Parser State
 * ───────────────────────────────────────────────────────────────────────── */

typedef struct {
    Lexer        lexer;
    Token        current_token;
    Token        previous_token;
    bool         had_error;
    bool         panic_mode;

    /* Progress tracking to detect stuck parsers */
    uint32_t     last_line;
    uint32_t     last_column;
    Token_Kind   last_kind;
} Parser;

static Parser Parser_New(const char *source, size_t length, const char *filename) {
    Parser p = {0};
    p.lexer = Lexer_New(source, length, filename);
    p.current_token = Lexer_Next_Token(&p.lexer);
    return p;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.2 Token Movement
 * ───────────────────────────────────────────────────────────────────────── */

static inline bool Parser_At(Parser *p, Token_Kind kind) {
    return p->current_token.kind == kind;
}

static inline bool Parser_At_Any(Parser *p, Token_Kind k1, Token_Kind k2) {
    return Parser_At(p, k1) || Parser_At(p, k2);
}

/* Lookahead: check if the NEXT token (after current) is of the given kind */
static bool Parser_Peek_At(Parser *p, Token_Kind kind) {
    Token saved = p->current_token;
    Lexer saved_lexer = p->lexer;

    /* Update prev_token_kind for context-sensitive lexing during lookahead */
    p->lexer.prev_token_kind = p->current_token.kind;
    p->current_token = Lexer_Next_Token(&p->lexer);
    bool result = p->current_token.kind == kind;

    p->current_token = saved;
    p->lexer = saved_lexer;
    return result;
}

static Token Parser_Advance(Parser *p) {
    p->previous_token = p->current_token;
    /* Update lexer's prev_token_kind before getting next token (for context-sensitive lexing) */
    p->lexer.prev_token_kind = p->current_token.kind;
    p->current_token = Lexer_Next_Token(&p->lexer);

    /* Handle compound keywords: AND THEN, OR ELSE */
    if (p->previous_token.kind == TK_AND && Parser_At(p, TK_THEN)) {
        p->previous_token.kind = TK_AND_THEN;
        p->lexer.prev_token_kind = TK_AND_THEN;
        p->current_token = Lexer_Next_Token(&p->lexer);
    } else if (p->previous_token.kind == TK_OR && Parser_At(p, TK_ELSE)) {
        p->previous_token.kind = TK_OR_ELSE;
        p->lexer.prev_token_kind = TK_OR_ELSE;
        p->current_token = Lexer_Next_Token(&p->lexer);
    }

    return p->previous_token;
}

static bool Parser_Match(Parser *p, Token_Kind kind) {
    if (!Parser_At(p, kind)) return false;
    Parser_Advance(p);
    return true;
}

static Source_Location Parser_Location(Parser *p) {
    return p->current_token.location;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.3 Error Recovery
 * ───────────────────────────────────────────────────────────────────────── */

static void Parser_Error(Parser *p, const char *message) {
    if (p->panic_mode) return;
    p->panic_mode = true;
    p->had_error = true;
    Report_Error(p->current_token.location, "%s", message);
}

static void Parser_Error_At_Current(Parser *p, const char *expected) {
    if (p->panic_mode) return;
    p->panic_mode = true;
    p->had_error = true;
    Report_Error(p->current_token.location, "expected %s, got %s",
                 expected, Token_Name[p->current_token.kind]);
}

/* Synchronize to a recovery point (statement/declaration boundary) */
static void Parser_Synchronize(Parser *p) {
    p->panic_mode = false;

    while (!Parser_At(p, TK_EOF)) {
        if (p->previous_token.kind == TK_SEMICOLON) return;

        switch (p->current_token.kind) {
            case TK_BEGIN: case TK_END: case TK_IF: case TK_CASE: case TK_LOOP:
            case TK_FOR: case TK_WHILE: case TK_RETURN: case TK_DECLARE:
            case TK_EXCEPTION: case TK_PROCEDURE: case TK_FUNCTION:
            case TK_PACKAGE: case TK_TASK: case TK_TYPE: case TK_SUBTYPE:
            case TK_PRAGMA: case TK_ACCEPT: case TK_SELECT:
                return;
            default:
                Parser_Advance(p);
        }
    }
}

/* Check for parser progress — detect stuck parsing loops */
static bool Parser_Check_Progress(Parser *p) {
    if (p->current_token.location.line == p->last_line &&
        p->current_token.location.column == p->last_column &&
        p->current_token.kind == p->last_kind) {
        Parser_Advance(p);
        return false;
    }
    p->last_line = p->current_token.location.line;
    p->last_column = p->current_token.location.column;
    p->last_kind = p->current_token.kind;
    return true;
}

/* Expect a specific token; report error and return false if not found */
static bool Parser_Expect(Parser *p, Token_Kind kind) {
    if (Parser_At(p, kind)) {
        Parser_Advance(p);
        return true;
    }
    Parser_Error_At_Current(p, Token_Name[kind]);
    return false;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.4 Identifier Parsing
 * ───────────────────────────────────────────────────────────────────────── */

static String_Slice Parser_Identifier(Parser *p) {
    if (!Parser_At(p, TK_IDENTIFIER)) {
        Parser_Error_At_Current(p, "identifier");
        return Empty_Slice;
    }
    String_Slice name = Slice_Duplicate(p->current_token.text);
    Parser_Advance(p);
    return name;
}

/* Check END identifier matches expected name (also handles operator strings) */
static void Parser_Check_End_Name(Parser *p, String_Slice expected_name) {
    if (Parser_At(p, TK_IDENTIFIER) || Parser_At(p, TK_STRING)) {
        String_Slice end_name = p->current_token.text;
        if (!Slice_Equal_Ignore_Case(end_name, expected_name)) {
            Report_Error(p->current_token.location,
                        "END name does not match (expected '%.*s', got '%.*s')",
                        expected_name.length, expected_name.data,
                        end_name.length, end_name.data);
        }
        Parser_Advance(p);
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.5 Expression Parsing — Operator Precedence
 *
 * The grammar encodes precedence while recursion direction determines associativity.
 *
 * Ada precedence (highest to lowest):
 *   ** (right associative)
 *   ABS NOT (unary prefix)
 *   * / MOD REM
 *   + - & (binary) + - (unary)
 *   = /= < <= > >= IN NOT IN
 *   AND OR XOR AND THEN OR ELSE
 * ───────────────────────────────────────────────────────────────────────── */

/* Forward declarations */
static Syntax_Node *Parse_Expression(Parser *p);
static Syntax_Node *Parse_Choice(Parser *p);
static Syntax_Node *Parse_Name(Parser *p);
static Syntax_Node *Parse_Simple_Name(Parser *p);  /* identifier or dotted, no parens/ticks */
static Syntax_Node *Parse_Subtype_Indication(Parser *p);
static Syntax_Node *Parse_Array_Type(Parser *p);
static void Parse_Association_List(Parser *p, Node_List *list);
static void Parse_Parameter_List(Parser *p, Node_List *params);

/* Parse primary: literals, names, aggregates, allocators, parenthesized */
static Syntax_Node *Parse_Primary(Parser *p) {
    Source_Location loc = Parser_Location(p);

    /* Integer literal */
    if (Parser_At(p, TK_INTEGER)) {
        Syntax_Node *node = Node_New(NK_INTEGER, loc);
        node->integer_lit.value = p->current_token.integer_value;
        node->integer_lit.big_value = p->current_token.big_integer;
        Parser_Advance(p);
        return node;
    }

    /* Real literal - store both double and Big_Real for arbitrary precision */
    if (Parser_At(p, TK_REAL)) {
        Syntax_Node *node = Node_New(NK_REAL, loc);
        node->real_lit.value = p->current_token.float_value;
        node->real_lit.big_value = p->current_token.big_real;
        Parser_Advance(p);
        return node;
    }

    /* Character literal - store only the text (e.g., "'X'"), extract char value when needed.
     * NOTE: Do not set integer_lit.value here - it overlaps with string_val.text.data
     * in the union and would corrupt the text pointer. */
    if (Parser_At(p, TK_CHARACTER)) {
        Syntax_Node *node = Node_New(NK_CHARACTER, loc);
        node->string_val.text = Slice_Duplicate(p->current_token.text);
        Parser_Advance(p);
        return node;
    }

    /* String literal - but check for operator symbol used as function name.
     * In Ada, "+"(X, Y) is a valid function call where "+" is the operator.
     * If this looks like an operator string followed by (, let it fall through
     * to Parse_Name which handles operator names and function calls. */
    if (Parser_At(p, TK_STRING)) {
        String_Slice text = p->current_token.text;
        bool is_operator_call = (text.length <= 3) && Parser_Peek_At(p, TK_LPAREN);
        if (!is_operator_call) {
            Syntax_Node *node = Node_New(NK_STRING, loc);
            node->string_val.text = Slice_Duplicate(text);
            Parser_Advance(p);
            return node;
        }
        /* Fall through to Parse_Name for operator call like "+"(X, Y) */
    }

    /* NULL */
    if (Parser_Match(p, TK_NULL)) {
        return Node_New(NK_NULL, loc);
    }

    /* OTHERS (in aggregates) */
    if (Parser_Match(p, TK_OTHERS)) {
        return Node_New(NK_OTHERS, loc);
    }

    /* NEW allocator */
    if (Parser_Match(p, TK_NEW)) {
        Syntax_Node *node = Node_New(NK_ALLOCATOR, loc);
        Syntax_Node *subtype = Parse_Subtype_Indication(p);

        /* If Parse_Subtype_Indication returned a qualified expression,
         * extract subtype_mark and expression separately */
        if (subtype->kind == NK_QUALIFIED) {
            node->allocator.subtype_mark = subtype->qualified.subtype_mark;
            node->allocator.expression = subtype->qualified.expression;
        } else {
            node->allocator.subtype_mark = subtype;
        }
        return node;
    }

    /* Unary operators: NOT, ABS, +, - */
    if (Parser_At_Any(p, TK_NOT, TK_ABS) ||
        Parser_At_Any(p, TK_PLUS, TK_MINUS)) {
        Token_Kind op = p->current_token.kind;
        Parser_Advance(p);
        Syntax_Node *node = Node_New(NK_UNARY_OP, loc);
        node->unary.op = op;
        node->unary.operand = Parse_Primary(p);
        return node;
    }

    /* Parenthesized expression or aggregate */
    if (Parser_Match(p, TK_LPAREN)) {
        Syntax_Node *expr = Parse_Expression(p);

        /* Check for aggregate indicators */
        if (Parser_At(p, TK_COMMA) || Parser_At(p, TK_ARROW) ||
            Parser_At(p, TK_BAR) || Parser_At(p, TK_WITH) ||
            Parser_At(p, TK_DOTDOT)) {
            /* This is an aggregate */
            Syntax_Node *node = Node_New(NK_AGGREGATE, loc);

            if (Parser_Match(p, TK_WITH)) {
                /* Extension aggregate: (ancestor with components) */
                Node_List_Push(&node->aggregate.items, expr);
                node->aggregate.is_named = true;
                Parse_Association_List(p, &node->aggregate.items);
            } else if (Parser_At(p, TK_DOTDOT)) {
                /* First element is a range: expr .. high */
                Syntax_Node *range = Node_New(NK_RANGE, loc);
                range->range.low = expr;
                Parser_Advance(p);  /* consume .. */
                range->range.high = Parse_Expression(p);

                /* Check for choice list or named association */
                if (Parser_At(p, TK_BAR) || Parser_At(p, TK_ARROW)) {
                    Syntax_Node *assoc = Node_New(NK_ASSOCIATION, loc);
                    Node_List_Push(&assoc->association.choices, range);

                    while (Parser_Match(p, TK_BAR)) {
                        Node_List_Push(&assoc->association.choices, Parse_Choice(p));
                    }
                    if (Parser_Match(p, TK_ARROW)) {
                        assoc->association.expression = Parse_Expression(p);
                    }
                    Node_List_Push(&node->aggregate.items, assoc);
                } else {
                    Node_List_Push(&node->aggregate.items, range);
                }

                if (Parser_Match(p, TK_COMMA)) {
                    Parse_Association_List(p, &node->aggregate.items);
                }
            } else if (Parser_At(p, TK_BAR) || Parser_At(p, TK_ARROW)) {
                /* First element is part of a choice list */
                Syntax_Node *assoc = Node_New(NK_ASSOCIATION, loc);
                Node_List_Push(&assoc->association.choices, expr);

                /* Collect additional choices */
                while (Parser_Match(p, TK_BAR)) {
                    Node_List_Push(&assoc->association.choices, Parse_Choice(p));
                }

                /* Named association: choices => value */
                if (Parser_Match(p, TK_ARROW)) {
                    assoc->association.expression = Parse_Expression(p);
                }

                Node_List_Push(&node->aggregate.items, assoc);

                /* Continue with remaining associations */
                if (Parser_Match(p, TK_COMMA)) {
                    Parse_Association_List(p, &node->aggregate.items);
                }
            } else {
                /* First element is positional, followed by more */
                Node_List_Push(&node->aggregate.items, expr);
                Parser_Advance(p);  /* consume the comma we know is there */
                Parse_Association_List(p, &node->aggregate.items);
            }
            Parser_Expect(p, TK_RPAREN);
            return node;
        }

        Parser_Expect(p, TK_RPAREN);
        return expr;
    }

    /* Name (identifier, selected, indexed, etc.) */
    return Parse_Name(p);
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.6 Unified Postfix Parsing
 *
 * Handles: .selector, 'attribute, (arguments) — in one loop.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Name(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Syntax_Node *node;

    /* Base: identifier or operator symbol */
    if (Parser_At(p, TK_IDENTIFIER)) {
        node = Node_New(NK_IDENTIFIER, loc);
        node->string_val.text = Parser_Identifier(p);
    } else if (Parser_At(p, TK_STRING)) {
        /* Operator symbol as name: "+" etc */
        node = Node_New(NK_IDENTIFIER, loc);
        node->string_val.text = Slice_Duplicate(p->current_token.text);
        Parser_Advance(p);
    } else {
        Parser_Error_At_Current(p, "name");
        return Node_New(NK_IDENTIFIER, loc);
    }

    /* Postfix chain */
    for (;;) {
        Source_Location postfix_loc = Parser_Location(p);

        /* .selector or .ALL */
        if (Parser_Match(p, TK_DOT)) {
            if (Parser_Match(p, TK_ALL)) {
                /* Dereference: prefix.ALL */
                Syntax_Node *deref = Node_New(NK_UNARY_OP, postfix_loc);
                deref->unary.op = TK_ALL;
                deref->unary.operand = node;
                node = deref;
            } else {
                /* Selection: prefix.component */
                Syntax_Node *sel = Node_New(NK_SELECTED, postfix_loc);
                sel->selected.prefix = node;
                sel->selected.selector = Parser_Identifier(p);
                node = sel;
            }
            continue;
        }

        /* 'attribute or '(qualified) */
        if (Parser_Match(p, TK_TICK)) {
            if (Parser_Match(p, TK_LPAREN)) {
                /* Qualified expression: Type'(Expr or Aggregate) */
                Syntax_Node *qual = Node_New(NK_QUALIFIED, postfix_loc);
                qual->qualified.subtype_mark = node;

                /* Parse expression or aggregate */
                Syntax_Node *expr = Parse_Expression(p);
                if (Parser_At(p, TK_COMMA) || Parser_At(p, TK_ARROW) ||
                    Parser_At(p, TK_BAR) || Parser_At(p, TK_DOTDOT)) {
                    /* Aggregate */
                    Syntax_Node *agg = Node_New(NK_AGGREGATE, postfix_loc);
                    if (Parser_At(p, TK_DOTDOT)) {
                        /* Range: expr .. high */
                        Syntax_Node *range = Node_New(NK_RANGE, postfix_loc);
                        range->range.low = expr;
                        Parser_Advance(p);
                        range->range.high = Parse_Expression(p);
                        if (Parser_At(p, TK_BAR) || Parser_At(p, TK_ARROW)) {
                            Syntax_Node *assoc = Node_New(NK_ASSOCIATION, postfix_loc);
                            Node_List_Push(&assoc->association.choices, range);
                            while (Parser_Match(p, TK_BAR)) {
                                Node_List_Push(&assoc->association.choices, Parse_Choice(p));
                            }
                            if (Parser_Match(p, TK_ARROW)) {
                                assoc->association.expression = Parse_Expression(p);
                            }
                            Node_List_Push(&agg->aggregate.items, assoc);
                        } else {
                            Node_List_Push(&agg->aggregate.items, range);
                        }
                        if (Parser_Match(p, TK_COMMA)) {
                            Parse_Association_List(p, &agg->aggregate.items);
                        }
                    } else if (Parser_At(p, TK_BAR) || Parser_At(p, TK_ARROW)) {
                        Syntax_Node *assoc = Node_New(NK_ASSOCIATION, postfix_loc);
                        Node_List_Push(&assoc->association.choices, expr);
                        while (Parser_Match(p, TK_BAR)) {
                            Node_List_Push(&assoc->association.choices, Parse_Choice(p));
                        }
                        if (Parser_Match(p, TK_ARROW)) {
                            assoc->association.expression = Parse_Expression(p);
                        }
                        Node_List_Push(&agg->aggregate.items, assoc);
                        if (Parser_Match(p, TK_COMMA)) {
                            Parse_Association_List(p, &agg->aggregate.items);
                        }
                    } else {
                        Node_List_Push(&agg->aggregate.items, expr);
                        Parser_Advance(p);  /* consume comma */
                        Parse_Association_List(p, &agg->aggregate.items);
                    }
                    qual->qualified.expression = agg;
                } else {
                    qual->qualified.expression = expr;
                }
                Parser_Expect(p, TK_RPAREN);
                node = qual;
            } else {
                /* Attribute: prefix'Name or prefix'Name(arg) */
                Syntax_Node *attr = Node_New(NK_ATTRIBUTE, postfix_loc);
                attr->attribute.prefix = node;

                /* Attribute name can be reserved word or identifier */
                if (Parser_At(p, TK_IDENTIFIER)) {
                    attr->attribute.name = Parser_Identifier(p);
                } else if (Parser_At(p, TK_RANGE) || Parser_At(p, TK_DIGITS) ||
                           Parser_At(p, TK_DELTA) || Parser_At(p, TK_ACCESS) ||
                           Parser_At(p, TK_MOD)) {
                    attr->attribute.name = Slice_Duplicate(p->current_token.text);
                    Parser_Advance(p);
                } else {
                    Parser_Error_At_Current(p, "attribute name");
                }

                /* Optional attribute arguments (one or more) */
                if (Parser_Match(p, TK_LPAREN)) {
                    Parse_Association_List(p, &attr->attribute.arguments);
                    Parser_Expect(p, TK_RPAREN);
                }
                node = attr;
            }
            continue;
        }

        /* (arguments) — call, index, slice, or type conversion */
        if (Parser_Match(p, TK_LPAREN)) {
            Syntax_Node *apply = Node_New(NK_APPLY, postfix_loc);
            apply->apply.prefix = node;
            Parse_Association_List(p, &apply->apply.arguments);
            Parser_Expect(p, TK_RPAREN);
            node = apply;
            continue;
        }

        break;
    }

    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.6.1 Simple Name Parsing (no parentheses or attributes)
 *
 * Used for generic unit names in instantiations where we don't want
 * parentheses interpreted as function calls.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Simple_Name(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Syntax_Node *node;

    /* Base: identifier */
    if (Parser_At(p, TK_IDENTIFIER)) {
        node = Node_New(NK_IDENTIFIER, loc);
        node->string_val.text = Parser_Identifier(p);
    } else {
        Parser_Error_At_Current(p, "identifier");
        return Node_New(NK_IDENTIFIER, loc);
    }

    /* Only follow dotted selections, not parentheses or ticks */
    for (;;) {
        if (Parser_Match(p, TK_DOT)) {
            Source_Location sel_loc = Parser_Location(p);
            Syntax_Node *sel = Node_New(NK_SELECTED, sel_loc);
            sel->selected.prefix = node;
            sel->selected.selector = Parser_Identifier(p);
            node = sel;
            continue;
        }
        break;
    }

    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.7 Unified Association Parsing
 *
 * The same syntax serves calls, aggregates, and instantiations. The parser
 * cannot tell them apart; semantic analysis can.
 * ───────────────────────────────────────────────────────────────────────── */

/* Helper to parse a choice (expression, range, or discrete_subtype_indication) */
static Syntax_Node *Parse_Choice(Parser *p) {
    Source_Location loc = Parser_Location(p);

    /* OTHERS choice */
    if (Parser_Match(p, TK_OTHERS)) {
        return Node_New(NK_OTHERS, loc);
    }

    Syntax_Node *expr = Parse_Expression(p);

    /* Check if this is a range: expr .. expr */
    if (Parser_Match(p, TK_DOTDOT)) {
        Syntax_Node *range = Node_New(NK_RANGE, loc);
        range->range.low = expr;
        range->range.high = Parse_Expression(p);
        return range;
    }

    /* Check for subtype_mark RANGE low..high (discrete_subtype_indication)
     * This handles index constraints like: INTEGER RANGE 1..10 */
    if (Parser_Match(p, TK_RANGE)) {
        Syntax_Node *ind = Node_New(NK_SUBTYPE_INDICATION, loc);
        ind->subtype_ind.subtype_mark = expr;

        Syntax_Node *constraint = Node_New(NK_RANGE_CONSTRAINT, loc);
        Syntax_Node *range_low = Parse_Expression(p);

        if (Parser_Match(p, TK_DOTDOT)) {
            Syntax_Node *range_node = Node_New(NK_RANGE, loc);
            range_node->range.low = range_low;
            range_node->range.high = Parse_Expression(p);
            constraint->range_constraint.range = range_node;
        } else {
            /* Just a range attribute or name */
            constraint->range_constraint.range = range_low;
        }

        ind->subtype_ind.constraint = constraint;
        return ind;
    }

    return expr;
}

static void Parse_Association_List(Parser *p, Node_List *list) {
    if (Parser_At(p, TK_RPAREN)) return;  /* Empty list */

    do {
        Source_Location loc = Parser_Location(p);
        Syntax_Node *first = Parse_Choice(p);

        /* Check for choice list with | or named association with => */
        if (Parser_At(p, TK_BAR) || Parser_At(p, TK_ARROW)) {
            Syntax_Node *assoc = Node_New(NK_ASSOCIATION, loc);
            Node_List_Push(&assoc->association.choices, first);

            /* Collect additional choices */
            while (Parser_Match(p, TK_BAR)) {
                Node_List_Push(&assoc->association.choices, Parse_Choice(p));
            }

            /* Named association: choices => value */
            if (Parser_Match(p, TK_ARROW)) {
                assoc->association.expression = Parse_Expression(p);
            }

            Node_List_Push(list, assoc);
        } else {
            /* Positional association */
            Node_List_Push(list, first);
        }
    } while (Parser_Match(p, TK_COMMA));
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.8 Binary Expression Parsing — Precedence Climbing
 *
 * Climbing starts at low precedence and consumes equal-or-higher before returning.
 * ───────────────────────────────────────────────────────────────────────── */

/* Precedence levels */
typedef enum {
    PREC_NONE = 0,
    PREC_LOGICAL,      /* AND, OR, XOR, AND_THEN, OR_ELSE */
    PREC_RELATIONAL,   /* = /= < <= > >= IN */
    PREC_ADDITIVE,     /* + - & */
    PREC_MULTIPLICATIVE, /* * / MOD REM */
    PREC_EXPONENTIAL,  /* ** */
    PREC_UNARY,        /* NOT ABS + - */
    PREC_PRIMARY
} Precedence;

static Precedence Get_Infix_Precedence(Token_Kind kind) {
    switch (kind) {
        case TK_AND: case TK_OR: case TK_XOR:
        case TK_AND_THEN: case TK_OR_ELSE:
            return PREC_LOGICAL;
        case TK_EQ: case TK_NE: case TK_LT: case TK_LE:
        case TK_GT: case TK_GE: case TK_IN: case TK_NOT:
            return PREC_RELATIONAL;
        case TK_PLUS: case TK_MINUS: case TK_AMPERSAND:
            return PREC_ADDITIVE;
        case TK_STAR: case TK_SLASH: case TK_MOD: case TK_REM:
            return PREC_MULTIPLICATIVE;
        case TK_EXPON:
            return PREC_EXPONENTIAL;
        default:
            return PREC_NONE;
    }
}

static bool Is_Right_Associative(Token_Kind kind) {
    return kind == TK_EXPON;
}

static Syntax_Node *Parse_Expression_Precedence(Parser *p, Precedence min_prec);

static Syntax_Node *Parse_Unary(Parser *p) {
    Source_Location loc = Parser_Location(p);

    if (Parser_At_Any(p, TK_PLUS, TK_MINUS) ||
        Parser_At_Any(p, TK_NOT, TK_ABS)) {
        Token_Kind op = p->current_token.kind;
        Parser_Advance(p);
        Syntax_Node *node = Node_New(NK_UNARY_OP, loc);
        node->unary.op = op;
        node->unary.operand = Parse_Unary(p);
        return node;
    }

    return Parse_Primary(p);
}

static Syntax_Node *Parse_Expression_Precedence(Parser *p, Precedence min_prec) {
    Syntax_Node *left = Parse_Unary(p);

    for (;;) {
        Token_Kind op = p->current_token.kind;
        Precedence prec = Get_Infix_Precedence(op);

        if (prec < min_prec) break;

        Source_Location loc = Parser_Location(p);
        Parser_Advance(p);

        /* After advance, check for compound keywords (AND THEN, OR ELSE)
         * that were detected in Parser_Advance */
        if (p->previous_token.kind == TK_AND_THEN || p->previous_token.kind == TK_OR_ELSE) {
            op = p->previous_token.kind;
        }

        /* Handle NOT IN specially */
        if (op == TK_NOT && Parser_At(p, TK_IN)) {
            Parser_Advance(p);
            Syntax_Node *node = Node_New(NK_BINARY_OP, loc);
            node->binary.op = TK_NOT;  /* NOT IN encoded as NOT with IN semantics */
            node->binary.left = left;
            node->binary.right = Parse_Expression_Precedence(p, prec + 1);
            left = node;
            continue;
        }

        /* Handle IN with possible range */
        if (op == TK_IN) {
            Syntax_Node *right = Parse_Expression_Precedence(p, prec + 1);

            /* Check for range: X in A .. B */
            if (Parser_Match(p, TK_DOTDOT)) {
                Syntax_Node *range = Node_New(NK_RANGE, loc);
                range->range.low = right;
                range->range.high = Parse_Expression_Precedence(p, prec + 1);
                right = range;
            }

            Syntax_Node *node = Node_New(NK_BINARY_OP, loc);
            node->binary.op = TK_IN;
            node->binary.left = left;
            node->binary.right = right;
            left = node;
            continue;
        }

        /* Standard binary operation */
        Precedence next_prec = Is_Right_Associative(op) ? prec : prec + 1;
        Syntax_Node *right = Parse_Expression_Precedence(p, next_prec);

        Syntax_Node *node = Node_New(NK_BINARY_OP, loc);
        node->binary.op = op;
        node->binary.left = left;
        node->binary.right = right;
        left = node;
    }

    return left;
}

static Syntax_Node *Parse_Expression(Parser *p) {
    return Parse_Expression_Precedence(p, PREC_LOGICAL);
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.9 Range Parsing
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Range(Parser *p) {
    Source_Location loc = Parser_Location(p);

    /* BOX: <> for unconstrained */
    if (Parser_Match(p, TK_BOX)) {
        return Node_New(NK_RANGE, loc);  /* Empty range = unconstrained */
    }

    Syntax_Node *low = Parse_Expression(p);

    if (Parser_Match(p, TK_DOTDOT)) {
        Syntax_Node *node = Node_New(NK_RANGE, loc);
        node->range.low = low;
        node->range.high = Parse_Expression(p);
        return node;
    }

    /* Check for subtype_mark RANGE low..high (discrete subtype definition)
     * e.g., "INTEGER RANGE 1..10" or "STAT RANGE 1..5" */
    if (Parser_Match(p, TK_RANGE)) {
        Syntax_Node *ind = Node_New(NK_SUBTYPE_INDICATION, loc);
        ind->subtype_ind.subtype_mark = low;

        /* Now parse the actual range constraint */
        Syntax_Node *constraint = Node_New(NK_RANGE_CONSTRAINT, loc);
        Syntax_Node *range_low = Parse_Expression(p);

        if (Parser_Match(p, TK_DOTDOT)) {
            Syntax_Node *range_node = Node_New(NK_RANGE, loc);
            range_node->range.low = range_low;
            range_node->range.high = Parse_Expression(p);
            constraint->range_constraint.range = range_node;
        } else {
            /* Just a range attribute or name */
            constraint->range_constraint.range = range_low;
        }

        ind->subtype_ind.constraint = constraint;
        return ind;
    }

    /* Could be a subtype name used as a range */
    return low;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.10 Subtype Indication Parsing
 *
 * A subtype is a type with a constraint that narrows the range of valid values.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Subtype_Indication(Parser *p) {
    Source_Location loc = Parser_Location(p);

    /* Parse_Name may consume (args) as NK_APPLY - we need to unwrap it for constraints */
    Syntax_Node *name_or_apply = Parse_Name(p);

    /* If Parse_Name returned NK_APPLY, the parenthesized part might be a constraint */
    if (name_or_apply->kind == NK_APPLY) {
        Syntax_Node *subtype_mark = name_or_apply->apply.prefix;
        Node_List *items = &name_or_apply->apply.arguments;

        /* Classify: if any item is a named association, it's a discriminant constraint */
        bool is_discriminant = false;
        for (uint32_t i = 0; i < items->count; i++) {
            Syntax_Node *item = items->items[i];
            if (item->kind == NK_ASSOCIATION) {
                is_discriminant = true;
                break;
            }
        }

        /* Create NK_SUBTYPE_INDICATION with appropriate constraint */
        Syntax_Node *ind = Node_New(NK_SUBTYPE_INDICATION, loc);
        ind->subtype_ind.subtype_mark = subtype_mark;

        if (is_discriminant) {
            Syntax_Node *constraint = Node_New(NK_DISCRIMINANT_CONSTRAINT, loc);
            constraint->discriminant_constraint.associations = *items;
            ind->subtype_ind.constraint = constraint;
        } else {
            Syntax_Node *constraint = Node_New(NK_INDEX_CONSTRAINT, loc);
            constraint->index_constraint.ranges = *items;
            ind->subtype_ind.constraint = constraint;
        }

        return ind;
    }

    Syntax_Node *subtype_mark = name_or_apply;

    /* Check for RANGE constraint */
    if (Parser_Match(p, TK_RANGE)) {
        Syntax_Node *ind = Node_New(NK_SUBTYPE_INDICATION, loc);
        ind->subtype_ind.subtype_mark = subtype_mark;

        Syntax_Node *constraint = Node_New(NK_RANGE_CONSTRAINT, loc);
        constraint->range_constraint.range = Parse_Range(p);
        ind->subtype_ind.constraint = constraint;
        return ind;
    }

    /* Check for DIGITS constraint (floating-point types) */
    if (Parser_Match(p, TK_DIGITS)) {
        Syntax_Node *ind = Node_New(NK_SUBTYPE_INDICATION, loc);
        ind->subtype_ind.subtype_mark = subtype_mark;

        Syntax_Node *constraint = Node_New(NK_DIGITS_CONSTRAINT, loc);
        constraint->digits_constraint.digits_expr = Parse_Expression(p);

        /* Optional RANGE constraint after DIGITS */
        if (Parser_Match(p, TK_RANGE)) {
            constraint->digits_constraint.range = Parse_Range(p);
        }

        ind->subtype_ind.constraint = constraint;
        return ind;
    }

    /* Check for DELTA constraint (fixed-point types) */
    if (Parser_Match(p, TK_DELTA)) {
        Syntax_Node *ind = Node_New(NK_SUBTYPE_INDICATION, loc);
        ind->subtype_ind.subtype_mark = subtype_mark;

        Syntax_Node *constraint = Node_New(NK_DELTA_CONSTRAINT, loc);
        constraint->delta_constraint.delta_expr = Parse_Expression(p);

        /* Optional RANGE constraint after DELTA */
        if (Parser_Match(p, TK_RANGE)) {
            constraint->delta_constraint.range = Parse_Range(p);
        }

        ind->subtype_ind.constraint = constraint;
        return ind;
    }

    return subtype_mark;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.11 Statement Parsing
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Statements run in sequence while expressions form a tree, and parsing reflects this.
 */

/* Forward declarations */
static Syntax_Node *Parse_Statement(Parser *p);
static void Parse_Statement_Sequence(Parser *p, Node_List *list);
static void Parse_Declarative_Part(Parser *p, Node_List *list);
static Syntax_Node *Parse_Declaration(Parser *p);
static Syntax_Node *Parse_Type_Definition(Parser *p);
static Syntax_Node *Parse_Subprogram_Body(Parser *p, Syntax_Node *spec);
static Syntax_Node *Parse_Block_Statement(Parser *p, String_Slice label);
static Syntax_Node *Parse_Loop_Statement(Parser *p, String_Slice label);
static Syntax_Node *Parse_Pragma(Parser *p);

/* ─────────────────────────────────────────────────────────────────────────
 * §9.11.1 Simple Statements
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Assignment_Or_Call(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Syntax_Node *target = Parse_Name(p);

    if (Parser_Match(p, TK_ASSIGN)) {
        Syntax_Node *node = Node_New(NK_ASSIGNMENT, loc);
        node->assignment.target = target;
        node->assignment.value = Parse_Expression(p);
        return node;
    }

    /* Procedure call (target is already an NK_APPLY or NK_IDENTIFIER) */
    Syntax_Node *call = Node_New(NK_CALL_STMT, loc);
    call->assignment.target = target;  /* Reuse field for simplicity */
    return call;
}

static Syntax_Node *Parse_Return_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_RETURN);

    Syntax_Node *node = Node_New(NK_RETURN, loc);
    if (!Parser_At(p, TK_SEMICOLON)) {
        node->return_stmt.expression = Parse_Expression(p);
    }
    return node;
}

static Syntax_Node *Parse_Exit_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_EXIT);

    Syntax_Node *node = Node_New(NK_EXIT, loc);
    if (Parser_At(p, TK_IDENTIFIER)) {
        node->exit_stmt.loop_name = Parser_Identifier(p);
    }
    if (Parser_Match(p, TK_WHEN)) {
        node->exit_stmt.condition = Parse_Expression(p);
    }
    return node;
}

static Syntax_Node *Parse_Goto_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_GOTO);

    Syntax_Node *node = Node_New(NK_GOTO, loc);
    node->goto_stmt.name = Parser_Identifier(p);
    return node;
}

static Syntax_Node *Parse_Raise_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_RAISE);

    Syntax_Node *node = Node_New(NK_RAISE, loc);
    if (Parser_At(p, TK_IDENTIFIER)) {
        node->raise_stmt.exception_name = Parse_Name(p);
    }
    return node;
}

static Syntax_Node *Parse_Delay_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_DELAY);

    Syntax_Node *node = Node_New(NK_DELAY, loc);
    node->delay_stmt.expression = Parse_Expression(p);
    return node;
}

static Syntax_Node *Parse_Abort_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_ABORT);

    Syntax_Node *node = Node_New(NK_ABORT, loc);
    do {
        Node_List_Push(&node->abort_stmt.task_names, Parse_Name(p));
    } while (Parser_Match(p, TK_COMMA));
    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.11.2 If Statement
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_If_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_IF);

    Syntax_Node *node = Node_New(NK_IF, loc);
    node->if_stmt.condition = Parse_Expression(p);
    Parser_Expect(p, TK_THEN);
    Parse_Statement_Sequence(p, &node->if_stmt.then_stmts);

    /* ELSIF parts */
    while (Parser_At(p, TK_ELSIF)) {
        Source_Location elsif_loc = Parser_Location(p);
        Parser_Advance(p);

        Syntax_Node *elsif = Node_New(NK_IF, elsif_loc);
        elsif->if_stmt.condition = Parse_Expression(p);
        Parser_Expect(p, TK_THEN);
        Parse_Statement_Sequence(p, &elsif->if_stmt.then_stmts);

        Node_List_Push(&node->if_stmt.elsif_parts, elsif);
    }

    /* ELSE part */
    if (Parser_Match(p, TK_ELSE)) {
        Parse_Statement_Sequence(p, &node->if_stmt.else_stmts);
    }

    Parser_Expect(p, TK_END);
    Parser_Expect(p, TK_IF);
    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.11.3 Case Statement
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Case_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_CASE);

    Syntax_Node *node = Node_New(NK_CASE, loc);
    node->case_stmt.expression = Parse_Expression(p);
    Parser_Expect(p, TK_IS);

    /* Parse alternatives */
    while (Parser_At(p, TK_WHEN)) {
        Source_Location alt_loc = Parser_Location(p);
        Parser_Advance(p);

        Syntax_Node *alt = Node_New(NK_ASSOCIATION, alt_loc);

        /* Parse choices - use Parse_Choice to handle ranges and OTHERS */
        do {
            Node_List_Push(&alt->association.choices, Parse_Choice(p));
        } while (Parser_Match(p, TK_BAR));

        Parser_Expect(p, TK_ARROW);

        /* Statements for this alternative stored as expression temporarily */
        Syntax_Node *stmts = Node_New(NK_BLOCK, alt_loc);
        Parse_Statement_Sequence(p, &stmts->block_stmt.statements);
        alt->association.expression = stmts;

        Node_List_Push(&node->case_stmt.alternatives, alt);
    }

    Parser_Expect(p, TK_END);
    Parser_Expect(p, TK_CASE);
    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.11.4 Loop Statement
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Loop_Statement(Parser *p, String_Slice label) {
    Source_Location loc = Parser_Location(p);
    Syntax_Node *node = Node_New(NK_LOOP, loc);
    node->loop_stmt.label = label;

    /* WHILE loop */
    if (Parser_Match(p, TK_WHILE)) {
        node->loop_stmt.iteration_scheme = Parse_Expression(p);
    }
    /* FOR loop */
    else if (Parser_Match(p, TK_FOR)) {
        Source_Location for_loc = Parser_Location(p);
        Syntax_Node *iter = Node_New(NK_BINARY_OP, for_loc);
        iter->binary.op = TK_IN;

        /* Iterator identifier */
        Syntax_Node *id = Node_New(NK_IDENTIFIER, for_loc);
        id->string_val.text = Parser_Identifier(p);
        iter->binary.left = id;

        Parser_Expect(p, TK_IN);

        node->loop_stmt.is_reverse = Parser_Match(p, TK_REVERSE);

        /* Discrete range */
        iter->binary.right = Parse_Range(p);
        node->loop_stmt.iteration_scheme = iter;
    }

    Parser_Expect(p, TK_LOOP);
    Parse_Statement_Sequence(p, &node->loop_stmt.statements);
    Parser_Expect(p, TK_END);
    Parser_Expect(p, TK_LOOP);

    if (label.data && Parser_At(p, TK_IDENTIFIER)) {
        Parser_Check_End_Name(p, label);
    }

    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.11.5 Block Statement
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Block_Statement(Parser *p, String_Slice label) {
    Source_Location loc = Parser_Location(p);
    Syntax_Node *node = Node_New(NK_BLOCK, loc);
    node->block_stmt.label = label;

    if (Parser_Match(p, TK_DECLARE)) {
        Parse_Declarative_Part(p, &node->block_stmt.declarations);
    }

    Parser_Expect(p, TK_BEGIN);
    Parse_Statement_Sequence(p, &node->block_stmt.statements);

    if (Parser_Match(p, TK_EXCEPTION)) {
        while (Parser_At(p, TK_WHEN)) {
            Source_Location h_loc = Parser_Location(p);
            Parser_Advance(p);

            Syntax_Node *handler = Node_New(NK_EXCEPTION_HANDLER, h_loc);

            /* Exception choices */
            do {
                if (Parser_Match(p, TK_OTHERS)) {
                    Node_List_Push(&handler->handler.exceptions, Node_New(NK_OTHERS, h_loc));
                } else {
                    Node_List_Push(&handler->handler.exceptions, Parse_Name(p));
                }
            } while (Parser_Match(p, TK_BAR));

            Parser_Expect(p, TK_ARROW);
            Parse_Statement_Sequence(p, &handler->handler.statements);

            Node_List_Push(&node->block_stmt.handlers, handler);
        }
    }

    Parser_Expect(p, TK_END);
    if (label.data && Parser_At(p, TK_IDENTIFIER)) {
        Parser_Check_End_Name(p, label);
    }

    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.11.6 Accept Statement
 *
 * ACCEPT is the server side of rendezvous where the caller blocks until accepted.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Accept_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_ACCEPT);

    Syntax_Node *node = Node_New(NK_ACCEPT, loc);
    node->accept_stmt.entry_name = Parser_Identifier(p);

    /* Optional index and/or parameters
     * Need to distinguish:
     * - Entry index: (expression) like (5) or (I)
     * - Parameters: (id : type) like (X : INTEGER) */
    if (Parser_At(p, TK_LPAREN)) {
        /* Lookahead to distinguish index vs parameters */
        Token saved = p->current_token;
        Lexer saved_lexer = p->lexer;
        Parser_Advance(p);  /* consume ( */

        bool is_parameter_list = false;
        if (Parser_At(p, TK_IDENTIFIER)) {
            Parser_Advance(p);  /* past identifier */
            /* If followed by : or ,, it's a parameter list */
            is_parameter_list = Parser_At(p, TK_COLON) || Parser_At(p, TK_COMMA);
        }

        /* Restore and parse correctly */
        p->current_token = saved;
        p->lexer = saved_lexer;

        if (is_parameter_list) {
            /* This is a parameter list, not an index */
            Parse_Parameter_List(p, &node->accept_stmt.parameters);
        } else {
            /* Parse entry index (expression) */
            Parser_Advance(p);  /* consume ( */
            node->accept_stmt.index = Parse_Expression(p);
            Parser_Expect(p, TK_RPAREN);

            /* Now check for optional parameters after index */
            if (Parser_At(p, TK_LPAREN)) {
                Parse_Parameter_List(p, &node->accept_stmt.parameters);
            }
        }
    }

    /* Optional body */
    if (Parser_Match(p, TK_DO)) {
        Parse_Statement_Sequence(p, &node->accept_stmt.statements);
        Parser_Expect(p, TK_END);
        if (Parser_At(p, TK_IDENTIFIER)) {
            Parser_Check_End_Name(p, node->accept_stmt.entry_name);
        }
    }

    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.11.7 Select Statement
 *
 * SELECT makes a nondeterministic choice among open alternatives at runtime.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Select_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_SELECT);

    Syntax_Node *node = Node_New(NK_SELECT, loc);

    /* Parse alternatives */
    do {
        Source_Location alt_loc = Parser_Location(p);

        if (Parser_Match(p, TK_WHEN)) {
            /* Guarded alternative */
            Syntax_Node *alt = Node_New(NK_ASSOCIATION, alt_loc);
            Node_List_Push(&alt->association.choices, Parse_Expression(p));
            Parser_Expect(p, TK_ARROW);
            alt->association.expression = Parse_Statement(p);
            Node_List_Push(&node->select_stmt.alternatives, alt);
        } else if (Parser_Match(p, TK_TERMINATE)) {
            Syntax_Node *term = Node_New(NK_NULL_STMT, alt_loc);
            Node_List_Push(&node->select_stmt.alternatives, term);
            Parser_Expect(p, TK_SEMICOLON);
        } else if (Parser_Match(p, TK_DELAY)) {
            Syntax_Node *delay = Node_New(NK_DELAY, alt_loc);
            delay->delay_stmt.expression = Parse_Expression(p);
            Parser_Expect(p, TK_SEMICOLON);
            Node_List_Push(&node->select_stmt.alternatives, delay);
        } else if (Parser_At(p, TK_ACCEPT)) {
            Syntax_Node *accept = Parse_Accept_Statement(p);
            Node_List_Push(&node->select_stmt.alternatives, accept);
            Parser_Expect(p, TK_SEMICOLON);
            /* Optional sequence of statements after accept in select */
            while (!Parser_At(p, TK_OR) && !Parser_At(p, TK_ELSE) &&
                   !Parser_At(p, TK_END) && !Parser_At(p, TK_EOF)) {
                Syntax_Node *stmt = Parse_Statement(p);
                Node_List_Push(&accept->accept_stmt.statements, stmt);
                if (!Parser_At(p, TK_OR) && !Parser_At(p, TK_ELSE) && !Parser_At(p, TK_END)) {
                    Parser_Expect(p, TK_SEMICOLON);
                }
            }
        } else {
            break;
        }
    } while (Parser_Match(p, TK_OR));

    if (Parser_Match(p, TK_ELSE)) {
        node->select_stmt.else_part = Node_New(NK_BLOCK, loc);
        Parse_Statement_Sequence(p, &node->select_stmt.else_part->block_stmt.statements);
    }

    Parser_Expect(p, TK_END);
    Parser_Expect(p, TK_SELECT);
    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.11.8 Statement Dispatch
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Statement(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Source_Location label_loc = loc;

    /* Check for label(s): <<label>> or identifier:
     * Ada allows multiple labels before a statement: <<L1>> <<L2>> stmt; */
    String_Slice label = Empty_Slice;

    /* Handle multiple consecutive labels */
    while (Parser_At(p, TK_LSHIFT) ||
           (Parser_At(p, TK_IDENTIFIER) && Parser_Peek_At(p, TK_COLON))) {

        if (Parser_Match(p, TK_LSHIFT)) {
            if (label.length == 0) label_loc = loc;  /* Save first label location */
            label = Parser_Identifier(p);
            Parser_Expect(p, TK_RSHIFT);
        } else if (Parser_At(p, TK_IDENTIFIER)) {
            /* Lookahead for "identifier :" (label) vs assignment/call */
            Token saved = p->current_token;
            Lexer saved_lexer = p->lexer;
            String_Slice id = Parser_Identifier(p);

            if (Parser_Match(p, TK_COLON)) {
                /* This is a label */
                if (label.length == 0) label_loc = loc;  /* Save first label location */
                label = id;
            } else {
                /* Not a label - restore and let assignment/call handle it */
                p->current_token = saved;
                p->lexer = saved_lexer;
                break;
            }
        }
        loc = Parser_Location(p);  /* Update location to after labels */
    }

    Syntax_Node *stmt = NULL;

    /* Null statement */
    if (Parser_Match(p, TK_NULL)) {
        /* Semicolon is handled by Parse_Statement_Sequence */
        stmt = Node_New(NK_NULL_STMT, loc);
    }
    /* Compound statements - loops and blocks handle labels as names */
    else if (Parser_At(p, TK_LOOP) || Parser_At(p, TK_WHILE) || Parser_At(p, TK_FOR)) {
        return Parse_Loop_Statement(p, label);  /* Loop keeps label as name */
    }
    else if (Parser_At(p, TK_DECLARE) || Parser_At(p, TK_BEGIN)) {
        return Parse_Block_Statement(p, label);  /* Block keeps label as name */
    }
    else if (Parser_At(p, TK_IF)) stmt = Parse_If_Statement(p);
    else if (Parser_At(p, TK_CASE)) stmt = Parse_Case_Statement(p);
    else if (Parser_At(p, TK_ACCEPT)) stmt = Parse_Accept_Statement(p);
    else if (Parser_At(p, TK_SELECT)) stmt = Parse_Select_Statement(p);
    /* Simple statements */
    else if (Parser_At(p, TK_RETURN)) stmt = Parse_Return_Statement(p);
    else if (Parser_At(p, TK_EXIT)) stmt = Parse_Exit_Statement(p);
    else if (Parser_At(p, TK_GOTO)) stmt = Parse_Goto_Statement(p);
    else if (Parser_At(p, TK_RAISE)) stmt = Parse_Raise_Statement(p);
    else if (Parser_At(p, TK_DELAY)) stmt = Parse_Delay_Statement(p);
    else if (Parser_At(p, TK_ABORT)) stmt = Parse_Abort_Statement(p);
    /* Pragma in statement sequence (Ada 83 RM 2.8) */
    else if (Parser_At(p, TK_PRAGMA)) stmt = Parse_Pragma(p);
    /* Assignment or procedure call */
    else stmt = Parse_Assignment_Or_Call(p);

    /* Wrap in NK_LABEL if a label was present (except for loop/block which handle labels) */
    if (label.length > 0 && stmt != NULL) {
        Syntax_Node *label_node = Node_New(NK_LABEL, label_loc);
        label_node->label_node.name = label;
        label_node->label_node.statement = stmt;
        label_node->label_node.symbol = NULL;  /* Set during resolution */
        return label_node;
    }

    return stmt;
}

static void Parse_Statement_Sequence(Parser *p, Node_List *list) {
    while (!Parser_At(p, TK_EOF) &&
           !Parser_At(p, TK_END) &&
           !Parser_At(p, TK_ELSE) &&
           !Parser_At(p, TK_ELSIF) &&
           !Parser_At(p, TK_WHEN) &&
           !Parser_At(p, TK_EXCEPTION) &&
           !Parser_At(p, TK_OR)) {

        if (!Parser_Check_Progress(p)) break;

        Syntax_Node *stmt = Parse_Statement(p);
        Node_List_Push(list, stmt);

        if (!Parser_At(p, TK_END) && !Parser_At(p, TK_ELSE) &&
            !Parser_At(p, TK_ELSIF) && !Parser_At(p, TK_WHEN) &&
            !Parser_At(p, TK_EXCEPTION) && !Parser_At(p, TK_OR)) {
            Parser_Expect(p, TK_SEMICOLON);
        }
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.12 Declaration Parsing
 * ═══════════════════════════════════════════════════════════════════════════
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §9.12.1 Object Declaration (variables, constants)
 *
 * Multiple names can share one type declaration but each gets its own symbol.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Object_Declaration(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Syntax_Node *node = Node_New(NK_OBJECT_DECL, loc);

    /* Identifier list */
    do {
        Syntax_Node *id = Node_New(NK_IDENTIFIER, Parser_Location(p));
        id->string_val.text = Parser_Identifier(p);
        Node_List_Push(&node->object_decl.names, id);
    } while (Parser_Match(p, TK_COMMA));

    Parser_Expect(p, TK_COLON);

    /* Check for exception declaration: identifier_list : EXCEPTION [RENAMES name] */
    if (Parser_Match(p, TK_EXCEPTION)) {
        /* Check for renaming */
        if (Parser_Match(p, TK_RENAMES)) {
            node->kind = NK_EXCEPTION_RENAMING;
            node->exception_decl.names = node->object_decl.names;
            node->exception_decl.renamed = Parse_Name(p);
        } else {
            node->kind = NK_EXCEPTION_DECL;
            node->exception_decl.names = node->object_decl.names;
        }
        return node;
    }

    node->object_decl.is_aliased = Parser_Match(p, TK_ACCESS);  /* ALIASED uses ACCESS token? */
    node->object_decl.is_constant = Parser_Match(p, TK_CONSTANT);

    /* Named number (number declaration): identifier : CONSTANT := static_expression; */
    /* No type specified, goes directly to := */
    if (!node->object_decl.is_constant || !Parser_At(p, TK_ASSIGN)) {
        /* Check for anonymous array type: ARRAY (...) OF ... */
        if (Parser_At(p, TK_ARRAY)) {
            node->object_decl.object_type = Parse_Array_Type(p);
        } else {
            node->object_decl.object_type = Parse_Subtype_Indication(p);
        }
    }

    /* Renames: X : T RENAMES Y */
    if (Parser_Match(p, TK_RENAMES)) {
        node->object_decl.is_rename = true;
        node->object_decl.init = Parse_Name(p);
        return node;
    }

    /* Initialization */
    if (Parser_Match(p, TK_ASSIGN)) {
        node->object_decl.init = Parse_Expression(p);
    }

    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.12.2 Type Declaration
 *
 * Discriminants parameterize the type with values fixed when the object is created.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Discriminant_Part(Parser *p) {
    if (!Parser_Match(p, TK_LPAREN)) return NULL;

    Source_Location loc = Parser_Location(p);
    Syntax_Node *disc_list = Node_New(NK_BLOCK, loc);  /* Container for discriminants */

    do {
        Source_Location d_loc = Parser_Location(p);
        Syntax_Node *disc = Node_New(NK_DISCRIMINANT_SPEC, d_loc);

        /* Name list */
        do {
            Syntax_Node *id = Node_New(NK_IDENTIFIER, Parser_Location(p));
            id->string_val.text = Parser_Identifier(p);
            Node_List_Push(&disc->discriminant.names, id);
        } while (Parser_Match(p, TK_COMMA));

        Parser_Expect(p, TK_COLON);
        disc->discriminant.disc_type = Parse_Subtype_Indication(p);

        if (Parser_Match(p, TK_ASSIGN)) {
            disc->discriminant.default_expr = Parse_Expression(p);
        }

        Node_List_Push(&disc_list->block_stmt.declarations, disc);
    } while (Parser_Match(p, TK_SEMICOLON));

    Parser_Expect(p, TK_RPAREN);
    return disc_list;
}

static Syntax_Node *Parse_Type_Declaration(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_TYPE);

    Syntax_Node *node = Node_New(NK_TYPE_DECL, loc);
    node->type_decl.name = Parser_Identifier(p);

    /* Discriminant part */
    if (Parser_At(p, TK_LPAREN)) {
        Syntax_Node *discs = Parse_Discriminant_Part(p);
        if (discs) {
            node->type_decl.discriminants = discs->block_stmt.declarations;
        }
    }

    /* Incomplete type declaration */
    if (Parser_Match(p, TK_SEMICOLON)) {
        return node;
    }

    Parser_Expect(p, TK_IS);

    node->type_decl.is_limited = Parser_Match(p, TK_LIMITED);
    node->type_decl.is_private = Parser_Match(p, TK_PRIVATE);

    if (!node->type_decl.is_private) {
        node->type_decl.definition = Parse_Type_Definition(p);
    }

    return node;
}

static Syntax_Node *Parse_Subtype_Declaration(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_SUBTYPE);

    Syntax_Node *node = Node_New(NK_SUBTYPE_DECL, loc);
    node->type_decl.name = Parser_Identifier(p);

    Parser_Expect(p, TK_IS);
    node->type_decl.definition = Parse_Subtype_Indication(p);

    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.12.3 Type Definitions
 *
 * Parsing establishes structure while elaboration establishes meaning.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Enumeration_Type(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_LPAREN);

    Syntax_Node *node = Node_New(NK_ENUMERATION_TYPE, loc);

    do {
        Source_Location lit_loc = Parser_Location(p);
        Syntax_Node *lit = Node_New(NK_IDENTIFIER, lit_loc);

        if (Parser_At(p, TK_IDENTIFIER)) {
            lit->string_val.text = Parser_Identifier(p);
        } else if (Parser_At(p, TK_CHARACTER)) {
            lit->string_val.text = Slice_Duplicate(p->current_token.text);
            Parser_Advance(p);
        } else {
            Parser_Error_At_Current(p, "enumeration literal");
            break;
        }

        Node_List_Push(&node->enum_type.literals, lit);
    } while (Parser_Match(p, TK_COMMA));

    Parser_Expect(p, TK_RPAREN);
    return node;
}

static Syntax_Node *Parse_Discrete_Range(Parser *p);

static Syntax_Node *Parse_Array_Type(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_ARRAY);
    Parser_Expect(p, TK_LPAREN);

    Syntax_Node *node = Node_New(NK_ARRAY_TYPE, loc);

    /* Index types: can be discrete_subtype_indication or discrete_range */
    do {
        Syntax_Node *idx = Parse_Discrete_Range(p);
        Node_List_Push(&node->array_type.indices, idx);
    } while (Parser_Match(p, TK_COMMA));

    /* Determine if constrained based on what we parsed.
     * An index is unconstrained if it's just a type mark (identifier/selected)
     * without a range constraint. A range or subtype_indication with constraint
     * means constrained. */
    node->array_type.is_constrained = true;
    for (size_t i = 0; i < node->array_type.indices.count; i++) {
        Syntax_Node *idx = node->array_type.indices.items[i];
        /* Just a type name without constraint = unconstrained */
        if (idx->kind == NK_IDENTIFIER || idx->kind == NK_SELECTED) {
            node->array_type.is_constrained = false;
            break;
        }
    }

    Parser_Expect(p, TK_RPAREN);
    Parser_Expect(p, TK_OF);
    node->array_type.component_type = Parse_Subtype_Indication(p);

    return node;
}

/* Parse discrete_range: can be subtype_indication or range */
static Syntax_Node *Parse_Discrete_Range(Parser *p) {
    Source_Location loc = Parser_Location(p);

    /* Check if this starts with an integer literal (anonymous range) */
    if (Parser_At(p, TK_INTEGER) || Parser_At(p, TK_CHARACTER)) {
        Syntax_Node *range = Node_New(NK_RANGE, loc);
        range->range.low = Parse_Expression(p);
        if (Parser_Match(p, TK_DOTDOT)) {
            range->range.high = Parse_Expression(p);
        }
        return range;
    }

    /* Otherwise try to parse as name, then check for range or constraint */
    Syntax_Node *name = Parse_Name(p);

    if (Parser_Match(p, TK_RANGE)) {
        /* Type RANGE low..high or Type RANGE <> */
        if (Parser_Match(p, TK_BOX)) {
            /* Unconstrained - return the type mark; <> is consumed */
            return name;
        }
        Syntax_Node *range = Node_New(NK_RANGE, loc);
        range->range.low = Parse_Expression(p);
        Parser_Expect(p, TK_DOTDOT);
        range->range.high = Parse_Expression(p);

        /* Create subtype indication with range constraint */
        Syntax_Node *ind = Node_New(NK_SUBTYPE_INDICATION, loc);
        ind->subtype_ind.subtype_mark = name;
        Syntax_Node *constraint = Node_New(NK_RANGE_CONSTRAINT, loc);
        constraint->range_constraint.range = range;
        ind->subtype_ind.constraint = constraint;
        return ind;
    }

    if (Parser_Match(p, TK_DOTDOT)) {
        /* Name is actually the low bound of a range */
        Syntax_Node *range = Node_New(NK_RANGE, loc);
        range->range.low = name;
        range->range.high = Parse_Expression(p);
        return range;
    }

    /* Just a type name */
    return name;
}

/* Forward declaration for variant part parsing */
static Syntax_Node *Parse_Variant_Part(Parser *p);

static Syntax_Node *Parse_Record_Type(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_RECORD);

    Syntax_Node *node = Node_New(NK_RECORD_TYPE, loc);

    /* NULL; as empty component statement (vs NULL RECORD which is parsed elsewhere) */
    /* Skip this check - NULL inside record body is handled in the loop below */

    /* Component list */
    while (!Parser_At(p, TK_END) && !Parser_At(p, TK_CASE) && !Parser_At(p, TK_EOF)) {
        if (!Parser_Check_Progress(p)) break;

        /* NULL; as empty component list */
        if (Parser_At(p, TK_NULL)) {
            Parser_Advance(p);
            Parser_Expect(p, TK_SEMICOLON);
            continue;
        }

        Source_Location c_loc = Parser_Location(p);
        Syntax_Node *comp = Node_New(NK_COMPONENT_DECL, c_loc);

        /* Component names */
        do {
            Syntax_Node *id = Node_New(NK_IDENTIFIER, Parser_Location(p));
            id->string_val.text = Parser_Identifier(p);
            Node_List_Push(&comp->component.names, id);
        } while (Parser_Match(p, TK_COMMA));

        Parser_Expect(p, TK_COLON);
        comp->component.component_type = Parse_Subtype_Indication(p);

        if (Parser_Match(p, TK_ASSIGN)) {
            comp->component.init = Parse_Expression(p);
        }

        Node_List_Push(&node->record_type.components, comp);
        Parser_Expect(p, TK_SEMICOLON);
    }

    /* Variant part */
    if (Parser_At(p, TK_CASE)) {
        node->record_type.variant_part = Parse_Variant_Part(p);
    }

    Parser_Expect(p, TK_END);
    Parser_Expect(p, TK_RECORD);
    return node;
}

static Syntax_Node *Parse_Variant_Part(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_CASE);

    Syntax_Node *node = Node_New(NK_VARIANT_PART, loc);
    node->variant_part.discriminant = Parser_Identifier(p);
    Parser_Expect(p, TK_IS);

    /* Variants */
    while (Parser_At(p, TK_WHEN)) {
        Source_Location v_loc = Parser_Location(p);
        Parser_Advance(p);

        Syntax_Node *variant = Node_New(NK_VARIANT, v_loc);

        /* Choices - can be expressions, ranges, or OTHERS */
        do {
            Node_List_Push(&variant->variant.choices, Parse_Choice(p));
        } while (Parser_Match(p, TK_BAR));

        Parser_Expect(p, TK_ARROW);

        /* Components in this variant */
        while (!Parser_At(p, TK_WHEN) && !Parser_At(p, TK_END) &&
               !Parser_At(p, TK_CASE) && !Parser_At(p, TK_EOF)) {
            if (!Parser_Check_Progress(p)) break;

            Source_Location c_loc = Parser_Location(p);
            Syntax_Node *comp = Node_New(NK_COMPONENT_DECL, c_loc);

            do {
                Syntax_Node *id = Node_New(NK_IDENTIFIER, Parser_Location(p));
                id->string_val.text = Parser_Identifier(p);
                Node_List_Push(&comp->component.names, id);
            } while (Parser_Match(p, TK_COMMA));

            Parser_Expect(p, TK_COLON);
            comp->component.component_type = Parse_Subtype_Indication(p);

            if (Parser_Match(p, TK_ASSIGN)) {
                comp->component.init = Parse_Expression(p);
            }

            Node_List_Push(&variant->variant.components, comp);
            Parser_Expect(p, TK_SEMICOLON);
        }

        /* Nested variant part */
        if (Parser_At(p, TK_CASE)) {
            variant->variant.variant_part = Parse_Variant_Part(p);
        }

        Node_List_Push(&node->variant_part.variants, variant);
    }

    Parser_Expect(p, TK_END);
    Parser_Expect(p, TK_CASE);
    Parser_Expect(p, TK_SEMICOLON);
    return node;
}

static Syntax_Node *Parse_Access_Type(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_ACCESS);

    Syntax_Node *node = Node_New(NK_ACCESS_TYPE, loc);
    node->access_type.is_constant = Parser_Match(p, TK_CONSTANT);
    node->access_type.designated = Parse_Subtype_Indication(p);
    return node;
}

static Syntax_Node *Parse_Derived_Type(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_NEW);

    Syntax_Node *node = Node_New(NK_DERIVED_TYPE, loc);
    node->derived_type.parent_type = Parse_Subtype_Indication(p);

    if (Parser_At(p, TK_RANGE) || Parser_At(p, TK_LPAREN)) {
        node->derived_type.constraint = Parse_Subtype_Indication(p);
    }

    return node;
}

static Syntax_Node *Parse_Type_Definition(Parser *p) {
    Source_Location loc = Parser_Location(p);

    /* Enumeration type */
    if (Parser_At(p, TK_LPAREN)) {
        return Parse_Enumeration_Type(p);
    }

    /* Array type */
    if (Parser_At(p, TK_ARRAY)) {
        return Parse_Array_Type(p);
    }

    /* Record type: RECORD ... END RECORD or NULL RECORD */
    if (Parser_At(p, TK_RECORD)) {
        return Parse_Record_Type(p);
    }

    /* Null record type: NULL RECORD */
    if (Parser_Match(p, TK_NULL)) {
        Parser_Expect(p, TK_RECORD);
        Syntax_Node *node = Node_New(NK_RECORD_TYPE, loc);
        node->record_type.is_null = true;
        return node;
    }

    /* Access type */
    if (Parser_At(p, TK_ACCESS)) {
        return Parse_Access_Type(p);
    }

    /* Derived type */
    if (Parser_At(p, TK_NEW)) {
        return Parse_Derived_Type(p);
    }

    /* Integer types: range, mod */
    if (Parser_Match(p, TK_RANGE)) {
        Syntax_Node *node = Node_New(NK_INTEGER_TYPE, loc);
        node->integer_type.range = Parse_Range(p);
        return node;
    }

    if (Parser_Match(p, TK_MOD)) {
        Syntax_Node *node = Node_New(NK_INTEGER_TYPE, loc);
        Syntax_Node *mod_expr = Parse_Expression(p);
        /* Store modulus as integer value if constant */
        node->integer_type.modulus = 0;  /* Will be evaluated during semantic analysis */
        node->integer_type.range = mod_expr;
        return node;
    }

    /* Real types: digits, delta */
    if (Parser_Match(p, TK_DIGITS)) {
        Syntax_Node *node = Node_New(NK_REAL_TYPE, loc);
        node->real_type.precision = Parse_Expression(p);
        if (Parser_Match(p, TK_RANGE)) {
            node->real_type.range = Parse_Range(p);
        }
        return node;
    }

    if (Parser_Match(p, TK_DELTA)) {
        Syntax_Node *node = Node_New(NK_REAL_TYPE, loc);
        node->real_type.delta = Parse_Expression(p);
        if (Parser_Match(p, TK_RANGE)) {
            node->real_type.range = Parse_Range(p);
        }
        return node;
    }

    Parser_Error(p, "expected type definition");
    return Node_New(NK_INTEGER_TYPE, loc);
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.13 Subprogram Declarations and Bodies
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * The spec declares the interface while the body provides the implementation.
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §9.13.1 Parameter Specification
 *
 * IN copies in, OUT copies out, IN OUT does both. Access avoids the copy.
 * ───────────────────────────────────────────────────────────────────────── */

static void Parse_Parameter_List(Parser *p, Node_List *params) {
    if (!Parser_Match(p, TK_LPAREN)) return;

    do {
        Source_Location loc = Parser_Location(p);
        Syntax_Node *param = Node_New(NK_PARAM_SPEC, loc);

        /* Identifier list */
        do {
            Syntax_Node *id = Node_New(NK_IDENTIFIER, Parser_Location(p));
            id->string_val.text = Parser_Identifier(p);
            Node_List_Push(&param->param_spec.names, id);
        } while (Parser_Match(p, TK_COMMA));

        Parser_Expect(p, TK_COLON);

        /* Mode */
        if (Parser_Match(p, TK_IN)) {
            if (Parser_Match(p, TK_OUT)) {
                param->param_spec.mode = MODE_IN_OUT;
            } else {
                param->param_spec.mode = MODE_IN;
            }
        } else if (Parser_Match(p, TK_OUT)) {
            param->param_spec.mode = MODE_OUT;
        } else {
            param->param_spec.mode = MODE_IN;  /* Default */
        }

        param->param_spec.param_type = Parse_Subtype_Indication(p);

        /* Default expression */
        if (Parser_Match(p, TK_ASSIGN)) {
            param->param_spec.default_expr = Parse_Expression(p);
        }

        Node_List_Push(params, param);
    } while (Parser_Match(p, TK_SEMICOLON));

    Parser_Expect(p, TK_RPAREN);
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.13.2 Procedure/Function Specification
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Procedure_Specification(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_PROCEDURE);

    Syntax_Node *node = Node_New(NK_PROCEDURE_SPEC, loc);

    /* Name (can be identifier or operator string) */
    if (Parser_At(p, TK_STRING)) {
        node->subprogram_spec.name = Slice_Duplicate(p->current_token.text);
        Parser_Advance(p);
    } else {
        node->subprogram_spec.name = Parser_Identifier(p);
    }

    Parse_Parameter_List(p, &node->subprogram_spec.parameters);
    return node;
}

static Syntax_Node *Parse_Function_Specification(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_FUNCTION);

    Syntax_Node *node = Node_New(NK_FUNCTION_SPEC, loc);

    /* Name */
    if (Parser_At(p, TK_STRING)) {
        node->subprogram_spec.name = Slice_Duplicate(p->current_token.text);
        Parser_Advance(p);
    } else {
        node->subprogram_spec.name = Parser_Identifier(p);
    }

    Parse_Parameter_List(p, &node->subprogram_spec.parameters);

    Parser_Expect(p, TK_RETURN);
    node->subprogram_spec.return_type = Parse_Subtype_Indication(p);

    return node;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §9.13.3 Subprogram Body
 *
 * Declarations, then BEGIN, then statements. The structure is invariant.
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Parse_Subprogram_Body(Parser *p, Syntax_Node *spec) {
    Source_Location loc = spec ? spec->location : Parser_Location(p);
    bool is_function = spec && spec->kind == NK_FUNCTION_SPEC;

    Syntax_Node *node = Node_New(is_function ? NK_FUNCTION_BODY : NK_PROCEDURE_BODY, loc);
    node->subprogram_body.specification = spec;

    Parser_Expect(p, TK_IS);

    /* Check for SEPARATE */
    if (Parser_Match(p, TK_SEPARATE)) {
        node->subprogram_body.is_separate = true;
        return node;
    }

    Parse_Declarative_Part(p, &node->subprogram_body.declarations);

    Parser_Expect(p, TK_BEGIN);
    Parse_Statement_Sequence(p, &node->subprogram_body.statements);

    if (Parser_Match(p, TK_EXCEPTION)) {
        while (Parser_At(p, TK_WHEN)) {
            Source_Location h_loc = Parser_Location(p);
            Parser_Advance(p);

            Syntax_Node *handler = Node_New(NK_EXCEPTION_HANDLER, h_loc);

            do {
                if (Parser_Match(p, TK_OTHERS)) {
                    Node_List_Push(&handler->handler.exceptions, Node_New(NK_OTHERS, h_loc));
                } else {
                    Node_List_Push(&handler->handler.exceptions, Parse_Name(p));
                }
            } while (Parser_Match(p, TK_BAR));

            Parser_Expect(p, TK_ARROW);
            Parse_Statement_Sequence(p, &handler->handler.statements);

            Node_List_Push(&node->subprogram_body.handlers, handler);
        }
    }

    Parser_Expect(p, TK_END);
    if (spec && (Parser_At(p, TK_IDENTIFIER) || Parser_At(p, TK_STRING))) {
        /* Check end name - handle both identifier and operator string */
        Parser_Check_End_Name(p, spec->subprogram_spec.name);
    }

    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.14 Package Declarations and Bodies
 * ═══════════════════════════════════════════════════════════════════════════
 */

static Syntax_Node *Parse_Package_Specification(Parser *p) {
    /* Note: caller must consume TK_PACKAGE before calling */
    Source_Location loc = Parser_Location(p);

    Syntax_Node *node = Node_New(NK_PACKAGE_SPEC, loc);
    node->package_spec.name = Parser_Identifier(p);

    Parser_Expect(p, TK_IS);

    /* Visible declarations */
    Parse_Declarative_Part(p, &node->package_spec.visible_decls);

    /* Private part */
    if (Parser_Match(p, TK_PRIVATE)) {
        Parse_Declarative_Part(p, &node->package_spec.private_decls);
    }

    Parser_Expect(p, TK_END);
    if (Parser_At(p, TK_IDENTIFIER)) {
        Parser_Check_End_Name(p, node->package_spec.name);
    }

    return node;
}

static Syntax_Node *Parse_Package_Body(Parser *p) {
    /* Note: caller must consume TK_PACKAGE and TK_BODY before calling */
    Source_Location loc = Parser_Location(p);

    Syntax_Node *node = Node_New(NK_PACKAGE_BODY, loc);
    node->package_body.name = Parser_Identifier(p);

    Parser_Expect(p, TK_IS);

    /* Check for SEPARATE */
    if (Parser_Match(p, TK_SEPARATE)) {
        node->package_body.is_separate = true;
        return node;
    }

    Parse_Declarative_Part(p, &node->package_body.declarations);

    if (Parser_Match(p, TK_BEGIN)) {
        Parse_Statement_Sequence(p, &node->package_body.statements);

        if (Parser_Match(p, TK_EXCEPTION)) {
            while (Parser_At(p, TK_WHEN)) {
                Source_Location h_loc = Parser_Location(p);
                Parser_Advance(p);

                Syntax_Node *handler = Node_New(NK_EXCEPTION_HANDLER, h_loc);

                do {
                    if (Parser_Match(p, TK_OTHERS)) {
                        Node_List_Push(&handler->handler.exceptions, Node_New(NK_OTHERS, h_loc));
                    } else {
                        Node_List_Push(&handler->handler.exceptions, Parse_Name(p));
                    }
                } while (Parser_Match(p, TK_BAR));

                Parser_Expect(p, TK_ARROW);
                Parse_Statement_Sequence(p, &handler->handler.statements);

                Node_List_Push(&node->package_body.handlers, handler);
            }
        }
    }

    Parser_Expect(p, TK_END);
    if (Parser_At(p, TK_IDENTIFIER)) {
        Parser_Check_End_Name(p, node->package_body.name);
    }

    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.15 Generic Units
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Generics are templates where instantiation means substitution with type checking.
 */

static void Parse_Generic_Formal_Part(Parser *p, Node_List *formals) {
    while (!Parser_At(p, TK_PROCEDURE) && !Parser_At(p, TK_FUNCTION) &&
           !Parser_At(p, TK_PACKAGE) && !Parser_At(p, TK_EOF)) {

        if (!Parser_Check_Progress(p)) break;

        Source_Location loc = Parser_Location(p);

        /* Generic type formal: type T[(discriminants)] is private | type T is (<>) | etc */
        if (Parser_Match(p, TK_TYPE)) {
            Syntax_Node *formal = Node_New(NK_GENERIC_TYPE_PARAM, loc);

            /* Parse type name */
            formal->generic_type_param.name = Parser_Identifier(p);

            /* Parse optional discriminant part: (discriminant_spec {; discriminant_spec}) */
            if (Parser_Match(p, TK_LPAREN)) {
                /* Skip discriminant specifications until closing paren */
                int depth = 1;
                while (depth > 0 && !Parser_At(p, TK_EOF)) {
                    if (Parser_At(p, TK_LPAREN)) depth++;
                    else if (Parser_At(p, TK_RPAREN)) depth--;
                    if (depth > 0) Parser_Advance(p);
                }
                Parser_Expect(p, TK_RPAREN);
            }

            Parser_Expect(p, TK_IS);

            /* Parse type definition form */
            if (Parser_Match(p, TK_LIMITED)) {
                Parser_Expect(p, TK_PRIVATE);
                formal->generic_type_param.def_kind = 1;  /* LIMITED_PRIVATE */
            } else if (Parser_Match(p, TK_PRIVATE)) {
                formal->generic_type_param.def_kind = 0;  /* PRIVATE */
            } else if (Parser_Match(p, TK_LPAREN)) {
                /* (<>) for discrete types */
                Parser_Expect(p, TK_BOX);
                Parser_Expect(p, TK_RPAREN);
                formal->generic_type_param.def_kind = 2;  /* DISCRETE */
            } else if (Parser_Match(p, TK_RANGE)) {
                /* range <> for integer types */
                Parser_Expect(p, TK_BOX);
                formal->generic_type_param.def_kind = 3;  /* INTEGER */
            } else if (Parser_Match(p, TK_DIGITS)) {
                /* digits <> for float types */
                Parser_Expect(p, TK_BOX);
                formal->generic_type_param.def_kind = 4;  /* FLOAT */
            } else if (Parser_Match(p, TK_DELTA)) {
                /* delta <> for fixed types */
                Parser_Expect(p, TK_BOX);
                formal->generic_type_param.def_kind = 5;  /* FIXED */
            } else if (Parser_Match(p, TK_ARRAY)) {
                /* array (index {, index}) of element_type for array types */
                formal->generic_type_param.def_kind = 6;  /* ARRAY */
                Parser_Expect(p, TK_LPAREN);
                /* Parse index subtypes: subtype_mark RANGE <> */
                do {
                    Parse_Name(p);  /* index subtype mark */
                    Parser_Expect(p, TK_RANGE);
                    Parser_Expect(p, TK_BOX);  /* <> */
                } while (Parser_Match(p, TK_COMMA));
                Parser_Expect(p, TK_RPAREN);
                Parser_Expect(p, TK_OF);
                formal->generic_type_param.def_detail = Parse_Subtype_Indication(p);
            } else if (Parser_Match(p, TK_ACCESS)) {
                /* access type_name for access types */
                formal->generic_type_param.def_kind = 7;  /* ACCESS */
                formal->generic_type_param.def_detail = Parse_Subtype_Indication(p);
            } else if (Parser_At(p, TK_NEW)) {
                /* new parent_type for derived types - skip NEW, parse parent */
                Parser_Advance(p);
                formal->generic_type_param.def_kind = 8;  /* DERIVED */
                formal->generic_type_param.def_detail = Parse_Subtype_Indication(p);
            } else {
                /* Unknown form - error recovery: skip to semicolon */
                formal->generic_type_param.def_kind = 0;
                while (!Parser_At(p, TK_SEMICOLON) && !Parser_At(p, TK_EOF)) {
                    Parser_Advance(p);
                }
            }

            Node_List_Push(formals, formal);
            Parser_Expect(p, TK_SEMICOLON);
            continue;
        }

        /* Generic object formal: identifier_list : [mode] type [:= default] */
        if (Parser_At(p, TK_IDENTIFIER)) {
            Syntax_Node *formal = Node_New(NK_GENERIC_OBJECT_PARAM, loc);

            /* Parse identifier list */
            do {
                Syntax_Node *id = Node_New(NK_IDENTIFIER, Parser_Location(p));
                id->string_val.text = Parser_Identifier(p);
                Node_List_Push(&formal->generic_object_param.names, id);
            } while (Parser_Match(p, TK_COMMA));

            Parser_Expect(p, TK_COLON);

            /* Parse mode: IN (default), OUT, or IN OUT */
            formal->generic_object_param.mode = 0;  /* Default: IN */
            if (Parser_Match(p, TK_IN)) {
                if (Parser_Match(p, TK_OUT)) {
                    formal->generic_object_param.mode = 2;  /* IN OUT */
                } else {
                    formal->generic_object_param.mode = 0;  /* IN */
                }
            } else if (Parser_Match(p, TK_OUT)) {
                formal->generic_object_param.mode = 1;  /* OUT */
            }

            /* Parse subtype mark */
            formal->generic_object_param.object_type = Parse_Subtype_Indication(p);

            /* Parse optional default expression */
            if (Parser_Match(p, TK_ASSIGN)) {
                formal->generic_object_param.default_expr = Parse_Expression(p);
            }

            Node_List_Push(formals, formal);
            Parser_Expect(p, TK_SEMICOLON);
            continue;
        }

        /* Generic subprogram formal: WITH PROCEDURE/FUNCTION spec [IS name | IS <>] */
        if (Parser_At(p, TK_WITH)) {
            Parser_Advance(p);  /* consume WITH */
            Syntax_Node *formal = Node_New(NK_GENERIC_SUBPROGRAM_PARAM, loc);

            if (Parser_Match(p, TK_PROCEDURE)) {
                formal->generic_subprog_param.is_function = false;
                formal->generic_subprog_param.name = Parser_Identifier(p);

                /* Optional parameters */
                if (Parser_At(p, TK_LPAREN)) {
                    Parse_Parameter_List(p, &formal->generic_subprog_param.parameters);
                }
            } else if (Parser_Match(p, TK_FUNCTION)) {
                formal->generic_subprog_param.is_function = true;

                /* Function name - can be identifier or operator string */
                if (Parser_At(p, TK_STRING)) {
                    formal->generic_subprog_param.name = Slice_Duplicate(p->current_token.text);
                    Parser_Advance(p);
                } else {
                    formal->generic_subprog_param.name = Parser_Identifier(p);
                }

                /* Optional parameters */
                if (Parser_At(p, TK_LPAREN)) {
                    Parse_Parameter_List(p, &formal->generic_subprog_param.parameters);
                }

                /* Return type */
                Parser_Expect(p, TK_RETURN);
                formal->generic_subprog_param.return_type = Parse_Name(p);
            }

            /* Optional default: IS name | IS <> */
            if (Parser_Match(p, TK_IS)) {
                if (Parser_Match(p, TK_BOX)) {
                    /* IS <> means any matching subprogram */
                    formal->generic_subprog_param.default_box = true;
                } else {
                    /* IS name means default to that subprogram */
                    formal->generic_subprog_param.default_name = Parse_Name(p);
                }
            }

            Node_List_Push(formals, formal);
            Parser_Expect(p, TK_SEMICOLON);
            continue;
        }

        break;
    }
}

static Syntax_Node *Parse_Generic_Declaration(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_GENERIC);

    Syntax_Node *node = Node_New(NK_GENERIC_DECL, loc);
    Parse_Generic_Formal_Part(p, &node->generic_decl.formals);

    /* The actual unit */
    if (Parser_At(p, TK_PROCEDURE)) {
        node->generic_decl.unit = Parse_Procedure_Specification(p);
    } else if (Parser_At(p, TK_FUNCTION)) {
        node->generic_decl.unit = Parse_Function_Specification(p);
    } else if (Parser_At(p, TK_PACKAGE)) {
        Parser_Advance(p);  /* consume PACKAGE */
        node->generic_decl.unit = Parse_Package_Specification(p);
    }

    return node;
}

__attribute__((unused))
static Syntax_Node *Parse_Generic_Instantiation(Parser *p, Token_Kind unit_kind) {
    Source_Location loc = Parser_Location(p);
    Parser_Advance(p);  /* consume PROCEDURE/FUNCTION/PACKAGE */

    Syntax_Node *node = Node_New(NK_GENERIC_INST, loc);
    node->generic_inst.unit_kind = unit_kind;
    node->generic_inst.instance_name = Parser_Identifier(p);

    Parser_Expect(p, TK_IS);
    Parser_Expect(p, TK_NEW);

    node->generic_inst.generic_name = Parse_Name(p);

    /* Generic actuals */
    if (Parser_Match(p, TK_LPAREN)) {
        Parse_Association_List(p, &node->generic_inst.actuals);
        Parser_Expect(p, TK_RPAREN);
    }

    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.16 Use and With Clauses
 * ═══════════════════════════════════════════════════════════════════════════
 */

static Syntax_Node *Parse_Use_Clause(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_USE);

    Syntax_Node *node = Node_New(NK_USE_CLAUSE, loc);

    do {
        Node_List_Push(&node->use_clause.names, Parse_Name(p));
    } while (Parser_Match(p, TK_COMMA));

    return node;
}

static Syntax_Node *Parse_With_Clause(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_WITH);

    Syntax_Node *node = Node_New(NK_WITH_CLAUSE, loc);

    do {
        Node_List_Push(&node->use_clause.names, Parse_Name(p));
    } while (Parser_Match(p, TK_COMMA));

    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.17 Pragmas
 * ═══════════════════════════════════════════════════════════════════════════
 */

static Syntax_Node *Parse_Pragma(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_PRAGMA);

    Syntax_Node *node = Node_New(NK_PRAGMA, loc);
    node->pragma_node.name = Parser_Identifier(p);

    if (Parser_Match(p, TK_LPAREN)) {
        Parse_Association_List(p, &node->pragma_node.arguments);
        Parser_Expect(p, TK_RPAREN);
    }

    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.18 Exception Declaration
 * ═══════════════════════════════════════════════════════════════════════════
 */

__attribute__((unused))
static Syntax_Node *Parse_Exception_Declaration(Parser *p) {
    Source_Location loc = Parser_Location(p);

    Syntax_Node *node = Node_New(NK_EXCEPTION_DECL, loc);

    do {
        Syntax_Node *id = Node_New(NK_IDENTIFIER, Parser_Location(p));
        id->string_val.text = Parser_Identifier(p);
        Node_List_Push(&node->exception_decl.names, id);
    } while (Parser_Match(p, TK_COMMA));

    Parser_Expect(p, TK_COLON);
    Parser_Expect(p, TK_EXCEPTION);

    /* Renames */
    if (Parser_Match(p, TK_RENAMES)) {
        node->kind = NK_EXCEPTION_RENAMING;
        /* Parse renamed exception name */
        node->exception_decl.renamed = Parse_Name(p);
    }

    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.19 Representation Clauses
 * ═══════════════════════════════════════════════════════════════════════════
 */

static Syntax_Node *Parse_Representation_Clause(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Parser_Expect(p, TK_FOR);

    Syntax_Node *node = Node_New(NK_REPRESENTATION_CLAUSE, loc);

    /* Parse: FOR entity_name'attribute USE expression;
     *    or: FOR type_name USE RECORD ... END RECORD;
     *    or: FOR type_name USE (enum_rep_list);
     *    or: FOR object_name USE AT address; */

    /* Parse entity name (possibly qualified: T or T'ATTRIBUTE) */
    node->rep_clause.entity_name = Parse_Name(p);

    /* Check if this is an attribute clause: FOR T'SIZE USE 32; */
    if (Parser_At(p, TK_TICK)) {
        Parser_Advance(p);  /* consume tick */
        if (Parser_At(p, TK_IDENTIFIER)) {
            node->rep_clause.attribute = p->current_token.text;
            Parser_Advance(p);  /* consume attribute name */
        }
    }

    Parser_Expect(p, TK_USE);

    /* Check for different representation clause forms */
    if (Parser_Match(p, TK_RECORD)) {
        /* Record representation clause: FOR T USE RECORD ... END RECORD; */
        node->rep_clause.is_record_rep = true;

        /* Parse optional alignment: AT MOD alignment; */
        if (Parser_Match(p, TK_AT)) {
            Parser_Expect(p, TK_MOD);
            node->rep_clause.expression = Parse_Expression(p);
            Parser_Expect(p, TK_SEMICOLON);
        }

        /* Parse component clauses: component_name AT position RANGE first_bit..last_bit; */
        while (!Parser_At(p, TK_END) && !Parser_At(p, TK_EOF)) {
            Syntax_Node *comp_clause = Node_New(NK_ASSOCIATION, Parser_Location(p));
            Node_List_Push(&comp_clause->association.choices, Parse_Name(p));
            Parser_Expect(p, TK_AT);
            comp_clause->association.expression = Parse_Expression(p);
            /* Optional RANGE clause */
            if (Parser_Match(p, TK_RANGE)) {
                /* bit_range is now part of the expression */
                Parse_Range(p);  /* first_bit .. last_bit */
            }
            Parser_Expect(p, TK_SEMICOLON);
            Node_List_Push(&node->rep_clause.component_clauses, comp_clause);
        }
        Parser_Expect(p, TK_END);
        Parser_Expect(p, TK_RECORD);
    } else if (Parser_At(p, TK_LPAREN)) {
        /* Enumeration representation: FOR T USE (A => 0, B => 1, ...); */
        node->rep_clause.is_enum_rep = true;
        Parser_Advance(p);  /* consume ( */
        Parse_Association_List(p, &node->rep_clause.component_clauses);
        Parser_Expect(p, TK_RPAREN);
    } else if (Parser_Match(p, TK_AT)) {
        /* Address clause: FOR X USE AT address; */
        node->rep_clause.expression = Parse_Expression(p);
    } else {
        /* Attribute value: FOR T'SIZE USE 32; */
        node->rep_clause.expression = Parse_Expression(p);
    }

    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.20 Declaration Dispatch
 * ═══════════════════════════════════════════════════════════════════════════
 */

static Syntax_Node *Parse_Declaration(Parser *p) {
    Source_Location loc = Parser_Location(p);

    /* Generic */
    if (Parser_At(p, TK_GENERIC)) {
        Syntax_Node *generic = Parse_Generic_Declaration(p);
        Parser_Expect(p, TK_SEMICOLON);
        return generic;
    }

    /* Procedure/Function - could be spec, body, or generic instantiation */
    if (Parser_At(p, TK_PROCEDURE) || Parser_At(p, TK_FUNCTION)) {
        Token_Kind kind = p->current_token.kind;
        Parser_Advance(p);  /* consume PROCEDURE/FUNCTION */

        /* Get the name - can be identifier or operator string for functions */
        String_Slice name;
        if (Parser_At(p, TK_STRING)) {
            name = Slice_Duplicate(p->current_token.text);
            Parser_Advance(p);
        } else {
            name = Parser_Identifier(p);
        }

        /* Check for generic instantiation: NAME IS NEW */
        if (Parser_At(p, TK_IS)) {
            /* Peek ahead to see if it's IS NEW */
            Token saved = p->current_token;
            Lexer saved_lexer = p->lexer;
            Parser_Advance(p);  /* consume IS */

            if (Parser_At(p, TK_NEW)) {
                Parser_Advance(p);  /* consume NEW */

                /* Create generic instantiation node */
                Syntax_Node *node = Node_New(NK_GENERIC_INST, loc);
                node->generic_inst.unit_kind = kind;
                node->generic_inst.instance_name = name;

                /* Parse the generic unit name */
                node->generic_inst.generic_name = Parse_Simple_Name(p);

                /* Generic actuals */
                if (Parser_Match(p, TK_LPAREN)) {
                    Parse_Association_List(p, &node->generic_inst.actuals);
                    Parser_Expect(p, TK_RPAREN);
                }

                Parser_Expect(p, TK_SEMICOLON);
                return node;
            }

            /* Not IS NEW - restore and parse as spec/body */
            p->current_token = saved;
            p->lexer = saved_lexer;
        }

        /* Parse parameters (if any) - Parse_Parameter_List handles the parens */
        Node_List params = {0};
        if (Parser_At(p, TK_LPAREN)) {
            Parse_Parameter_List(p, &params);
        }

        /* Create the spec node */
        Syntax_Node *spec = Node_New(kind == TK_PROCEDURE ? NK_PROCEDURE_SPEC : NK_FUNCTION_SPEC, loc);
        spec->subprogram_spec.name = name;
        spec->subprogram_spec.parameters = params;

        /* For functions, parse return type */
        if (kind == TK_FUNCTION) {
            Parser_Expect(p, TK_RETURN);
            spec->subprogram_spec.return_type = Parse_Name(p);
        }

        /* Check for subprogram renaming: PROCEDURE P RENAMES Q; or FUNCTION F RENAMES G; */
        if (Parser_Match(p, TK_RENAMES)) {
            spec->kind = NK_SUBPROGRAM_RENAMING;
            spec->subprogram_spec.renamed = Parse_Name(p);
            Parser_Expect(p, TK_SEMICOLON);
            return spec;
        }

        /* Check for body or just spec */
        if (Parser_At(p, TK_IS)) {
            Syntax_Node *body = Parse_Subprogram_Body(p, spec);
            Parser_Expect(p, TK_SEMICOLON);
            return body;
        }

        /* Just a specification */
        Parser_Expect(p, TK_SEMICOLON);
        return spec;
    }

    /* Package */
    if (Parser_At(p, TK_PACKAGE)) {
        Parser_Advance(p);  /* consume PACKAGE */
        if (Parser_At(p, TK_BODY)) {
            Parser_Advance(p);  /* consume BODY */
            Syntax_Node *body = Parse_Package_Body(p);
            Parser_Expect(p, TK_SEMICOLON);
            return body;
        }
        /* Check for package renaming: PACKAGE name RENAMES old_name; */
        String_Slice pkg_name = Parser_Identifier(p);
        if (Parser_Match(p, TK_RENAMES)) {
            Syntax_Node *node = Node_New(NK_PACKAGE_RENAMING, loc);
            node->package_renaming.new_name = pkg_name;
            node->package_renaming.old_name = Parse_Name(p);
            Parser_Expect(p, TK_SEMICOLON);
            return node;
        }

        Parser_Expect(p, TK_IS);

        /* Check for generic instantiation: PACKAGE name IS NEW generic_name */
        if (Parser_Match(p, TK_NEW)) {
            Syntax_Node *node = Node_New(NK_GENERIC_INST, loc);
            node->generic_inst.unit_kind = TK_PACKAGE;
            node->generic_inst.instance_name = pkg_name;

            /* Parse the generic unit name */
            node->generic_inst.generic_name = Parse_Simple_Name(p);

            /* Generic actuals */
            if (Parser_Match(p, TK_LPAREN)) {
                Parse_Association_List(p, &node->generic_inst.actuals);
                Parser_Expect(p, TK_RPAREN);
            }

            Parser_Expect(p, TK_SEMICOLON);
            return node;
        }

        /* Not a generic instantiation - parse as specification */
        Syntax_Node *spec = Node_New(NK_PACKAGE_SPEC, loc);
        spec->package_spec.name = pkg_name;
        /* Parse visible declarations (each declaration consumes its own semicolon) */
        while (!Parser_At(p, TK_PRIVATE) && !Parser_At(p, TK_END) && !Parser_At(p, TK_EOF)) {
            if (!Parser_Check_Progress(p)) break;
            Syntax_Node *decl = Parse_Declaration(p);
            Node_List_Push(&spec->package_spec.visible_decls, decl);
        }
        /* Parse private declarations */
        if (Parser_Match(p, TK_PRIVATE)) {
            while (!Parser_At(p, TK_END) && !Parser_At(p, TK_EOF)) {
                if (!Parser_Check_Progress(p)) break;
                Syntax_Node *decl = Parse_Declaration(p);
                Node_List_Push(&spec->package_spec.private_decls, decl);
            }
        }
        Parser_Expect(p, TK_END);
        if (Parser_At(p, TK_IDENTIFIER)) {
            Parser_Check_End_Name(p, spec->package_spec.name);
        }
        Parser_Expect(p, TK_SEMICOLON);
        return spec;
    }

    /* Task declaration */
    if (Parser_At(p, TK_TASK)) {
        Parser_Advance(p);  /* consume TASK */

        /* TASK BODY name IS ... */
        if (Parser_At(p, TK_BODY)) {
            Parser_Advance(p);  /* consume BODY */
            Source_Location t_loc = Parser_Location(p);
            Syntax_Node *node = Node_New(NK_TASK_BODY, t_loc);
            node->task_body.name = Parser_Identifier(p);
            Parser_Expect(p, TK_IS);

            if (Parser_Match(p, TK_SEPARATE)) {
                node->task_body.is_separate = true;
                Parser_Expect(p, TK_SEMICOLON);
                return node;
            }

            Parse_Declarative_Part(p, &node->task_body.declarations);
            Parser_Expect(p, TK_BEGIN);
            Parse_Statement_Sequence(p, &node->task_body.statements);

            if (Parser_Match(p, TK_EXCEPTION)) {
                while (Parser_At(p, TK_WHEN)) {
                    Source_Location h_loc = Parser_Location(p);
                    Parser_Advance(p);

                    Syntax_Node *handler = Node_New(NK_EXCEPTION_HANDLER, h_loc);
                    do {
                        if (Parser_Match(p, TK_OTHERS)) {
                            Node_List_Push(&handler->handler.exceptions, Node_New(NK_OTHERS, h_loc));
                        } else {
                            Node_List_Push(&handler->handler.exceptions, Parse_Name(p));
                        }
                    } while (Parser_Match(p, TK_BAR));

                    Parser_Expect(p, TK_ARROW);
                    Parse_Statement_Sequence(p, &handler->handler.statements);
                    Node_List_Push(&node->task_body.handlers, handler);
                }
            }

            Parser_Expect(p, TK_END);
            if (Parser_At(p, TK_IDENTIFIER)) {
                Parser_Check_End_Name(p, node->task_body.name);
            }
            Parser_Expect(p, TK_SEMICOLON);
            return node;
        }

        /* TASK [TYPE] name [IS ... END name]; */
        bool is_type = Parser_Match(p, TK_TYPE);
        Source_Location t_loc = Parser_Location(p);
        Syntax_Node *node = Node_New(NK_TASK_SPEC, t_loc);
        node->task_spec.name = Parser_Identifier(p);
        node->task_spec.is_type = is_type;

        if (Parser_Match(p, TK_IS)) {
            /* Task spec with entries */
            while (!Parser_At(p, TK_END) && !Parser_At(p, TK_EOF)) {
                if (!Parser_Check_Progress(p)) break;

                if (Parser_Match(p, TK_ENTRY)) {
                    Source_Location e_loc = Parser_Location(p);
                    Syntax_Node *entry = Node_New(NK_ENTRY_DECL, e_loc);
                    entry->entry_decl.name = Parser_Identifier(p);

                    /* Entry may have family index: ENTRY name(index)
                     * and/or parameters: ENTRY name(...) or ENTRY name(index)(...)
                     * Family index is a discrete_subtype_definition (like 1..10)
                     * Parameters start with identifier : mode type */
                    if (Parser_At(p, TK_LPAREN)) {
                        /* Check if this is an entry family index or parameter list
                         * Entry family: (discrete_range) like (1..10) or (T'RANGE)
                         * Parameters: (id : mode type) - starts with identifier followed by : */
                        Token saved = p->current_token;
                        Lexer saved_lexer = p->lexer;
                        Parser_Advance(p);  /* consume ( for lookahead */

                        bool is_family_index = false;
                        if (!Parser_At(p, TK_IDENTIFIER)) {
                            /* Not starting with identifier - must be family index */
                            is_family_index = true;
                        } else {
                            /* Look ahead to see if it's id : (parameter) or just id (family) */
                            Token saved2 = p->current_token;
                            Lexer saved_lexer2 = p->lexer;
                            Parser_Advance(p);  /* past identifier */
                            is_family_index = !Parser_At(p, TK_COLON) && !Parser_At(p, TK_COMMA);
                            p->current_token = saved2;
                            p->lexer = saved_lexer2;
                        }

                        if (is_family_index) {
                            /* Parse discrete subtype definition - already past ( */
                            Syntax_Node *range = Parse_Range(p);
                            Node_List_Push(&entry->entry_decl.index_constraints, range);
                            Parser_Expect(p, TK_RPAREN);

                            /* Optionally parse parameters after family index */
                            if (Parser_At(p, TK_LPAREN)) {
                                Parse_Parameter_List(p, &entry->entry_decl.parameters);
                            }
                        } else {
                            /* Restore and use Parse_Parameter_List which handles ( ) */
                            p->current_token = saved;
                            p->lexer = saved_lexer;
                            Parse_Parameter_List(p, &entry->entry_decl.parameters);
                        }
                    }
                    Parser_Expect(p, TK_SEMICOLON);
                    Node_List_Push(&node->task_spec.entries, entry);
                } else if (Parser_At(p, TK_PRAGMA)) {
                    Node_List_Push(&node->task_spec.entries, Parse_Pragma(p));
                    Parser_Expect(p, TK_SEMICOLON);
                } else if (Parser_At(p, TK_FOR)) {
                    /* Representation clause in task spec */
                    Node_List_Push(&node->task_spec.entries, Parse_Representation_Clause(p));
                    Parser_Expect(p, TK_SEMICOLON);
                } else {
                    Parser_Error(p, "expected ENTRY, PRAGMA, FOR, or END in task spec");
                    Parser_Advance(p);
                }
            }
            Parser_Expect(p, TK_END);
            if (Parser_At(p, TK_IDENTIFIER)) {
                Parser_Check_End_Name(p, node->task_spec.name);
            }
        }

        Parser_Expect(p, TK_SEMICOLON);
        return node;
    }

    /* Type declaration */
    if (Parser_At(p, TK_TYPE)) {
        Syntax_Node *type_decl = Parse_Type_Declaration(p);
        /* Incomplete type declaration (no definition, not private/limited) already consumed semicolon */
        if (type_decl->type_decl.definition || type_decl->type_decl.is_private ||
            type_decl->type_decl.is_limited) {
            Parser_Expect(p, TK_SEMICOLON);
        }
        return type_decl;
    }

    /* Subtype declaration */
    if (Parser_At(p, TK_SUBTYPE)) {
        Syntax_Node *subtype = Parse_Subtype_Declaration(p);
        Parser_Expect(p, TK_SEMICOLON);
        return subtype;
    }

    /* Use clause */
    if (Parser_At(p, TK_USE)) {
        Syntax_Node *use = Parse_Use_Clause(p);
        Parser_Expect(p, TK_SEMICOLON);
        return use;
    }

    /* Pragma */
    if (Parser_At(p, TK_PRAGMA)) {
        Syntax_Node *pragma = Parse_Pragma(p);
        Parser_Expect(p, TK_SEMICOLON);
        return pragma;
    }

    /* FOR representation clause */
    if (Parser_At(p, TK_FOR)) {
        Syntax_Node *rep = Parse_Representation_Clause(p);
        Parser_Expect(p, TK_SEMICOLON);
        return rep;
    }

    /* Object or exception declaration */
    if (Parser_At(p, TK_IDENTIFIER)) {
        Syntax_Node *obj = Parse_Object_Declaration(p);
        Parser_Expect(p, TK_SEMICOLON);
        return obj;
    }

    Parser_Error(p, "expected declaration");
    Parser_Synchronize(p);
    return Node_New(NK_NULL_STMT, loc);
}

static void Parse_Declarative_Part(Parser *p, Node_List *list) {
    while (!Parser_At(p, TK_BEGIN) && !Parser_At(p, TK_END) &&
           !Parser_At(p, TK_PRIVATE) && !Parser_At(p, TK_EOF)) {

        if (!Parser_Check_Progress(p)) break;

        Syntax_Node *decl = Parse_Declaration(p);
        Node_List_Push(list, decl);
        /* Each declaration now consumes its own trailing semicolon */
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §9.21 Compilation Unit
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * WITH establishes dependencies while USE imports names into the current namespace.
 */

static Syntax_Node *Parse_Context_Clause(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Syntax_Node *node = Node_New(NK_CONTEXT_CLAUSE, loc);

    while (Parser_At(p, TK_WITH) || Parser_At(p, TK_USE) || Parser_At(p, TK_PRAGMA)) {
        if (Parser_At(p, TK_WITH)) {
            Node_List_Push(&node->context.with_clauses, Parse_With_Clause(p));
            Parser_Expect(p, TK_SEMICOLON);
        } else if (Parser_At(p, TK_USE)) {
            Node_List_Push(&node->context.use_clauses, Parse_Use_Clause(p));
            Parser_Expect(p, TK_SEMICOLON);
        } else if (Parser_At(p, TK_PRAGMA)) {
            Parse_Pragma(p);  /* Configuration pragmas */
            Parser_Expect(p, TK_SEMICOLON);
        }
    }

    return node;
}

static Syntax_Node *Parse_Compilation_Unit(Parser *p) {
    Source_Location loc = Parser_Location(p);
    Syntax_Node *node = Node_New(NK_COMPILATION_UNIT, loc);

    node->compilation_unit.context = Parse_Context_Clause(p);

    /* Handle trailing pragmas at end of file (no more library units) */
    if (Parser_At(p, TK_EOF)) {
        node->compilation_unit.unit = NULL;
        return node;
    }

    /* Separate unit */
    if (Parser_Match(p, TK_SEPARATE)) {
        Parser_Expect(p, TK_LPAREN);
        node->compilation_unit.separate_parent = Parse_Name(p);
        Parser_Expect(p, TK_RPAREN);
        /* Parse the actual subunit below */
    }

    /* Main unit - Parse_Declaration now consumes its trailing semicolon */
    node->compilation_unit.unit = Parse_Declaration(p);

    return node;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §10. TYPE SYSTEM — Ada Type Semantics
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * A type combines name, range, and representation as three orthogonal concerns.
 *
 * INVARIANT: All sizes are stored in BYTES, not bits.
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §10.1 Type Kinds
 * ───────────────────────────────────────────────────────────────────────── */

typedef enum {
    TYPE_UNKNOWN = 0,

    /* Scalar types */
    TYPE_BOOLEAN,
    TYPE_CHARACTER,
    TYPE_INTEGER,
    TYPE_MODULAR,
    TYPE_ENUMERATION,
    TYPE_FLOAT,
    TYPE_FIXED,

    /* Composite types */
    TYPE_ARRAY,
    TYPE_RECORD,
    TYPE_STRING,      /* Special case of array */

    /* Access types */
    TYPE_ACCESS,

    /* Special types */
    TYPE_UNIVERSAL_INTEGER,
    TYPE_UNIVERSAL_REAL,
    TYPE_TASK,
    TYPE_SUBPROGRAM,  /* For formal subprogram parameters */
    TYPE_PRIVATE,
    TYPE_LIMITED_PRIVATE,
    TYPE_INCOMPLETE,
    TYPE_PACKAGE,     /* For package namespaces */

    TYPE_COUNT
} Type_Kind;

/* ─────────────────────────────────────────────────────────────────────────
 * §10.2 Type Information Structure
 *
 * Each type has:
 * - Kind and name
 * - Size and alignment (in BYTES)
 * - Bounds for scalars
 * - Component info for composites
 * ───────────────────────────────────────────────────────────────────────── */

typedef struct Type_Info Type_Info;
typedef struct Symbol Symbol;

/* Bound representation: explicit tagged union to avoid bitcast */
typedef struct {
    enum { BOUND_INTEGER, BOUND_FLOAT, BOUND_EXPR } kind;
    union {
        int64_t      int_value;
        double       float_value;
        Syntax_Node *expr;
    };
} Type_Bound;

/* Component information for records */
typedef struct {
    String_Slice  name;
    Type_Info    *component_type;
    uint32_t      byte_offset;
    uint32_t      bit_offset;    /* For representation clauses */
    uint32_t      bit_size;
} Component_Info;

/* Index information for arrays */
typedef struct {
    Type_Info *index_type;
    Type_Bound low_bound;
    Type_Bound high_bound;
} Index_Info;

struct Type_Info {
    Type_Kind    kind;
    String_Slice name;
    Symbol      *defining_symbol;

    /* Size and alignment in BYTES (not bits!) */
    uint32_t     size;
    uint32_t     alignment;

    /* Scalar bounds */
    Type_Bound   low_bound;
    Type_Bound   high_bound;
    int64_t      modulus;        /* For modular types */

    /* Base/parent type for subtypes and derived types */
    Type_Info   *base_type;
    Type_Info   *parent_type;    /* For derived types */

    /* Composite type info */
    union {
        struct {  /* TYPE_ARRAY */
            Index_Info *indices;
            uint32_t    index_count;
            Type_Info  *element_type;
            bool        is_constrained;
        } array;

        struct {  /* TYPE_RECORD */
            Component_Info *components;
            uint32_t        component_count;
            /* Discriminant info would go here */
        } record;

        struct {  /* TYPE_ACCESS */
            Type_Info *designated_type;
            bool       is_access_constant;
        } access;

        struct {  /* TYPE_ENUMERATION */
            String_Slice *literals;
            uint32_t      literal_count;
            int64_t      *rep_values;    /* Optional representation clause values */
        } enumeration;

        struct {  /* TYPE_FIXED */
            double delta;   /* User-specified delta (smallest increment) */
            double small;   /* Implementation small: power of 2 <= delta */
            int    scale;   /* Scale factor: value = mantissa * 2^scale */
        } fixed;
    };

    /* Runtime check suppression */
    uint32_t     suppressed_checks;

    /* Pragma Pack - pack components to minimum size */
    bool         is_packed;

    /* Freezing status - once frozen, representation cannot change */
    bool         is_frozen;

    /* Implicitly generated equality function name (set at freeze time) */
    const char  *equality_func_name;
};

/* ─────────────────────────────────────────────────────────────────────────
 * §10.2.1 Frozen Composite Types List
 *
 * Track composite types that need implicit equality operators.
 * These are added during Freeze_Type and processed during code generation.
 * ───────────────────────────────────────────────────────────────────────── */

static Type_Info *Frozen_Composite_Types[256];
static uint32_t   Frozen_Composite_Count = 0;

/* Global list of exception symbols for code generation */
static Symbol    *Exception_Symbols[256];
static uint32_t   Exception_Symbol_Count = 0;

/* ─────────────────────────────────────────────────────────────────────────
 * §10.3 Type Construction
 * ───────────────────────────────────────────────────────────────────────── */

static Type_Info *Type_New(Type_Kind kind, String_Slice name) {
    Type_Info *t = Arena_Allocate(sizeof(Type_Info));
    t->kind = kind;
    t->name = name;
    t->size = Default_Size_Bytes;
    t->alignment = Default_Align_Bytes;
    return t;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §10.4 Type Predicates
 * ───────────────────────────────────────────────────────────────────────── */

static inline bool Type_Is_Scalar(const Type_Info *t) {
    return t && t->kind >= TYPE_BOOLEAN && t->kind <= TYPE_FIXED;
}

static inline bool Type_Is_Discrete(const Type_Info *t) {
    return t && (t->kind == TYPE_BOOLEAN || t->kind == TYPE_CHARACTER ||
                 t->kind == TYPE_INTEGER || t->kind == TYPE_MODULAR ||
                 t->kind == TYPE_ENUMERATION);
}

static inline bool Type_Is_Numeric(const Type_Info *t) {
    return t && (t->kind == TYPE_INTEGER || t->kind == TYPE_MODULAR ||
                 t->kind == TYPE_FLOAT || t->kind == TYPE_FIXED ||
                 t->kind == TYPE_UNIVERSAL_INTEGER || t->kind == TYPE_UNIVERSAL_REAL);
}

static inline bool Type_Is_Real(const Type_Info *t) {
    return t && (t->kind == TYPE_FLOAT || t->kind == TYPE_FIXED ||
                 t->kind == TYPE_UNIVERSAL_REAL);
}

/* Type uses floating-point LLVM representation (for codegen, not semantic analysis).
 * Fixed-point types are NOT included as they use integer representation. */
static inline bool Type_Is_Float_Representation(const Type_Info *t) {
    return t && (t->kind == TYPE_FLOAT || t->kind == TYPE_UNIVERSAL_REAL);
}

static inline bool Type_Is_Array_Like(const Type_Info *t) {
    return t && (t->kind == TYPE_ARRAY || t->kind == TYPE_STRING);
}

static inline bool Type_Is_Composite(const Type_Info *t) {
    return t && (t->kind == TYPE_ARRAY || t->kind == TYPE_RECORD ||
                 t->kind == TYPE_STRING);
}

static inline bool Type_Is_Access(const Type_Info *t) {
    return t && t->kind == TYPE_ACCESS;
}

/* Check if array type is unconstrained (needs fat pointer representation) */
static inline bool Type_Is_Unconstrained_Array(const Type_Info *t) {
    return t && (t->kind == TYPE_ARRAY || t->kind == TYPE_STRING) &&
           !t->array.is_constrained;
}

/* Check if array type has dynamic bounds (BOUND_EXPR) that need runtime access.
 * This includes constrained arrays like ARRAY(1..G) where G is a variable. */
static inline bool Type_Has_Dynamic_Bounds(const Type_Info *t) {
    if (!t || (t->kind != TYPE_ARRAY && t->kind != TYPE_STRING))
        return false;
    if (t->array.index_count == 0)
        return false;
    /* Check if any bound is a runtime expression */
    for (uint32_t i = 0; i < t->array.index_count; i++) {
        if (t->array.indices[i].low_bound.kind == BOUND_EXPR ||
            t->array.indices[i].high_bound.kind == BOUND_EXPR) {
            return true;
        }
    }
    return false;
}

/* Check if an expression is a slice (NK_APPLY with NK_RANGE argument).
 * Slices produce fat pointers at runtime even when their declared type
 * is constrained, so they need special handling in comparisons. */
static inline bool Expression_Is_Slice(const Syntax_Node *node) {
    if (!node || node->kind != NK_APPLY) return false;
    for (uint32_t i = 0; i < node->apply.arguments.count; i++) {
        Syntax_Node *arg = node->apply.arguments.items[i];
        if (arg && arg->kind == NK_RANGE) return true;
    }
    return false;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §10.5 Base Type Traversal
 *
 * Per RM 3.3.1: The base type of a type is the ultimate ancestor.
 * For subtypes, follow base_type links; for derived types, follow parent_type.
 * ───────────────────────────────────────────────────────────────────────── */

static Type_Info *Type_Base(Type_Info *t) {
    while (t && t->base_type) t = t->base_type;
    return t;
}

/* Type_Root: Follow both base_type and parent_type chains to find the root
 * ancestor type. This is used for derived type compatibility checking where
 * we need to find the ultimate parent enumeration/integer type. */
static Type_Info *Type_Root(Type_Info *t) {
    while (t) {
        if (t->base_type) {
            t = t->base_type;
        } else if (t->parent_type) {
            t = t->parent_type;
        } else {
            break;
        }
    }
    return t;
}

/*
 * NOTE: Type compatibility checking is consolidated in Type_Covers()
 * defined in §11.6.2 (Overload Resolution section). That function provides
 * coverage checking for:
 * - Same type identity
 * - Universal type compatibility
 * - Base type matching
 * - Array/string structural compatibility
 * - Access type designated type compatibility
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §10.6 Type Freezing
 *
 * Freezing determines the point at which a type's representation is fixed.
 * The compiler must track what the RM permits but the programmer cannot see.
 * Per RM 13.14:
 * - Types are frozen by object declarations, bodies, end of declarative part
 * - Subtypes freeze their base type
 * - Composite types freeze their component types
 * - Once frozen, size/alignment/layout cannot change
 * ───────────────────────────────────────────────────────────────────────── */

/* Forward declaration for Symbol */
typedef struct Symbol Symbol;

/* Freeze a type and all its dependencies
 * Per RM 13.14: When a type is frozen, its representation is fixed */
static void Freeze_Type(Type_Info *t) {
    if (!t || t->is_frozen) return;

    /* Mark as frozen first to prevent infinite recursion */
    t->is_frozen = true;

    /* Freeze base type if present */
    if (t->base_type) {
        Freeze_Type(t->base_type);
    }

    /* Freeze parent type for derived types */
    if (t->parent_type) {
        Freeze_Type(t->parent_type);
    }

    /* Freeze component types for composites */
    switch (t->kind) {
        case TYPE_ARRAY:
        case TYPE_STRING:
            /* Freeze element type */
            if (t->array.element_type) {
                Freeze_Type(t->array.element_type);
            }
            /* Freeze index types */
            for (uint32_t i = 0; i < t->array.index_count; i++) {
                if (t->array.indices[i].index_type) {
                    Freeze_Type(t->array.indices[i].index_type);
                }
            }
            break;

        case TYPE_RECORD:
            /* Freeze all component types */
            for (uint32_t i = 0; i < t->record.component_count; i++) {
                if (t->record.components[i].component_type) {
                    Freeze_Type(t->record.components[i].component_type);
                }
            }
            break;

        case TYPE_ACCESS:
            /* Access type freezing does NOT freeze designated type */
            /* Per RM 13.14: "Freezing an access type does not freeze
               its designated subtype" */
            break;

        default:
            break;
    }

    /* Register composite types for implicit equality function generation
     * Per RM 4.5.2: Equality is predefined for all non-limited types */
    if (Type_Is_Composite(t) && Frozen_Composite_Count < 256) {
        Frozen_Composite_Types[Frozen_Composite_Count++] = t;

        /* Generate a unique function name for this type's equality */
        char *name_buf = Arena_Allocate(64);
        snprintf(name_buf, 64, "_ada_eq_%.*s_%u",
                 (int)(t->name.length > 20 ? 20 : t->name.length),
                 t->name.data,
                 Frozen_Composite_Count);
        t->equality_func_name = name_buf;
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §10.7 LLVM Type Mapping
 *
 * The source type is semantic while the target type is representational.
 * ───────────────────────────────────────────────────────────────────────── */

/* Forward declarations for array helpers (defined after Type_Bound_Value) */
static int64_t Type_Bound_Value(Type_Bound b);
static int64_t Array_Element_Count(Type_Info *t);
static int64_t Array_Low_Bound(Type_Info *t);

static const char *Type_To_Llvm(Type_Info *t) {
    if (!t) return "i64";

    switch (t->kind) {
        case TYPE_BOOLEAN:    return "i1";
        case TYPE_CHARACTER:  return "i8";
        case TYPE_INTEGER:
        case TYPE_MODULAR:
        case TYPE_ENUMERATION:
        case TYPE_UNIVERSAL_INTEGER:
        case TYPE_FIXED:  /* Fixed-point uses scaled integer representation */
            return Llvm_Int_Type((uint32_t)To_Bits(t->size));
        case TYPE_FLOAT:
        case TYPE_UNIVERSAL_REAL:
            return Llvm_Float_Type((uint32_t)To_Bits(t->size));
        case TYPE_ACCESS:
            /* Access to unconstrained array/STRING needs fat pointer representation */
            if (t->access.designated_type) {
                Type_Info *d = t->access.designated_type;
                if (d->kind == TYPE_STRING ||
                    (d->kind == TYPE_ARRAY && !d->array.is_constrained)) {
                    return "{ ptr, { i64, i64 } }";
                }
            }
            return "ptr";
        case TYPE_RECORD:
        case TYPE_TASK:
            return "ptr";
        case TYPE_ARRAY:
            /* Unconstrained arrays use fat pointers, constrained use ptr */
            return (t->array.is_constrained) ? "ptr" : "{ ptr, { i64, i64 } }";
        case TYPE_STRING:
            /* STRING is always unconstrained array of CHARACTER */
            return "{ ptr, { i64, i64 } }";
        default:
            return "i64";
    }
}


/* ═══════════════════════════════════════════════════════════════════════════
 * §11. SYMBOL TABLE — Scoped Name Resolution
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * The symbol table implements Ada's visibility and overloading rules:
 *
 * - Hierarchical scopes (packages can nest, blocks create new scopes)
 * - Overloading: same name, different parameter profiles
 * - Use clauses: make names directly visible without qualification
 * - Visibility: immediately visible, use-visible, directly visible
 *
 * We use a hash table with chaining and a scope stack for nested contexts.
 * Collisions are inevitable; we make them cheap rather than trying to
 * eliminate them.
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §11.1 Symbol Kinds
 *
 * Eighteen kinds where the RM defines most and the implementation adds two.
 * ───────────────────────────────────────────────────────────────────────── */

typedef enum {
    SYMBOL_UNKNOWN = 0,
    SYMBOL_VARIABLE,
    SYMBOL_CONSTANT,
    SYMBOL_TYPE,
    SYMBOL_SUBTYPE,
    SYMBOL_PROCEDURE,
    SYMBOL_FUNCTION,
    SYMBOL_PARAMETER,
    SYMBOL_PACKAGE,
    SYMBOL_EXCEPTION,
    SYMBOL_LABEL,
    SYMBOL_LOOP,
    SYMBOL_ENTRY,
    SYMBOL_COMPONENT,
    SYMBOL_DISCRIMINANT,
    SYMBOL_LITERAL,      /* Enumeration literal */
    SYMBOL_GENERIC,
    SYMBOL_GENERIC_INSTANCE,
    SYMBOL_COUNT
} Symbol_Kind;

/* ─────────────────────────────────────────────────────────────────────────
 * §11.2 Symbol Structure
 *
 * The symbol table maps names to meanings while the scope stack provides context.
 * ───────────────────────────────────────────────────────────────────────── */

typedef struct Symbol Symbol;
typedef struct Scope Scope;

/* Parameter mode */
typedef enum {
    PARAM_IN = 0,
    PARAM_OUT,
    PARAM_IN_OUT
} Parameter_Mode;

/* Parameter information for subprograms */
typedef struct {
    String_Slice    name;
    Type_Info      *param_type;
    Parameter_Mode  mode;
    Syntax_Node    *default_value;
    struct Symbol  *param_sym;    /* Symbol for this parameter in function body */
} Parameter_Info;

/* Check if parameter mode requires pass-by-reference (OUT or IN OUT) */
static inline bool Param_Is_By_Reference(Parameter_Mode mode) {
    return mode == PARAM_OUT || mode == PARAM_IN_OUT;
}

struct Symbol {
    Symbol_Kind     kind;
    String_Slice    name;
    Source_Location location;

    /* Type information */
    Type_Info      *type;

    /* Scope membership */
    Scope          *defining_scope;
    Symbol         *parent;         /* Enclosing package/subprogram symbol */

    /* Overloading chain */
    Symbol         *next_overload;

    /* Hash table chaining */
    Symbol         *next_in_bucket;

    /* Visibility */
    enum {
        VIS_HIDDEN = 0,
        VIS_IMMEDIATELY_VISIBLE = 1,
        VIS_USE_VISIBLE = 2,
        VIS_DIRECTLY_VISIBLE = 3
    } visibility;

    /* Declaration reference */
    Syntax_Node    *declaration;

    /* Subprogram-specific */
    Parameter_Info *parameters;
    uint32_t        parameter_count;
    Type_Info      *return_type;    /* NULL for procedures */

    /* Package-specific */
    Symbol        **exported;       /* Visible part symbols */
    uint32_t        exported_count;

    /* Unique identifier for mangling */
    uint32_t        unique_id;

    /* Nesting level for static link computation */
    uint32_t        nesting_level;

    /* Frame offset for static link variable access */
    int64_t         frame_offset;

    /* Scope created by this symbol (for functions/procedures) */
    Scope          *scope;

    /* ─────────────────────────────────────────────────────────────────────
     * Pragma Effects
     * ───────────────────────────────────────────────────────────────────── */

    /* pragma Inline */
    bool            is_inline;

    /* pragma Import / Export */
    bool            is_imported;
    bool            is_exported;
    String_Slice    external_name;       /* External linker name */
    String_Slice    link_name;           /* Link section name */
    enum {
        CONVENTION_ADA = 0,
        CONVENTION_C,
        CONVENTION_STDCALL,
        CONVENTION_INTRINSIC,
        CONVENTION_ASSEMBLER
    } convention;

    /* pragma Suppress checks */
    uint32_t        suppressed_checks;   /* Bitmask of suppressed checks */

    /* pragma Unreferenced */
    bool            is_unreferenced;

    /* Code generation flags */
    bool            extern_emitted;      /* Extern declaration already emitted */
    bool            body_emitted;        /* Function/procedure body already emitted */
    bool            is_named_number;     /* Named number (constant without explicit type) */
    bool            is_overloaded;       /* Part of an overload set (needs unique_id suffix) */
    bool            body_claimed;        /* Body has been matched to this spec (for homographs) */
    bool            is_predefined;       /* Predefined operator from STANDARD */
    bool            needs_address_marker; /* Needs @__addr.X global for 'ADDRESS */
    bool            is_identity_function; /* Function body is just RETURN param (can inline) */

    /* LLVM label ID for SYMBOL_LABEL */
    uint32_t        llvm_label_id;       /* 0 = not yet assigned */

    /* Entry index within task (for SYMBOL_ENTRY) */
    uint32_t        entry_index;         /* 0-based index for entry matching */

    /* For RENAMES: pointer to the renamed object's AST node */
    Syntax_Node    *renamed_object;

    /* ─────────────────────────────────────────────────────────────────────
     * Generic Support
     * ───────────────────────────────────────────────────────────────────── */

    /* For SYMBOL_GENERIC: the generic template */
    Syntax_Node    *generic_formals;     /* List of NK_GENERIC_*_PARAM nodes */
    Syntax_Node    *generic_unit;        /* The procedure/function/package spec */
    Syntax_Node    *generic_body;        /* Associated body (if found) */

    /* For SYMBOL_GENERIC_INSTANCE: instantiation info */
    Symbol         *generic_template;    /* The SYMBOL_GENERIC being instantiated */
    Symbol         *instantiated_subprogram;  /* The resolved subprogram instance */

    /* Generic formal->actual mapping (array parallel to generic_formals) */
    struct {
        String_Slice formal_name;
        Type_Info   *actual_type;        /* For type formals */
        Symbol      *actual_subprogram;  /* For subprogram formals */
        Syntax_Node *actual_expr;        /* For object formals */
        Token_Kind   builtin_operator;   /* For built-in operators as subprogram actuals */
    } *generic_actuals;
    uint32_t        generic_actual_count;

    /* For generic instances: expanded (cloned) trees with substitutions */
    Syntax_Node    *expanded_spec;       /* Cloned spec with actuals substituted */
    Syntax_Node    *expanded_body;       /* Cloned body with actuals substituted */
};

/* ─────────────────────────────────────────────────────────────────────────
 * §11.3 Scope Structure
 *
 * Each scope has its own hash table with 1024 buckets, which covers most programs.
 * ───────────────────────────────────────────────────────────────────────── */

#define SYMBOL_TABLE_SIZE 1024

struct Scope {
    Symbol  *buckets[SYMBOL_TABLE_SIZE];
    Scope   *parent;
    Symbol  *owner;             /* Package/subprogram owning this scope */
    uint32_t nesting_level;

    /* Linear list of all symbols for enumeration (static link support) */
    Symbol **symbols;
    uint32_t symbol_count;
    uint32_t symbol_capacity;
    int64_t  frame_size;        /* Total size of frame for this scope */
};

typedef struct {
    Scope   *current_scope;
    Scope   *global_scope;

    /* Predefined types */
    Type_Info *type_boolean;
    Type_Info *type_integer;
    Type_Info *type_float;
    Type_Info *type_character;
    Type_Info *type_string;
    Type_Info *type_duration;
    Type_Info *type_universal_integer;
    Type_Info *type_universal_real;
    Type_Info *type_address;  /* SYSTEM.ADDRESS */

    /* Unique ID counter for symbol mangling */
    uint32_t   next_unique_id;
} Symbol_Manager;

/* ─────────────────────────────────────────────────────────────────────────
 * §11.4 Scope Operations
 *
 * Lexical scoping is a tree; visibility rules turn it into a forest.
 * ───────────────────────────────────────────────────────────────────────── */

static Scope *Scope_New(Scope *parent) {
    Scope *scope = Arena_Allocate(sizeof(Scope));
    scope->parent = parent;
    scope->nesting_level = parent ? parent->nesting_level + 1 : 0;
    /* Inherit frame_size from parent so nested scope variables get unique offsets.
     * This ensures variables in DECLARE blocks don't overlap with outer variables. */
    scope->frame_size = parent ? parent->frame_size : 0;
    return scope;
}


static void Symbol_Manager_Push_Scope(Symbol_Manager *sm, Symbol *owner) {
    Scope *scope = Scope_New(sm->current_scope);
    scope->owner = owner;
    sm->current_scope = scope;
}

static void Symbol_Manager_Pop_Scope(Symbol_Manager *sm) {
    if (sm->current_scope->parent) {
        /* Propagate frame_size up to parent - parent needs to allocate enough
         * space for all variables, including those in nested blocks. */
        if (sm->current_scope->frame_size > sm->current_scope->parent->frame_size) {
            sm->current_scope->parent->frame_size = sm->current_scope->frame_size;
        }
        sm->current_scope = sm->current_scope->parent;
    }
}

/* Push an existing scope (used for separate subunits to reuse parent's scope) */
static void Symbol_Manager_Push_Existing_Scope(Symbol_Manager *sm, Scope *scope) {
    if (scope) {
        scope->parent = sm->current_scope;
        sm->current_scope = scope;
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §11.5 Symbol Table Operations
 * ───────────────────────────────────────────────────────────────────────── */

static uint32_t Symbol_Hash_Name(String_Slice name) {
    return (uint32_t)(Slice_Hash(name) % SYMBOL_TABLE_SIZE);
}

static Symbol *Symbol_New(Symbol_Kind kind, String_Slice name, Source_Location loc) {
    Symbol *sym = Arena_Allocate(sizeof(Symbol));
    sym->kind = kind;
    sym->name = name;
    sym->location = loc;
    sym->visibility = VIS_IMMEDIATELY_VISIBLE;
    return sym;
}

static void Symbol_Add(Symbol_Manager *sm, Symbol *sym) {
    Scope *scope = sm->current_scope;

    uint32_t hash = Symbol_Hash_Name(sym->name);
    Symbol *existing = scope->buckets[hash];

    /* Check if symbol is already in this bucket (avoid self-cycle) */
    while (existing) {
        if (existing == sym) return;  /* Already added */
        if (existing->defining_scope == scope &&
            Slice_Equal_Ignore_Case(existing->name, sym->name)) {
            /* Overloading: add to chain if subprograms or enumeration literals */
            /* Per RM 8.6, enumeration literals are overloadable like functions */
            if ((existing->kind == SYMBOL_PROCEDURE || existing->kind == SYMBOL_FUNCTION ||
                 existing->kind == SYMBOL_LITERAL) &&
                (sym->kind == SYMBOL_PROCEDURE || sym->kind == SYMBOL_FUNCTION ||
                 sym->kind == SYMBOL_LITERAL)) {
                /* Check if sym is already in the overload chain (prevents cycles) */
                Symbol *chain = existing;
                while (chain) {
                    if (chain == sym) return;  /* Already in chain */
                    chain = chain->next_overload;
                }
                sym->unique_id = sm->next_unique_id++;  /* Assign unique ID for mangling */
                sym->is_overloaded = true;
                existing->is_overloaded = true;  /* Mark first decl as overloaded too */
                sym->next_overload = existing->next_overload;
                existing->next_overload = sym;
                sym->parent = scope->owner;
                return;
            }
            /* Allow variable to shadow type with same name (single task declaration).
             * Per RM 9.1, a single task declaration creates both a task type and
             * an anonymous object of that type with the same name. The object
             * shadows the type for normal name lookups. */
            if (sym->kind == SYMBOL_VARIABLE && existing->kind == SYMBOL_TYPE) {
                break;  /* Proceed to add the variable - it will shadow the type */
            }
            /* Same symbol already exists at this scope - skip */
            return;
        }
        existing = existing->next_in_bucket;
    }

    sym->unique_id = sm->next_unique_id++;
    sym->defining_scope = scope;
    sym->nesting_level = scope->nesting_level;

    sym->next_in_bucket = scope->buckets[hash];
    scope->buckets[hash] = sym;

    /* Set parent to enclosing package/subprogram for nested symbol support */
    sym->parent = scope->owner;

    /* Add to linear symbol list for enumeration (static link support) */
    if (scope->symbol_count >= scope->symbol_capacity) {
        uint32_t new_cap = scope->symbol_capacity ? scope->symbol_capacity * 2 : 16;
        Symbol **new_syms = Arena_Allocate(new_cap * sizeof(Symbol*));
        if (scope->symbols) memcpy(new_syms, scope->symbols, scope->symbol_count * sizeof(Symbol*));
        scope->symbols = new_syms;
        scope->symbol_capacity = new_cap;
    }
    scope->symbols[scope->symbol_count++] = sym;

    /* Track frame offset for variables/parameters/constants */
    if (sym->kind == SYMBOL_VARIABLE || sym->kind == SYMBOL_PARAMETER ||
        sym->kind == SYMBOL_CONSTANT) {
        sym->frame_offset = scope->frame_size;
        uint32_t var_size = sym->type ? sym->type->size : 8;
        /* Fat pointers for dynamic/unconstrained arrays need 24 bytes { ptr, { i64, i64 } } */
        if (sym->type && (Type_Has_Dynamic_Bounds(sym->type) || Type_Is_Unconstrained_Array(sym->type))) {
            var_size = 24;
        }
        if (var_size == 0) var_size = 8;
        scope->frame_size += var_size;
    }
}

/* Find symbol by name, searching enclosing scopes */
static Symbol *Symbol_Find(Symbol_Manager *sm, String_Slice name) {
    uint32_t hash = Symbol_Hash_Name(name);

    for (Scope *scope = sm->current_scope; scope; scope = scope->parent) {
        for (Symbol *sym = scope->buckets[hash]; sym; sym = sym->next_in_bucket) {
            if (Slice_Equal_Ignore_Case(sym->name, name) &&
                sym->visibility >= VIS_IMMEDIATELY_VISIBLE) {
                return sym;
            }
        }
    }

    return NULL;
}

/* Find symbol with specific arity (for overload resolution) */
__attribute__((unused))
static Symbol *Symbol_Find_With_Arity(Symbol_Manager *sm, String_Slice name, uint32_t arity) {
    Symbol *sym = Symbol_Find(sm, name);

    while (sym) {
        if (sym->parameter_count == arity) return sym;
        sym = sym->next_overload;
    }

    return NULL;
}

/* Find symbol by name and type (for enumeration literal disambiguation) */
static Symbol *Symbol_Find_By_Type(Symbol_Manager *sm, String_Slice name, Type_Info *expected_type) {
    if (!expected_type) return Symbol_Find(sm, name);
    /* Get base type for matching (handles derived types and constrained subtypes).
     * Follow both parent_type (derived types) and base_type (constrained subtypes). */
    Type_Info *base_expected = expected_type;
    while (base_expected) {
        if (base_expected->parent_type)
            base_expected = base_expected->parent_type;
        else if (base_expected->base_type)
            base_expected = base_expected->base_type;
        else
            break;
    }

    uint32_t hash = Symbol_Hash_Name(name);
    /* Search all scopes for a matching symbol - don't stop at first name match,
     * keep searching if the type doesn't match (for enumeration literal overloading) */
    for (Scope *scope = sm->current_scope; scope; scope = scope->parent) {
        for (Symbol *sym = scope->buckets[hash]; sym; sym = sym->next_in_bucket) {
            if (Slice_Equal_Ignore_Case(sym->name, name) &&
                sym->visibility >= VIS_IMMEDIATELY_VISIBLE) {
                /* Search through overload chain (for enumeration literals) */
                for (Symbol *ovl = sym; ovl; ovl = ovl->next_overload) {
                    /* Check if type matches (either directly or via base type) */
                    Type_Info *sym_base = ovl->type;
                    while (sym_base) {
                        if (sym_base->parent_type)
                            sym_base = sym_base->parent_type;
                        else if (sym_base->base_type)
                            sym_base = sym_base->base_type;
                        else
                            break;
                    }
                    if (sym_base == base_expected) {
                        return ovl;
                    }
                }
                /* Type didn't match in this scope - continue to parent scopes */
            }
        }
    }
    return NULL;  /* No matching symbol found */
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §11.6 OVERLOAD RESOLUTION
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Overload resolution is a two-pass process:
 *
 * 1. Bottom-up pass: Collect all possible interpretations of each identifier
 *    based on visibility rules. Each interpretation is a (Symbol, Type) pair.
 *
 * 2. Top-down pass: Given context type expectations, select the unique valid
 *    interpretation using disambiguation rules.
 *
 * Key concepts:
 * - Interp: Record of (Nam, Typ, Opnd_Typ) representing one interpretation
 * - Covers: Type compatibility test (T1 covers T2 if T2's values are legal for T1)
 * - Disambiguate: Select best interpretation when multiple are valid
 *
 * Per RM 8.6: Overload resolution identifies the unique declaration for each
 * identifier. It fails if no interpretation is valid or if multiple are valid.
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §11.6.1 Interpretation Structure
 *
 * "type Interp is record Nam, Typ, Opnd_Typ..."
 * We store interpretations in a contiguous array during resolution.
 * Sixty-four interpretations suffices since deeper ambiguity signals a pathological program.
 * ───────────────────────────────────────────────────────────────────────── */

#define MAX_INTERPRETATIONS 64

typedef struct {
    Symbol    *nam;           /* The entity (function, procedure, operator) */
    Type_Info *typ;           /* The result type */
    Type_Info *opnd_typ;      /* For comparison ops: operand type for visibility */
    bool       is_universal;  /* True if operands are universal types */
    uint32_t   scope_depth;   /* Nesting level for hiding rules */
} Interpretation;

typedef struct {
    Interpretation items[MAX_INTERPRETATIONS];
    uint32_t       count;
} Interp_List;

/* ─────────────────────────────────────────────────────────────────────────
 * §11.6.2 Type Covering (Compatibility)
 *
 * For example: T1 covers T2 if values of T2 are legal where T1 is expected.
 *
 * Key rules from RM 8.6:
 * - Same type: always covers
 * - Subtypes of same base type: cover each other
 * - Universal types: Universal_Integer covers any integer type, etc.
 * ───────────────────────────────────────────────────────────────────────── */

static bool Type_Covers(Type_Info *expected, Type_Info *actual) {
    /* Null types are permissive (incomplete analysis) */
    if (!expected || !actual) return true;

    /* Same type always covers */
    if (expected == actual) return true;

    /* Universal_Integer covers any discrete type */
    if (expected->kind == TYPE_UNIVERSAL_INTEGER) {
        return Type_Is_Discrete(actual);
    }
    if (actual->kind == TYPE_UNIVERSAL_INTEGER) {
        return Type_Is_Discrete(expected);
    }

    /* Universal_Real covers any real type */
    if (expected->kind == TYPE_UNIVERSAL_REAL) {
        return Type_Is_Real(actual);
    }
    if (actual->kind == TYPE_UNIVERSAL_REAL) {
        return Type_Is_Real(expected);
    }

    /* Same base type covers */
    Type_Info *base_exp = Type_Base(expected);
    Type_Info *base_act = Type_Base(actual);
    if (base_exp == base_act) return true;
    if (base_exp == actual || expected == base_act) return true;

    /* For derived types, check if they share the same root type (RM 3.4).
     * This handles enumeration/integer literals from parent types being
     * compatible with derived types. E.g., if T is new PARENT, then
     * enumeration literal E4 from PARENT is compatible with T. */
    Type_Info *root_exp = Type_Root(expected);
    Type_Info *root_act = Type_Root(actual);
    if (root_exp && root_act && root_exp == root_act) return true;

    /* SYSTEM.ADDRESS compatibility (RM 13.7): all ADDRESS types are interoperable
     * This handles the case where 'ADDRESS attribute returns a built-in ADDRESS
     * type but the target is declared as SYSTEM.ADDRESS from the package */
    if (Slice_Equal_Ignore_Case(expected->name, S("ADDRESS")) &&
        Slice_Equal_Ignore_Case(actual->name, S("ADDRESS"))) {
        return true;
    }

    /* Array/string compatibility: same structure */
    if (Type_Is_Array_Like(expected) && Type_Is_Array_Like(actual)) {
        /* STRING is compatible with CHARACTER arrays */
        if (expected->kind == TYPE_STRING || actual->kind == TYPE_STRING) {
            return true;
        }
        /* Arrays with same element type */
        if (expected->array.element_type && actual->array.element_type) {
            return Type_Covers(expected->array.element_type,
                              actual->array.element_type);
        }
        return true;
    }

    /* Access types: check designated type compatibility */
    if (expected->kind == TYPE_ACCESS && actual->kind == TYPE_ACCESS) {
        if (expected->access.designated_type && actual->access.designated_type) {
            return Type_Covers(expected->access.designated_type,
                              actual->access.designated_type);
        }
        return true;
    }

    /* NULL literal covers any access type */
    if (expected->kind == TYPE_ACCESS && !actual) {
        return true;
    }

    /* Enumeration types from generic instantiation: same name means compatible.
     * This handles the case where instantiation creates new type objects
     * that should be compatible with the original generic spec's types. */
    if (expected->kind == TYPE_ENUMERATION && actual->kind == TYPE_ENUMERATION &&
        expected->name.data && actual->name.data &&
        Slice_Equal_Ignore_Case(expected->name, actual->name)) {
        return true;
    }

    /* Integer/derived types from generic instantiation: same name means compatible */
    if (expected->kind == TYPE_INTEGER && actual->kind == TYPE_INTEGER &&
        expected->name.data && actual->name.data &&
        Slice_Equal_Ignore_Case(expected->name, actual->name)) {
        return true;
    }

    /* Character literals as enumeration literals (RM 3.5.1):
     * An enumeration type can define character literals (e.g., TYPE T IS ('A', 'B');).
     * When comparing, CHARACTER type should be compatible with such enumerations.
     * Check by looking for literals that start with single quote. */
    {
        Type_Info *char_type = NULL;
        Type_Info *enum_type = NULL;
        if (expected->kind == TYPE_CHARACTER && actual->kind == TYPE_ENUMERATION) {
            char_type = expected;
            enum_type = actual;
        } else if (actual->kind == TYPE_CHARACTER && expected->kind == TYPE_ENUMERATION) {
            char_type = actual;
            enum_type = expected;
        }
        /* Also check derived enumeration types via root */
        if (!enum_type && expected->kind == TYPE_CHARACTER) {
            Type_Info *act_root = Type_Root(actual);
            if (act_root && act_root->kind == TYPE_ENUMERATION) {
                enum_type = act_root;
                char_type = expected;
            }
        }
        if (!enum_type && actual->kind == TYPE_CHARACTER) {
            Type_Info *exp_root = Type_Root(expected);
            if (exp_root && exp_root->kind == TYPE_ENUMERATION) {
                enum_type = exp_root;
                char_type = actual;
            }
        }
        if (char_type && enum_type && enum_type->enumeration.literals) {
            /* Check if enum has any character literals */
            for (uint32_t i = 0; i < enum_type->enumeration.literal_count; i++) {
                String_Slice lit = enum_type->enumeration.literals[i];
                if (lit.length > 0 && lit.data[0] == '\'') {
                    return true;  /* Enum has character literals */
                }
            }
        }
    }

    return false;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §11.6.3 Parameter Conformance
 *
 * Check if an argument list matches a subprogram's parameter profile.
 * Per RM 6.4.1: actual parameters must be type conformant with formals.
 * ───────────────────────────────────────────────────────────────────────── */

/* Forward declaration for Resolve_Expression - needed for argument resolution */
static Type_Info *Resolve_Expression(Symbol_Manager *sm, Syntax_Node *node);

typedef struct {
    Type_Info **types;       /* Array of argument types */
    uint32_t    count;       /* Number of arguments */
    String_Slice *names;     /* Named association names (NULL for positional) */
} Argument_Info;

/* Check if arguments match a symbol's parameter profile */
static bool Arguments_Match_Profile(Symbol *sym, Argument_Info *args) {
    if (!sym) return false;

    /* Track which formal parameters are covered by arguments */
    bool *param_covered = Arena_Allocate(sym->parameter_count * sizeof(bool));
    for (uint32_t i = 0; i < sym->parameter_count; i++) {
        param_covered[i] = false;
    }

    /* Check type compatibility for each argument and mark params covered */
    for (uint32_t i = 0; i < args->count; i++) {
        Type_Info *arg_type = args->types[i];
        Type_Info *param_type = NULL;
        uint32_t param_idx = i;

        /* Handle named association */
        if (args->names && args->names[i].data) {
            bool found = false;
            for (uint32_t j = 0; j < sym->parameter_count; j++) {
                if (Slice_Equal_Ignore_Case(sym->parameters[j].name, args->names[i])) {
                    param_type = sym->parameters[j].param_type;
                    param_idx = j;
                    found = true;
                    break;
                }
            }
            if (!found) return false;
        } else {
            /* Positional: use i-th parameter */
            if (i >= sym->parameter_count) return false;
            param_type = sym->parameters[i].param_type;
        }

        /* Mark this parameter as covered */
        if (param_idx < sym->parameter_count) {
            param_covered[param_idx] = true;
        }

        if (!Type_Covers(param_type, arg_type)) {
            return false;
        }
    }

    /* Verify all required parameters (no default value) are covered */
    for (uint32_t i = 0; i < sym->parameter_count; i++) {
        if (!param_covered[i] && !sym->parameters[i].default_value) {
            return false;  /* Required parameter not provided */
        }
    }

    return true;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §11.6.4 Interpretation Collection
 *
 * Gather candidates first, filter later. Visibility determines the set.
 * ───────────────────────────────────────────────────────────────────────── */

/* Collect all visible interpretations of a name */
static void Collect_Interpretations(Symbol_Manager *sm, String_Slice name,
                                    Interp_List *interps) {
    interps->count = 0;
    uint32_t hash = Symbol_Hash_Name(name);

    /* Search all enclosing scopes */
    for (Scope *scope = sm->current_scope; scope; scope = scope->parent) {
        for (Symbol *sym = scope->buckets[hash]; sym; sym = sym->next_in_bucket) {
            if (!Slice_Equal_Ignore_Case(sym->name, name)) continue;
            if (sym->visibility < VIS_IMMEDIATELY_VISIBLE) continue;

            /* Add this interpretation and all overloads */
            Symbol *s = sym;
            while (s && interps->count < MAX_INTERPRETATIONS) {
                /* Check if we already have this interpretation */
                bool duplicate = false;
                for (uint32_t i = 0; i < interps->count; i++) {
                    if (interps->items[i].nam == s) {
                        duplicate = true;
                        break;
                    }
                }

                if (!duplicate) {
                    interps->items[interps->count++] = (Interpretation){
                        .nam = s,
                        .typ = (s->kind == SYMBOL_FUNCTION) ? s->return_type : s->type,
                        .opnd_typ = NULL,
                        .is_universal = false,
                        .scope_depth = scope->nesting_level
                    };
                }

                s = s->next_overload;
            }
        }
    }
}

/* Filter interpretations by argument compatibility */
static void Filter_By_Arguments(Interp_List *interps, Argument_Info *args) {
    uint32_t write_idx = 0;

    for (uint32_t i = 0; i < interps->count; i++) {
        Symbol *sym = interps->items[i].nam;

        /* Non-callable symbols don't filter by arguments */
        if (sym->kind != SYMBOL_FUNCTION && sym->kind != SYMBOL_PROCEDURE) {
            interps->items[write_idx++] = interps->items[i];
            continue;
        }

        /* Keep if arguments match */
        if (Arguments_Match_Profile(sym, args)) {
            interps->items[write_idx++] = interps->items[i];
        }
    }

    interps->count = write_idx;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §11.6.5 Disambiguation
 *
 * Nearer scope, exact type match, and user definitions all take priority.
 * ───────────────────────────────────────────────────────────────────────── */

/* Check if sym1 hides sym2 (user-defined hiding predefined, or inner scope) */
static bool Symbol_Hides(Symbol *sym1, Symbol *sym2) {
    if (!sym1 || !sym2) return false;

    /* User-defined function can hide predefined operator */
    if ((sym1->kind == SYMBOL_FUNCTION || sym1->kind == SYMBOL_PROCEDURE) &&
        sym2->nesting_level == 0) {  /* Predefined are at level 0 */
        return true;
    }

    /* Inner scope hides outer scope */
    if (sym1->nesting_level > sym2->nesting_level) {
        return true;
    }

    return false;
}

/* Check if type is a universal type */
static bool Type_Is_Universal(Type_Info *t) {
    return t && (t->kind == TYPE_UNIVERSAL_INTEGER ||
                 t->kind == TYPE_UNIVERSAL_REAL);
}

/* Score an interpretation for preference ranking (higher = better) */
static int32_t Score_Interpretation(Interpretation *interp,
                                    Type_Info *context_type,
                                    Argument_Info *args) {
    int32_t score = 0;
    Symbol *sym = interp->nam;

    /* Prefer non-universal interpretations */
    if (!Type_Is_Universal(interp->typ)) {
        score += 1000;
    }

    /* Prefer exact context type match */
    if (context_type && interp->typ == context_type) {
        score += 500;
    }

    /* Prefer inner scopes (user-defined over predefined) */
    score += (int32_t)(interp->scope_depth * 10);

    /* For functions: prefer exact argument type matches */
    if (sym && (sym->kind == SYMBOL_FUNCTION || sym->kind == SYMBOL_PROCEDURE) && args) {
        for (uint32_t i = 0; i < args->count && i < sym->parameter_count; i++) {
            Type_Info *arg_type = args->types[i];
            Type_Info *param_type = sym->parameters[i].param_type;

            /* Exact match is better than just coverage */
            if (arg_type == param_type) {
                score += 100;
            } else if (Type_Base(arg_type) == Type_Base(param_type)) {
                score += 50;
            }
        }
    }

    return score;
}

/* Select the best interpretation from a list */
static Symbol *Disambiguate(Interp_List *interps, Type_Info *context_type,
                           Argument_Info *args) {
    if (interps->count == 0) return NULL;
    if (interps->count == 1) return interps->items[0].nam;

    /* Score all interpretations */
    int32_t best_score = INT32_MIN;
    Symbol *best = NULL;
    int tied_count = 0;

    for (uint32_t i = 0; i < interps->count; i++) {
        int32_t score = Score_Interpretation(&interps->items[i], context_type, args);

        if (score > best_score) {
            best_score = score;
            best = interps->items[i].nam;
            tied_count = 1;
        } else if (score == best_score) {
            /* Check hiding rules */
            if (Symbol_Hides(interps->items[i].nam, best)) {
                best = interps->items[i].nam;
            } else if (!Symbol_Hides(best, interps->items[i].nam)) {
                tied_count++;
            }
        }
    }

    /* If still tied, check for universal vs specific preference */
    if (tied_count > 1 && context_type) {
        /* Prefer interpretation matching context exactly */
        for (uint32_t i = 0; i < interps->count; i++) {
            if (interps->items[i].typ == context_type) {
                return interps->items[i].nam;
            }
        }

        /* Prefer non-universal */
        for (uint32_t i = 0; i < interps->count; i++) {
            if (!Type_Is_Universal(interps->items[i].typ)) {
                return interps->items[i].nam;
            }
        }
    }

    return best;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §11.6.6 Unified Overload Resolution Entry Point
 *
 * Collect, filter, disambiguate, fail if not unique.
 * ───────────────────────────────────────────────────────────────────────── */

static Symbol *Resolve_Overloaded_Call(Symbol_Manager *sm,
                                       String_Slice name,
                                       Argument_Info *args,
                                       Type_Info *context_type) {
    Interp_List interps;

    /* Phase 1: Collect all visible interpretations */
    Collect_Interpretations(sm, name, &interps);

    if (interps.count == 0) {
        return NULL;  /* No visible interpretation */
    }

    /* Phase 2: Filter by argument compatibility */
    if (args && args->count > 0) {
        Filter_By_Arguments(&interps, args);

        if (interps.count == 0) {
            return NULL;  /* No matching profile */
        }
    }

    /* Phase 3: Apply context type filtering if provided */
    if (context_type && interps.count > 1) {
        uint32_t write_idx = 0;
        for (uint32_t i = 0; i < interps.count; i++) {
            if (Type_Covers(context_type, interps.items[i].typ)) {
                interps.items[write_idx++] = interps.items[i];
            }
        }
        if (write_idx > 0) {
            interps.count = write_idx;
        }
        /* If no matches, keep all for better error reporting */
    }

    /* Phase 4: Disambiguate if multiple interpretations remain */
    return Disambiguate(&interps, context_type, args);
}

/* ─────────────────────────────────────────────────────────────────────────
 * §11.7 Symbol Manager Initialization
 * ───────────────────────────────────────────────────────────────────────── */

static void Symbol_Manager_Init_Predefined(Symbol_Manager *sm) {
    /* Create predefined types */
    sm->type_boolean = Type_New(TYPE_BOOLEAN, S("BOOLEAN"));
    sm->type_boolean->size = 1;
    sm->type_boolean->low_bound = (Type_Bound){BOUND_INTEGER, {.int_value = 0}};
    sm->type_boolean->high_bound = (Type_Bound){BOUND_INTEGER, {.int_value = 1}};

    sm->type_integer = Type_New(TYPE_INTEGER, S("INTEGER"));
    sm->type_integer->size = 8;  /* 64-bit INTEGER to match i64 usage throughout codegen */
    sm->type_integer->low_bound = (Type_Bound){BOUND_INTEGER, {.int_value = INT32_MIN}};
    sm->type_integer->high_bound = (Type_Bound){BOUND_INTEGER, {.int_value = INT32_MAX}};

    sm->type_float = Type_New(TYPE_FLOAT, S("FLOAT"));
    sm->type_float->size = 8;  /* double precision */

    sm->type_character = Type_New(TYPE_CHARACTER, S("CHARACTER"));
    sm->type_character->size = 1;

    sm->type_string = Type_New(TYPE_STRING, S("STRING"));
    sm->type_string->size = 16;  /* Fat pointer: ptr + length */
    sm->type_string->array.element_type = sm->type_character;  /* STRING is array of CHARACTER */

    /* DURATION is a predefined fixed-point type for time intervals */
    sm->type_duration = Type_New(TYPE_FIXED, S("DURATION"));
    sm->type_duration->size = 8;  /* 64-bit for high precision */
    sm->type_duration->fixed.delta = 0.00001;  /* 10 microsecond resolution */

    sm->type_universal_integer = Type_New(TYPE_UNIVERSAL_INTEGER, S("universal_integer"));
    sm->type_universal_real = Type_New(TYPE_UNIVERSAL_REAL, S("universal_real"));
    sm->type_universal_real->size = 8;  /* 64 bits / double precision */

    /* Add predefined type symbols to global scope */
    Symbol *sym_boolean = Symbol_New(SYMBOL_TYPE, S("BOOLEAN"), No_Location);
    sym_boolean->type = sm->type_boolean;
    Symbol_Add(sm, sym_boolean);

    Symbol *sym_integer = Symbol_New(SYMBOL_TYPE, S("INTEGER"), No_Location);
    sym_integer->type = sm->type_integer;
    Symbol_Add(sm, sym_integer);

    /* NATURAL is subtype INTEGER range 0..INTEGER'LAST */
    Symbol *sym_natural = Symbol_New(SYMBOL_SUBTYPE, S("NATURAL"), No_Location);
    Type_Info *type_natural = Type_New(TYPE_INTEGER, S("NATURAL"));
    type_natural->base_type = sm->type_integer;
    type_natural->size = sm->type_integer->size;
    type_natural->alignment = sm->type_integer->alignment;
    type_natural->low_bound = (Type_Bound){ .kind = BOUND_INTEGER, .int_value = 0 };
    type_natural->high_bound = sm->type_integer->high_bound;
    sym_natural->type = type_natural;
    Symbol_Add(sm, sym_natural);

    /* POSITIVE is subtype INTEGER range 1..INTEGER'LAST */
    Symbol *sym_positive = Symbol_New(SYMBOL_SUBTYPE, S("POSITIVE"), No_Location);
    Type_Info *type_positive = Type_New(TYPE_INTEGER, S("POSITIVE"));
    type_positive->base_type = sm->type_integer;
    type_positive->size = sm->type_integer->size;
    type_positive->alignment = sm->type_integer->alignment;
    type_positive->low_bound = (Type_Bound){ .kind = BOUND_INTEGER, .int_value = 1 };
    type_positive->high_bound = sm->type_integer->high_bound;
    sym_positive->type = type_positive;
    Symbol_Add(sm, sym_positive);

    Symbol *sym_float = Symbol_New(SYMBOL_TYPE, S("FLOAT"), No_Location);
    sym_float->type = sm->type_float;
    Symbol_Add(sm, sym_float);

    Symbol *sym_duration = Symbol_New(SYMBOL_TYPE, S("DURATION"), No_Location);
    sym_duration->type = sm->type_duration;
    Symbol_Add(sm, sym_duration);

    Symbol *sym_character = Symbol_New(SYMBOL_TYPE, S("CHARACTER"), No_Location);
    sym_character->type = sm->type_character;
    Symbol_Add(sm, sym_character);

    Symbol *sym_string = Symbol_New(SYMBOL_TYPE, S("STRING"), No_Location);
    sym_string->type = sm->type_string;
    Symbol_Add(sm, sym_string);

    /* Boolean literals */
    Symbol *sym_false = Symbol_New(SYMBOL_LITERAL, S("FALSE"), No_Location);
    sym_false->type = sm->type_boolean;
    Symbol_Add(sm, sym_false);

    Symbol *sym_true = Symbol_New(SYMBOL_LITERAL, S("TRUE"), No_Location);
    sym_true->type = sm->type_boolean;
    Symbol_Add(sm, sym_true);

    /* Predefined exceptions (RM 11.1) */
    Symbol *sym_constraint_error = Symbol_New(SYMBOL_EXCEPTION, S("CONSTRAINT_ERROR"), No_Location);
    Symbol_Add(sm, sym_constraint_error);

    Symbol *sym_numeric_error = Symbol_New(SYMBOL_EXCEPTION, S("NUMERIC_ERROR"), No_Location);
    Symbol_Add(sm, sym_numeric_error);

    Symbol *sym_program_error = Symbol_New(SYMBOL_EXCEPTION, S("PROGRAM_ERROR"), No_Location);
    Symbol_Add(sm, sym_program_error);

    Symbol *sym_storage_error = Symbol_New(SYMBOL_EXCEPTION, S("STORAGE_ERROR"), No_Location);
    Symbol_Add(sm, sym_storage_error);

    Symbol *sym_tasking_error = Symbol_New(SYMBOL_EXCEPTION, S("TASKING_ERROR"), No_Location);
    Symbol_Add(sm, sym_tasking_error);

    /* SYSTEM.ADDRESS (RM 13.7) - implementation-defined private type
     * In our implementation, ADDRESS is an integer type (derived from INTEGER) */
    sm->type_address = Type_New(TYPE_INTEGER, S("ADDRESS"));
    sm->type_address->size = 8;  /* 64-bit addresses */
    sm->type_address->alignment = 8;
    sm->type_address->base_type = sm->type_integer;

    /* STANDARD package (RM 8.6) - the implicit library containing predefined types
     * All visible entities are implicitly declared here */
    Symbol *pkg_standard = Symbol_New(SYMBOL_PACKAGE, S("STANDARD"), No_Location);
    Type_Info *pkg_standard_type = Type_New(TYPE_PACKAGE, S("STANDARD"));
    pkg_standard->type = pkg_standard_type;
    Symbol_Add(sm, pkg_standard);

    /* ASCII package (RM C.3) - predefined character constants
     * In Ada 83, ASCII is a package in STANDARD, always visible */
    Symbol *pkg_ascii = Symbol_New(SYMBOL_PACKAGE, S("ASCII"), No_Location);
    Type_Info *pkg_ascii_type = Type_New(TYPE_PACKAGE, S("ASCII"));
    pkg_ascii->type = pkg_ascii_type;
    pkg_ascii->parent = pkg_standard;  /* Child of STANDARD */
    Symbol_Add(sm, pkg_ascii);

    /* STANDARD exports ASCII */
    pkg_standard->exported = Arena_Allocate(1 * sizeof(Symbol*));
    pkg_standard->exported_count = 1;
    pkg_standard->exported[0] = pkg_ascii;

    /* ASCII control characters and named constants */
    static const struct { const char *name; uint8_t val; } ascii_chars[] = {
        {"NUL",0},{"SOH",1},{"STX",2},{"ETX",3},{"EOT",4},{"ENQ",5},{"ACK",6},{"BEL",7},
        {"BS",8},{"HT",9},{"LF",10},{"VT",11},{"FF",12},{"CR",13},{"SO",14},{"SI",15},
        {"DLE",16},{"DC1",17},{"DC2",18},{"DC3",19},{"DC4",20},{"NAK",21},{"SYN",22},
        {"ETB",23},{"CAN",24},{"EM",25},{"SUB",26},{"ESC",27},{"FS",28},{"GS",29},
        {"RS",30},{"US",31},{"DEL",127},
        /* Named punctuation */
        {"EXCLAM",'!'},{"QUOTATION",'"'},{"SHARP",'#'},{"DOLLAR",'$'},{"PERCENT",'%'},
        {"AMPERSAND",'&'},{"COLON",':'},{"SEMICOLON",';'},{"QUERY",'?'},{"AT_SIGN",'@'},
        {"L_BRACKET",'['},{"BACK_SLASH",'\\'},{"R_BRACKET",']'},{"CIRCUMFLEX",'^'},
        {"UNDERLINE",'_'},{"GRAVE",'`'},{"L_BRACE",'{'},{"BAR",'|'},{"R_BRACE",'}'},
        {"TILDE",'~'},
        /* Lowercase letters */
        {"LC_A",'a'},{"LC_B",'b'},{"LC_C",'c'},{"LC_D",'d'},{"LC_E",'e'},{"LC_F",'f'},
        {"LC_G",'g'},{"LC_H",'h'},{"LC_I",'i'},{"LC_J",'j'},{"LC_K",'k'},{"LC_L",'l'},
        {"LC_M",'m'},{"LC_N",'n'},{"LC_O",'o'},{"LC_P",'p'},{"LC_Q",'q'},{"LC_R",'r'},
        {"LC_S",'s'},{"LC_T",'t'},{"LC_U",'u'},{"LC_V",'v'},{"LC_W",'w'},{"LC_X",'x'},
        {"LC_Y",'y'},{"LC_Z",'z'},
    };
    uint32_t ascii_count = sizeof(ascii_chars) / sizeof(ascii_chars[0]);
    pkg_ascii->exported = Arena_Allocate(ascii_count * sizeof(Symbol*));
    pkg_ascii->exported_count = ascii_count;
    for (uint32_t i = 0; i < ascii_count; i++) {
        String_Slice name = { ascii_chars[i].name, strlen(ascii_chars[i].name) };
        Symbol *ch = Symbol_New(SYMBOL_CONSTANT, name, No_Location);
        ch->type = sm->type_character;
        ch->parent = pkg_ascii;
        ch->frame_offset = ascii_chars[i].val;  /* Store char value */
        ch->is_named_number = true;  /* Treat as compile-time constant */
        Symbol_Add(sm, ch);
        pkg_ascii->exported[i] = ch;
    }

    /* ─────────────────────────────────────────────────────────────────────────
     * Predefined Operators (RM 4.5) — Needed for operator renaming
     *
     * Per LRM 4.5.3-4.5.6, predefined operators exist for all numeric types.
     * We add symbols for these so RENAMES "+" etc. can resolve them.
     * ───────────────────────────────────────────────────────────────────────── */
    static const struct { const char *name; bool is_binary; bool returns_bool; } predef_ops[] = {
        {"+", true, false}, {"-", true, false}, {"*", true, false},
        {"/", true, false}, {"mod", true, false}, {"rem", true, false},
        {"**", true, false}, {"abs", false, false},
        {"=", true, true}, {"/=", true, true},
        {"<", true, true}, {"<=", true, true},
        {">", true, true}, {">=", true, true},
    };
    Type_Info *num_types[] = { sm->type_integer, sm->type_float };
    for (uint32_t ti = 0; ti < 2; ti++) {
        Type_Info *ty = num_types[ti];
        for (uint32_t i = 0; i < sizeof(predef_ops)/sizeof(predef_ops[0]); i++) {
            String_Slice op_name = { predef_ops[i].name, strlen(predef_ops[i].name) };
            Symbol *op_sym = Symbol_New(SYMBOL_FUNCTION, op_name, No_Location);
            op_sym->is_predefined = true;
            op_sym->return_type = predef_ops[i].returns_bool ? sm->type_boolean : ty;
            if (predef_ops[i].is_binary) {
                op_sym->parameter_count = 2;
                op_sym->parameters = Arena_Allocate(2 * sizeof(Parameter_Info));
                op_sym->parameters[0] = (Parameter_Info){S("LEFT"), ty, PARAM_IN, NULL};
                op_sym->parameters[1] = (Parameter_Info){S("RIGHT"), ty, PARAM_IN, NULL};
            } else {
                op_sym->parameter_count = 1;
                op_sym->parameters = Arena_Allocate(1 * sizeof(Parameter_Info));
                op_sym->parameters[0] = (Parameter_Info){S("RIGHT"), ty, PARAM_IN, NULL};
            }
            Symbol_Add(sm, op_sym);
        }
    }
}

static Symbol_Manager *Symbol_Manager_New(void) {
    Symbol_Manager *sm = Arena_Allocate(sizeof(Symbol_Manager));
    sm->global_scope = Scope_New(NULL);
    sm->current_scope = sm->global_scope;
    sm->next_unique_id = 1;
    Symbol_Manager_Init_Predefined(sm);
    return sm;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §12. SEMANTIC ANALYSIS — Type Checking and Resolution
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * A permissive parser gives the type checker material to work with.
 *
 * Semantic analysis performs:
 * - Name resolution: bind identifiers to symbols
 * - Type checking: verify type compatibility of operations
 * - Overload resolution: select correct subprogram
 * - Constraint checking: verify bounds, indices, etc.
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §12.1 Expression Resolution
 * ───────────────────────────────────────────────────────────────────────── */

static Type_Info *Resolve_Expression(Symbol_Manager *sm, Syntax_Node *node);
static void Resolve_Statement(Symbol_Manager *sm, Syntax_Node *node);

static Type_Info *Resolve_Identifier(Symbol_Manager *sm, Syntax_Node *node) {
    Symbol *sym = Symbol_Find(sm, node->string_val.text);

    if (!sym) {
        Report_Error(node->location, "undefined identifier '%.*s'",
                    node->string_val.text.length, node->string_val.text.data);
        return sm->type_integer;  /* ??? Continue; one error is better than ten. */
    }

    node->symbol = sym;

    /* For parameterless functions, the result type is the return type.
     * In Ada, a function name without parentheses is a valid call. */
    if (sym->kind == SYMBOL_FUNCTION && sym->return_type) {
        node->type = sym->return_type;
        return sym->return_type;
    }

    node->type = sym->type;
    return sym->type;
}

static Type_Info *Resolve_Selected(Symbol_Manager *sm, Syntax_Node *node) {
    /* Resolve prefix first */
    Type_Info *prefix_type = Resolve_Expression(sm, node->selected.prefix);

    /* Handle .ALL for explicit dereference (RM 4.1) */
    if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
        Slice_Equal_Ignore_Case(node->selected.selector, S("ALL"))) {
        node->type = prefix_type->access.designated_type;
        return node->type;
    }

    /* Get effective type for record component lookup (handle implicit dereference) */
    Type_Info *record_type = prefix_type;
    if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
        prefix_type->access.designated_type &&
        prefix_type->access.designated_type->kind == TYPE_RECORD) {
        record_type = prefix_type->access.designated_type;
    }

    if (record_type && record_type->kind == TYPE_RECORD) {
        /* Look up component */
        for (uint32_t i = 0; i < record_type->record.component_count; i++) {
            if (Slice_Equal_Ignore_Case(record_type->record.components[i].name,
                                        node->selected.selector)) {
                node->type = record_type->record.components[i].component_type;
                return node->type;
            }
        }
        Report_Error(node->location, "no component '%.*s' in record type",
                    node->selected.selector.length, node->selected.selector.data);
    } else if (prefix_type && prefix_type->kind == TYPE_TASK) {
        /* Task entry selection: T.E1 where T is a task object (RM 9.5)
         * Look up entry in the task type's defining_symbol exported list */
        Symbol *type_sym = prefix_type->defining_symbol;
        if (type_sym) {
            for (uint32_t i = 0; i < type_sym->exported_count; i++) {
                if (Slice_Equal_Ignore_Case(type_sym->exported[i]->name,
                                           node->selected.selector)) {
                    node->symbol = type_sym->exported[i];
                    node->type = type_sym->exported[i]->type;
                    return node->type;
                }
            }
        }
        Report_Error(node->location, "no entry '%.*s' in task type",
                    (int)node->selected.selector.length, node->selected.selector.data);
    } else {
        /* Could be qualified name - look up in prefix's exported/visible symbols.
         * Per RM 4.1.3, qualified names can use package, procedure, or function
         * as prefix to access items declared within that scope. */
        Symbol *prefix_sym = node->selected.prefix->symbol;
        if (prefix_sym && prefix_sym->kind == SYMBOL_PACKAGE) {
            /* Search package's exported symbols */
            for (uint32_t i = 0; i < prefix_sym->exported_count; i++) {
                if (Slice_Equal_Ignore_Case(prefix_sym->exported[i]->name,
                                           node->selected.selector)) {
                    node->symbol = prefix_sym->exported[i];
                    node->type = prefix_sym->exported[i]->type;
                    return node->type;
                }
            }
        }
        /* For procedure/function prefix, search the subprogram's scope.
         * This handles cases like MAIN.A_B_C where MAIN is a procedure
         * and A_B_C is an enum literal or type declared within it. */
        if (prefix_sym && (prefix_sym->kind == SYMBOL_PROCEDURE ||
                          prefix_sym->kind == SYMBOL_FUNCTION) &&
            prefix_sym->scope) {
            Scope *subp_scope = prefix_sym->scope;
            uint32_t hash = Symbol_Hash_Name(node->selected.selector);
            for (Symbol *s = subp_scope->buckets[hash]; s; s = s->next_in_bucket) {
                if (Slice_Equal_Ignore_Case(s->name, node->selected.selector) &&
                    s->visibility >= VIS_IMMEDIATELY_VISIBLE) {
                    node->symbol = s;
                    node->type = s->type;
                    return node->type;
                }
            }
        }
    }

    return sm->type_integer;  /* Error recovery */
}

/* Get the operator name string for a token kind */
static String_Slice Operator_Name(Token_Kind op) {
    switch (op) {
        case TK_PLUS:      return S("\"+\"");
        case TK_MINUS:     return S("\"-\"");
        case TK_STAR:      return S("\"*\"");
        case TK_SLASH:     return S("\"/\"");
        case TK_MOD:       return S("\"mod\"");
        case TK_REM:       return S("\"rem\"");
        case TK_EXPON:     return S("\"**\"");
        case TK_AMPERSAND: return S("\"&\"");
        case TK_AND:       return S("\"and\"");
        case TK_OR:        return S("\"or\"");
        case TK_XOR:       return S("\"xor\"");
        case TK_EQ:        return S("\"=\"");
        case TK_NE:        return S("\"/=\"");
        case TK_LT:        return S("\"<\"");
        case TK_LE:        return S("\"<=\"");
        case TK_GT:        return S("\">\"");
        case TK_GE:        return S("\">=\"");
        case TK_NOT:       return S("\"not\"");
        case TK_ABS:       return S("\"abs\"");
        default:           return S("");
    }
}

/* Resolve a character literal as an enumeration literal given a context type.
 * Used for comparisons and assignments where a character literal should be
 * interpreted as an enumeration value. Returns true if resolved. */
static bool Resolve_Char_As_Enum(Symbol_Manager *sm, Syntax_Node *char_node, Type_Info *enum_type) {
    if (!char_node || char_node->kind != NK_CHARACTER || !enum_type)
        return false;
    /* Find base enumeration type by following both parent_type and base_type chains.
     * parent_type is used for derived types (TYPE T IS NEW X)
     * base_type is used for constrained subtypes (SUBTYPE S IS X RANGE ...) */
    Type_Info *base_enum = enum_type;
    while (base_enum) {
        if (base_enum->parent_type)
            base_enum = base_enum->parent_type;
        else if (base_enum->base_type)
            base_enum = base_enum->base_type;
        else
            break;
    }
    if (!base_enum || base_enum->kind != TYPE_ENUMERATION || !base_enum->enumeration.literals)
        return false;
    /* Get the character from the literal (format: 'X') */
    String_Slice lit_text = char_node->string_val.text;
    char ch = lit_text.length >= 2 ? lit_text.data[1] : 0;
    /* Look for matching character literal in enum */
    for (uint32_t j = 0; j < base_enum->enumeration.literal_count; j++) {
        String_Slice lit_name = base_enum->enumeration.literals[j];
        if (lit_name.length == 3 &&
            lit_name.data[0] == '\'' &&
            lit_name.data[1] == ch &&
            lit_name.data[2] == '\'') {
            /* Found matching enum literal - find symbol with matching type */
            Symbol *lit_sym = Symbol_Find_By_Type(sm, lit_name, base_enum);
            if (lit_sym && lit_sym->kind == SYMBOL_LITERAL) {
                char_node->symbol = lit_sym;
                char_node->type = enum_type;
                return true;
            }
        }
    }
    return false;
}

static Type_Info *Resolve_Binary_Op(Symbol_Manager *sm, Syntax_Node *node) {
    Type_Info *left_type = Resolve_Expression(sm, node->binary.left);
    Type_Info *right_type = Resolve_Expression(sm, node->binary.right);

    Token_Kind op = node->binary.op;

    /*
     * Per RM 4.5: Binary operators can be user-defined. We first check for
     * user-defined operators, then fall back to predefined semantics.
     *
     * User-defined operators are functions with designator names like "+" that
     * take two parameters of the appropriate types.
     */

    /* Try to find a user-defined operator */
    String_Slice op_name = Operator_Name(op);
    if (op_name.length > 0) {
        Type_Info *arg_types[2] = { left_type, right_type };
        Argument_Info args = {
            .types = arg_types,
            .count = 2,
            .names = NULL
        };

        Symbol *user_op = Resolve_Overloaded_Call(sm, op_name, &args, NULL);
        if (user_op && user_op->kind == SYMBOL_FUNCTION) {
            node->symbol = user_op;
            node->type = user_op->return_type;
            return node->type;
        }
    }

    /* Fall back to predefined operator semantics */
    switch (op) {
        case TK_PLUS: case TK_MINUS: case TK_STAR: case TK_SLASH:
        case TK_MOD: case TK_REM: case TK_EXPON:
            /* Numeric operators */
            if (!Type_Is_Numeric(left_type) || !Type_Is_Numeric(right_type)) {
                Report_Error(node->location, "numeric operands required for %s",
                            Token_Name[op]);
            }
            /* Result type determination (RM 4.5.5):
             * - Mixed real/integer: result is the real type (real "wins")
             * - Same class: prefer non-universal type
             * - Both universal: keep universal (propagates to context) */
            if (Type_Is_Real(left_type) && !Type_Is_Real(right_type)) {
                /* Left is real, right is integer -> result is left (real) */
                node->type = left_type;
            } else if (Type_Is_Real(right_type) && !Type_Is_Real(left_type)) {
                /* Right is real, left is integer -> result is right (real) */
                node->type = right_type;
            } else if (Type_Is_Universal(left_type) && !Type_Is_Universal(right_type)) {
                node->type = right_type;
            } else if (!Type_Is_Universal(left_type)) {
                node->type = left_type;
            } else {
                /* Both universal - result is universal */
                node->type = left_type;
            }
            break;

        case TK_AMPERSAND:
            /* String/array/character concatenation (RM 4.5.3).
             * Valid operand combinations:
             *   STRING & STRING -> STRING
             *   STRING & CHARACTER -> STRING
             *   CHARACTER & STRING -> STRING
             *   CHARACTER & CHARACTER -> STRING
             *   ARRAY & ARRAY -> ARRAY (same element type)
             *   ARRAY & ELEMENT -> ARRAY
             *   ELEMENT & ARRAY -> ARRAY */
            {
                bool left_ok = left_type && (left_type->kind == TYPE_STRING ||
                               left_type->kind == TYPE_ARRAY ||
                               left_type->kind == TYPE_CHARACTER);
                bool right_ok = right_type && (right_type->kind == TYPE_STRING ||
                                right_type->kind == TYPE_ARRAY ||
                                right_type->kind == TYPE_CHARACTER);
                if (!left_ok && !right_ok) {
                    Report_Error(node->location, "concatenation requires string, array, or character");
                }
                /* Propagate type to aggregate operands (RM 4.3):
                 * In A & (1, 2), the aggregate gets its type from A */
                if (node->binary.right->kind == NK_AGGREGATE && !node->binary.right->type && left_type) {
                    node->binary.right->type = left_type;
                    Resolve_Expression(sm, node->binary.right);
                }
                if (node->binary.left->kind == NK_AGGREGATE && !node->binary.left->type && right_type) {
                    node->binary.left->type = right_type;
                    Resolve_Expression(sm, node->binary.left);
                }
                /* Result type: prefer string/array type over character */
                if (left_type && left_type->kind == TYPE_STRING) {
                    node->type = left_type;
                } else if (right_type && right_type->kind == TYPE_STRING) {
                    node->type = right_type;
                } else if (left_type && left_type->kind == TYPE_ARRAY) {
                    node->type = left_type;
                } else if (right_type && right_type->kind == TYPE_ARRAY) {
                    node->type = right_type;
                } else {
                    /* CHARACTER & CHARACTER -> STRING */
                    node->type = sm->type_string;
                }
            }
            break;

        case TK_AND: case TK_OR: case TK_XOR:
        case TK_AND_THEN: case TK_OR_ELSE:
            /* Boolean operators - can also operate on arrays of Boolean */
            if (left_type && left_type->kind != TYPE_BOOLEAN) {
                if (left_type->kind != TYPE_ARRAY ||
                    !left_type->array.element_type ||
                    left_type->array.element_type->kind != TYPE_BOOLEAN) {
                    Report_Error(node->location, "Boolean operands required");
                }
            }
            node->type = left_type ? left_type : sm->type_boolean;
            break;

        case TK_EQ: case TK_NE: case TK_LT: case TK_LE: case TK_GT: case TK_GE:
            /* Comparison operators */
            /* Handle aggregates without type context (RM 4.3):
             * In A = (1, 2, 3), the aggregate gets its type from A.
             * Per GNAT sem_res.adb Find_Unique_Type, propagate type context. */
            if (node->binary.right->kind == NK_AGGREGATE && !node->binary.right->type && left_type) {
                /* Propagate type from left operand to aggregate */
                node->binary.right->type = left_type;
                /* Re-resolve aggregate with proper type context */
                Resolve_Expression(sm, node->binary.right);
                right_type = node->binary.right->type;
            }
            if (node->binary.left->kind == NK_AGGREGATE && !node->binary.left->type && right_type) {
                /* Propagate type from right operand to aggregate */
                node->binary.left->type = right_type;
                /* Re-resolve aggregate with proper type context */
                Resolve_Expression(sm, node->binary.left);
                left_type = node->binary.left->type;
            }
            /* Handle character literals that should be enum literals */
            if (left_type && (left_type->kind == TYPE_ENUMERATION ||
                (left_type->parent_type && left_type->parent_type->kind == TYPE_ENUMERATION))) {
                if (node->binary.right->kind == NK_CHARACTER) {
                    if (Resolve_Char_As_Enum(sm, node->binary.right, left_type)) {
                        right_type = node->binary.right->type;
                    }
                }
            }
            if (right_type && (right_type->kind == TYPE_ENUMERATION ||
                (right_type->parent_type && right_type->parent_type->kind == TYPE_ENUMERATION))) {
                if (node->binary.left->kind == NK_CHARACTER) {
                    if (Resolve_Char_As_Enum(sm, node->binary.left, right_type)) {
                        left_type = node->binary.left->type;
                    }
                }
            }
            if (!Type_Covers(left_type, right_type) && !Type_Covers(right_type, left_type)) {
                Report_Error(node->location, "incompatible types for comparison");
            }
            node->type = sm->type_boolean;
            break;

        case TK_IN:
        case TK_NOT:  /* NOT IN is encoded as TK_NOT in binary op */
            /* Membership test */
            node->type = sm->type_boolean;
            break;

        default:
            node->type = sm->type_integer;
    }

    return node->type;
}

static Type_Info *Resolve_Apply(Symbol_Manager *sm, Syntax_Node *node) {
    /*
     * Apply node resolution - handles multiple Ada constructs:
     * 1. Function/procedure calls: Put(X), Process(A, B)
     * 2. Array indexing: Arr(I), Matrix(I, J)
     * 3. Type conversions: Integer(X), Float(Y)
     * 4. Constrained subtype indications: String(1..10)
     *
     * For calls, we use the overload resolution engine to handle:
     * - Overloaded subprogram names
     * - Named parameter associations
     * - Default parameter values
     */

    /* First, resolve all arguments to get their types */
    uint32_t arg_count = (uint32_t)node->apply.arguments.count;
    Type_Info **arg_types = NULL;
    String_Slice *arg_names = NULL;

    if (arg_count > 0) {
        arg_types = Arena_Allocate(arg_count * sizeof(Type_Info*));
        arg_names = Arena_Allocate(arg_count * sizeof(String_Slice));

        for (uint32_t i = 0; i < arg_count; i++) {
            Syntax_Node *arg = node->apply.arguments.items[i];

            /* Handle named associations: Name => Value */
            if (arg->kind == NK_ASSOCIATION && arg->association.choices.count == 1) {
                Syntax_Node *name_node = arg->association.choices.items[0];
                if (name_node->kind == NK_IDENTIFIER) {
                    arg_names[i] = name_node->string_val.text;
                }
                /* Resolve the value expression */
                if (arg->association.expression) {
                    arg_types[i] = Resolve_Expression(sm, arg->association.expression);
                }
            } else {
                arg_names[i] = (String_Slice){0};  /* Positional */
                arg_types[i] = Resolve_Expression(sm, arg);
            }
        }
    }

    Argument_Info args = {
        .types = arg_types,
        .count = arg_count,
        .names = arg_names
    };

    /* Resolve the prefix */
    Syntax_Node *prefix = node->apply.prefix;
    Symbol *prefix_sym = NULL;

    /* For identifier prefix, use overload resolution */
    if (prefix->kind == NK_IDENTIFIER) {
        prefix_sym = Resolve_Overloaded_Call(sm, prefix->string_val.text, &args, NULL);
        if (prefix_sym) {
            prefix->symbol = prefix_sym;
            prefix->type = (prefix_sym->kind == SYMBOL_FUNCTION) ?
                           prefix_sym->return_type : prefix_sym->type;
        } else {
            /* Fall back to simple lookup for non-callable names */
            prefix_sym = Symbol_Find(sm, prefix->string_val.text);
            if (prefix_sym) {
                prefix->symbol = prefix_sym;
                prefix->type = prefix_sym->type;
            }
        }
    } else {
        /* For complex prefix (selected, etc.), resolve normally */
        Resolve_Expression(sm, prefix);
        prefix_sym = prefix->symbol;
    }

    Type_Info *prefix_type = prefix->type;

    /* Handle based on what the prefix resolves to */
    if (prefix_sym) {
        
        /* ─── Case 1: Function/Procedure Call ─── */
        if (prefix_sym->kind == SYMBOL_FUNCTION || prefix_sym->kind == SYMBOL_PROCEDURE) {
            node->symbol = prefix_sym;
            node->type = prefix_sym->return_type;  /* NULL for procedures */
            /* Re-resolve arguments based on parameter types.
             * This handles:
             * - Character literals like FN('A') where 'A' must be resolved as
             *   the enumeration literal for the parameter's type, not ASCII.
             * - Aggregates like FN((1,2,3)) where the aggregate needs the
             *   parameter type to determine its type (RM 4.3). */
            for (uint32_t i = 0; i < arg_count && i < prefix_sym->parameter_count; i++) {
                Syntax_Node *arg = node->apply.arguments.items[i];
                /* Handle named associations */
                if (arg->kind == NK_ASSOCIATION && arg->association.expression) {
                    arg = arg->association.expression;
                }
                Type_Info *param_type = prefix_sym->parameters[i].param_type;
                if (arg->kind == NK_CHARACTER) {
                    Resolve_Char_As_Enum(sm, arg, param_type);
                }
                /* Propagate type to aggregate arguments */
                if (arg->kind == NK_AGGREGATE && !arg->type && param_type) {
                    arg->type = param_type;
                    Resolve_Expression(sm, arg);
                }
            }
            return node->type;
        }

        /* ─── Case 2: Type Conversion or Constrained Subtype ─── */
        if (prefix_sym->kind == SYMBOL_TYPE || prefix_sym->kind == SYMBOL_SUBTYPE) {
            Type_Info *base_type = prefix_sym->type;

            /* Check for constrained subtype indication: STRING(1..5) */
            if (Type_Is_Array_Like(base_type)) {
                /* Check if arguments are ranges (subtype indication) vs values (indexing) */
                bool has_range = false;
                for (uint32_t i = 0; i < arg_count; i++) {
                    Syntax_Node *arg = node->apply.arguments.items[i];
                    if (arg->kind == NK_RANGE) {
                        has_range = true;
                        break;
                    }
                }

                if (has_range) {
                    /* Constrained array/string subtype indication */
                    Type_Info *constrained = Type_New(TYPE_ARRAY, base_type->name);
                    constrained->array.is_constrained = true;
                    constrained->array.index_count = arg_count;

                    /* Element type */
                    if (base_type->kind == TYPE_STRING) {
                        constrained->array.element_type = sm->type_character;
                    } else if (base_type->array.element_type) {
                        constrained->array.element_type = base_type->array.element_type;
                    }

                    /* Process index constraints */
                    if (arg_count > 0) {
                        constrained->array.indices = Arena_Allocate(
                            arg_count * sizeof(Index_Info));

                        for (uint32_t i = 0; i < arg_count; i++) {
                            Syntax_Node *arg = node->apply.arguments.items[i];
                            Index_Info *info = &constrained->array.indices[i];
                            info->index_type = sm->type_integer;

                            if (arg->kind == NK_RANGE) {
                                if (arg->range.low && arg->range.low->kind == NK_INTEGER) {
                                    info->low_bound = (Type_Bound){
                                        .kind = BOUND_INTEGER,
                                        .int_value = arg->range.low->integer_lit.value
                                    };
                                }
                                if (arg->range.high && arg->range.high->kind == NK_INTEGER) {
                                    info->high_bound = (Type_Bound){
                                        .kind = BOUND_INTEGER,
                                        .int_value = arg->range.high->integer_lit.value
                                    };
                                }
                            }
                        }

                        /* Compute size */
                        int64_t count = 1;
                        for (uint32_t i = 0; i < arg_count; i++) {
                            int64_t lo = Type_Bound_Value(constrained->array.indices[i].low_bound);
                            int64_t hi = Type_Bound_Value(constrained->array.indices[i].high_bound);
                            count *= (hi - lo + 1);
                        }
                        uint32_t elem_size = constrained->array.element_type ?
                                             constrained->array.element_type->size : 1;
                        constrained->size = (uint32_t)(count * elem_size);
                    }

                    node->type = constrained;
                    return constrained;
                }
            }

            /* Regular type conversion: Integer(X) */
            if (arg_count == 1) {
                node->type = prefix_sym->type;
                return node->type;
            }
        }
    }

    /* ─── Case 2b: Predefined operator called via string syntax ─── */
    /* Ada allows "+"(X, Y) or "&"(A, B) as equivalent to X + Y or A & B.
     * Handle predefined operators that don't have explicit symbol entries.
     * Note: The lexer strips quotes from operator strings, so "&" becomes just &. */
    if (!prefix_sym && prefix->kind == NK_IDENTIFIER) {
        String_Slice name = prefix->string_val.text;
        /* Check for single-character operators (lexer stripped quotes) */
        if (name.length == 1 && arg_count == 2) {
            char op_char = name.data[0];
            if (op_char == '&') {
                /* "&"(A, B) is array/string concatenation */
                Syntax_Node *left = node->apply.arguments.items[0];
                Syntax_Node *right = node->apply.arguments.items[1];
                Type_Info *left_type = Resolve_Expression(sm, left);
                Type_Info *right_type = Resolve_Expression(sm, right);
                /* Result is the array type (prefer left if array, else right) */
                if (left_type && Type_Is_Array_Like(left_type)) {
                    node->type = left_type;
                } else if (right_type && Type_Is_Array_Like(right_type)) {
                    node->type = right_type;
                } else if (left_type && left_type->kind == TYPE_STRING) {
                    node->type = left_type;
                } else if (right_type && right_type->kind == TYPE_STRING) {
                    node->type = right_type;
                } else {
                    node->type = sm->type_string;  /* Default for character concat */
                }
                return node->type;
            }
            /* Handle arithmetic operators */
            if (op_char == '+' || op_char == '-' || op_char == '*' || op_char == '/') {
                Syntax_Node *left = node->apply.arguments.items[0];
                Syntax_Node *right = node->apply.arguments.items[1];
                Type_Info *left_type = Resolve_Expression(sm, left);
                Type_Info *right_type = Resolve_Expression(sm, right);
                /* Result is the numeric type (prefer left) */
                node->type = left_type ? left_type : right_type;
                return node->type;
            }
        }
        /* Check for two-character operators like <=, >=, /=, ** */
        if (name.length == 2 && arg_count == 2) {
            if ((name.data[0] == '<' && name.data[1] == '=') ||
                (name.data[0] == '>' && name.data[1] == '=') ||
                (name.data[0] == '/' && name.data[1] == '=')) {
                /* Comparison operators return BOOLEAN */
                Syntax_Node *left = node->apply.arguments.items[0];
                Syntax_Node *right = node->apply.arguments.items[1];
                Resolve_Expression(sm, left);
                Resolve_Expression(sm, right);
                node->type = sm->type_boolean;
                return node->type;
            }
            if (name.data[0] == '*' && name.data[1] == '*') {
                /* Exponentiation */
                Syntax_Node *left = node->apply.arguments.items[0];
                Syntax_Node *right = node->apply.arguments.items[1];
                Type_Info *left_type = Resolve_Expression(sm, left);
                Resolve_Expression(sm, right);
                node->type = left_type;
                return node->type;
            }
        }
        /* Unary operators with one argument */
        if (name.length == 1 && arg_count == 1) {
            char op_char = name.data[0];
            if (op_char == '+' || op_char == '-') {
                Syntax_Node *operand = node->apply.arguments.items[0];
                node->type = Resolve_Expression(sm, operand);
                return node->type;
            }
        }
    }

    /* ─── Case 3: Array Indexing/Slicing (with implicit access dereference) ─── */
    /* Per RM 4.1(3), A(I) where A is access-to-array is equivalent to A.ALL(I) */
    Type_Info *indexed_type = prefix_type;
    if (prefix_type && prefix_type->kind == TYPE_ACCESS && prefix_type->access.designated_type) {
        indexed_type = prefix_type->access.designated_type;  /* Implicit dereference */
    }
    if (Type_Is_Array_Like(indexed_type)) {
        /* Check if this is a slice (range argument) vs indexing (scalar argument) */
        bool is_slice = false;
        for (uint32_t i = 0; i < arg_count; i++) {
            Syntax_Node *arg = node->apply.arguments.items[i];
            if (arg && arg->kind == NK_RANGE) {
                is_slice = true;
                break;
            }
        }

        if (is_slice) {
            /* Slice: result type is the same array/string type */
            node->type = indexed_type;
        } else {
            /* Indexing: result type is the element type */
            node->type = indexed_type->array.element_type;
            if (!node->type && indexed_type->kind == TYPE_STRING) {
                node->type = sm->type_character;
            }
        }
        return node->type;
    }

    /* ─── Case 4: Unresolved - report error and recover ─── */
    if (prefix->kind == NK_IDENTIFIER) {
        Report_Error(node->location, "cannot resolve '%.*s' as callable or indexable",
                    (int)prefix->string_val.text.length, prefix->string_val.text.data);
    }

    return sm->type_integer;  /* Error recovery */
}

/* ─────────────────────────────────────────────────────────────────────────
 * Evaluate Constant Numeric Expression (for delta, bounds in type defs)
 * Returns NaN if not a static constant expression
 * ───────────────────────────────────────────────────────────────────────── */
static bool Is_Integer_Expr(Syntax_Node *n);  /* Forward declaration */

static bool Is_Integer_Expr(Syntax_Node *n) {
    /* Returns true if the expression is integer-typed (for division semantics) */
    if (!n) return false;
    switch (n->kind) {
        case NK_INTEGER: return true;
        case NK_REAL:    return false;
        case NK_IDENTIFIER:
        case NK_SELECTED: {
            /* Check if named number/constant is integer */
            Symbol *sym = n->symbol;
            if (sym && sym->kind == SYMBOL_CONSTANT && sym->is_named_number &&
                sym->declaration && sym->declaration->kind == NK_OBJECT_DECL) {
                return Is_Integer_Expr(sym->declaration->object_decl.init);
            }
            /* Check type if available */
            if (n->type && n->type->kind == TYPE_INTEGER) return true;
            return false;
        }
        case NK_UNARY_OP:
            return Is_Integer_Expr(n->unary.operand);
        case NK_BINARY_OP:
            return Is_Integer_Expr(n->binary.left) && Is_Integer_Expr(n->binary.right);
        case NK_APPLY:
            /* For type conversions TYPE(arg), check if arg is integer */
            if (n->apply.arguments.count == 1 &&
                n->apply.prefix && n->apply.prefix->symbol &&
                n->apply.prefix->symbol->kind == SYMBOL_TYPE) {
                return Is_Integer_Expr(n->apply.arguments.items[0]);
            }
            return false;
        default:
            return false;
    }
}

static double Eval_Const_Numeric(Syntax_Node *n) {
    if (!n) return 0.0/0.0;
    switch (n->kind) {
        case NK_REAL:    return n->real_lit.value;
        case NK_INTEGER: return (double)n->integer_lit.value;
        case NK_CHARACTER:
            /* Character literals have position value in symbol->frame_offset */
            if (n->symbol && n->symbol->kind == SYMBOL_LITERAL) {
                return (double)n->symbol->frame_offset;
            }
            /* Fallback: use ASCII code - character literals store their value in string_val.text */
            /* Format is 'X' (length 3) - extract the middle character at index 1 */
            if (n->string_val.text.length >= 2) {
                return (double)(unsigned char)n->string_val.text.data[1];
            }
            if (n->string_val.text.length == 1) {
                return (double)(unsigned char)n->string_val.text.data[0];
            }
            return 0.0/0.0;
        case NK_IDENTIFIER:
        case NK_SELECTED: {
            /* Check for character/enum literal first */
            Symbol *sym = n->symbol;
            if (sym && sym->kind == SYMBOL_LITERAL) {
                return (double)sym->frame_offset;
            }
            /* Named number or constant - evaluate via symbol's declaration */
            if (sym && sym->kind == SYMBOL_CONSTANT && sym->is_named_number &&
                sym->declaration && sym->declaration->kind == NK_OBJECT_DECL) {
                return Eval_Const_Numeric(sym->declaration->object_decl.init);
            }
            return 0.0/0.0;
        }
        case NK_QUALIFIED:
            /* Qualified expression: TYPE'(expr) - evaluate the inner expression */
            if (n->qualified.expression) {
                Syntax_Node *inner = n->qualified.expression;
                /* Handle character literal inside qualified expression:
                 * look up in the qualifying type's enumeration literals */
                if (inner->kind == NK_CHARACTER && n->qualified.subtype_mark &&
                    n->qualified.subtype_mark->type) {
                    Type_Info *qual_type = n->qualified.subtype_mark->type;
                    /* Walk up to find the base enumeration type with literals */
                    while (qual_type && qual_type->kind == TYPE_ENUMERATION &&
                           !qual_type->enumeration.literals) {
                        qual_type = qual_type->base_type ? qual_type->base_type : qual_type->parent_type;
                    }
                    if (qual_type && qual_type->kind == TYPE_ENUMERATION &&
                        qual_type->enumeration.literals) {
                        /* Extract the character from 'X' format */
                        String_Slice lit_text = inner->string_val.text;
                        char ch = lit_text.length >= 2 ? lit_text.data[1] : 0;
                        /* Look for matching character literal in enum */
                        for (uint32_t j = 0; j < qual_type->enumeration.literal_count; j++) {
                            String_Slice lit_name = qual_type->enumeration.literals[j];
                            if (lit_name.length == 3 &&
                                lit_name.data[0] == '\'' &&
                                lit_name.data[1] == ch &&
                                lit_name.data[2] == '\'') {
                                return (double)j;  /* Position in enumeration */
                            }
                        }
                    }
                }
                return Eval_Const_Numeric(inner);
            }
            return 0.0/0.0;
        case NK_APPLY: {
            /* Type conversions: TYPE_NAME(expr) - evaluate the argument */
            if (n->apply.prefix && n->apply.arguments.count == 1) {
                Syntax_Node *arg = n->apply.arguments.items[0];
                Syntax_Node *prefix = n->apply.prefix;
                if (prefix->kind == NK_IDENTIFIER && prefix->symbol &&
                    prefix->symbol->kind == SYMBOL_TYPE) {
                    return Eval_Const_Numeric(arg);
                }
            }
            return 0.0/0.0;
        }
        case NK_UNARY_OP:
            if (n->unary.op == TK_MINUS) return -Eval_Const_Numeric(n->unary.operand);
            if (n->unary.op == TK_PLUS)  return Eval_Const_Numeric(n->unary.operand);
            return 0.0/0.0;
        case NK_BINARY_OP: {
            double l = Eval_Const_Numeric(n->binary.left);
            double r = Eval_Const_Numeric(n->binary.right);
            switch (n->binary.op) {
                case TK_PLUS:  return l + r;
                case TK_MINUS: return l - r;
                case TK_STAR:  return l * r;
                case TK_SLASH:
                    if (r == 0) return 0.0/0.0;
                    /* Ada integer division truncates toward zero (RM 4.5.5) */
                    /* Only use integer division if BOTH operands are integer-typed */
                    if (Is_Integer_Expr(n->binary.left) && Is_Integer_Expr(n->binary.right) &&
                        l == floor(l) && r == floor(r) &&
                        fabs(l) < 1e15 && fabs(r) < 1e15) {
                        int64_t li = (int64_t)l;
                        int64_t ri = (int64_t)r;
                        return (double)(li / ri);  /* Integer division */
                    }
                    return l / r;
                case TK_EXPON: return pow(l, r);
                default:       return 0.0/0.0;
            }
        }
        default: return 0.0/0.0;
    }
}

static Type_Info *Resolve_Expression(Symbol_Manager *sm, Syntax_Node *node) {
    if (!node) return NULL;

    switch (node->kind) {
        case NK_INTEGER:
            node->type = sm->type_universal_integer;
            return node->type;

        case NK_REAL:
            node->type = sm->type_universal_real;
            return node->type;

        case NK_CHARACTER:
            node->type = sm->type_character;
            return node->type;

        case NK_STRING:
            node->type = sm->type_string;
            return node->type;

        case NK_NULL:
            node->type = NULL;  /* Matches any access type */
            return NULL;

        case NK_IDENTIFIER:
            return Resolve_Identifier(sm, node);

        case NK_SELECTED:
            return Resolve_Selected(sm, node);

        case NK_BINARY_OP:
            return Resolve_Binary_Op(sm, node);

        case NK_UNARY_OP:
            node->type = Resolve_Expression(sm, node->unary.operand);
            if (node->unary.op == TK_NOT) {
                node->type = sm->type_boolean;
            } else if (node->unary.op == TK_ALL) {
                /* .ALL dereference: result is the designated type (RM 4.1) */
                Type_Info *operand_type = node->unary.operand->type;
                if (operand_type && operand_type->kind == TYPE_ACCESS) {
                    node->type = operand_type->access.designated_type;
                }
            }
            return node->type;

        case NK_APPLY:
            return Resolve_Apply(sm, node);

        case NK_ATTRIBUTE:
            Resolve_Expression(sm, node->attribute.prefix);
            /* Resolve attribute arguments with type context for certain attributes */
            {
                Type_Info *prefix_type = node->attribute.prefix->type;
                String_Slice attr = node->attribute.name;

                /* For POS, SUCC, PRED, IMAGE - argument should be of prefix type */
                bool needs_enum_context = prefix_type &&
                    (prefix_type->kind == TYPE_ENUMERATION ||
                     (prefix_type->parent_type &&
                      prefix_type->parent_type->kind == TYPE_ENUMERATION)) &&
                    (Slice_Equal_Ignore_Case(attr, S("POS")) ||
                     Slice_Equal_Ignore_Case(attr, S("SUCC")) ||
                     Slice_Equal_Ignore_Case(attr, S("PRED")) ||
                     Slice_Equal_Ignore_Case(attr, S("IMAGE")));

                for (uint32_t i = 0; i < node->attribute.arguments.count; i++) {
                    Syntax_Node *arg = node->attribute.arguments.items[i];
                    bool resolved_as_enum = false;
                    /* Check if character literal should be resolved as enum literal */
                    if (needs_enum_context && arg && arg->kind == NK_CHARACTER) {
                        /* Get the character from the literal (format: 'X') */
                        String_Slice lit_text = arg->string_val.text;
                        char ch = lit_text.length >= 2 ? lit_text.data[1] : 0;
                        /* Find enum type (handle derived types) */
                        Type_Info *enum_type = prefix_type;
                        while (enum_type && enum_type->parent_type)
                            enum_type = enum_type->parent_type;
                        /* Look for matching character literal in enum */
                        if (enum_type && enum_type->kind == TYPE_ENUMERATION &&
                            enum_type->enumeration.literals) {
                            for (uint32_t j = 0; j < enum_type->enumeration.literal_count; j++) {
                                String_Slice lit_name = enum_type->enumeration.literals[j];
                                if (lit_name.length == 3 &&
                                    lit_name.data[0] == '\'' &&
                                    lit_name.data[1] == ch &&
                                    lit_name.data[2] == '\'') {
                                    /* Found matching enum literal - set symbol with type match */
                                    Symbol *lit_sym = Symbol_Find_By_Type(sm, lit_name, enum_type);
                                    if (lit_sym && lit_sym->kind == SYMBOL_LITERAL) {
                                        arg->symbol = lit_sym;
                                        arg->type = prefix_type;
                                        resolved_as_enum = true;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    /* Only resolve if not already resolved as enum literal */
                    if (!resolved_as_enum) {
                        Resolve_Expression(sm, arg);
                    }
                }
            }
            /* Attribute type depends on attribute name and prefix type */
            {
                Type_Info *prefix_type = node->attribute.prefix->type;
                String_Slice attr = node->attribute.name;

                /* Implicit dereference for access types (RM 4.1(3))
                 * A1'FIRST where A1 is access-to-array is equivalent to A1.ALL'FIRST */
                if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
                    prefix_type->access.designated_type) {
                    prefix_type = prefix_type->access.designated_type;
                }

                /* FIRST, LAST return the index type for arrays, base type for scalars */
                if (Slice_Equal_Ignore_Case(attr, S("FIRST")) ||
                    Slice_Equal_Ignore_Case(attr, S("LAST"))) {
                    if (prefix_type && (prefix_type->kind == TYPE_ARRAY ||
                                       prefix_type->kind == TYPE_STRING)) {
                        /* For arrays, FIRST/LAST return the actual index type for that dimension */
                        uint32_t dim = 0;  /* Default to first dimension (0-indexed) */
                        if (node->attribute.arguments.count > 0) {
                            Syntax_Node *dim_arg = node->attribute.arguments.items[0];
                            if (dim_arg && dim_arg->kind == NK_INTEGER) {
                                dim = (uint32_t)(dim_arg->integer_lit.value - 1);
                            }
                        }
                        /* Get the index type for this dimension */
                        if (prefix_type->kind == TYPE_ARRAY &&
                            prefix_type->array.indices &&
                            dim < prefix_type->array.index_count &&
                            prefix_type->array.indices[dim].index_type) {
                            node->type = prefix_type->array.indices[dim].index_type;
                        } else {
                            /* Default to INTEGER for strings or missing info */
                            node->type = sm->type_integer;
                        }
                    } else {
                        /* For scalar types, return the type itself */
                        node->type = prefix_type ? prefix_type : sm->type_integer;
                    }
                }
                /* VAL, SUCC, PRED return the base type (for scalar types) */
                else if (Slice_Equal_Ignore_Case(attr, S("VAL")) ||
                         Slice_Equal_Ignore_Case(attr, S("SUCC")) ||
                         Slice_Equal_Ignore_Case(attr, S("PRED"))) {
                    node->type = prefix_type ? prefix_type : sm->type_integer;
                }
                /* POS returns universal integer */
                else if (Slice_Equal_Ignore_Case(attr, S("POS"))) {
                    node->type = sm->type_universal_integer;
                }
                /* IMAGE returns STRING */
                else if (Slice_Equal_Ignore_Case(attr, S("IMAGE"))) {
                    node->type = sm->type_string;
                }
                /* SIZE, LENGTH, COUNT, WIDTH, MANTISSA, etc. return universal integer */
                else if (Slice_Equal_Ignore_Case(attr, S("SIZE")) ||
                         Slice_Equal_Ignore_Case(attr, S("LENGTH")) ||
                         Slice_Equal_Ignore_Case(attr, S("COUNT")) ||
                         Slice_Equal_Ignore_Case(attr, S("WIDTH")) ||
                         Slice_Equal_Ignore_Case(attr, S("MANTISSA")) ||
                         Slice_Equal_Ignore_Case(attr, S("MACHINE_MANTISSA")) ||
                         Slice_Equal_Ignore_Case(attr, S("DIGITS")) ||
                         Slice_Equal_Ignore_Case(attr, S("EMAX")) ||
                         Slice_Equal_Ignore_Case(attr, S("MACHINE_EMAX")) ||
                         Slice_Equal_Ignore_Case(attr, S("MACHINE_EMIN")) ||
                         Slice_Equal_Ignore_Case(attr, S("MACHINE_RADIX")) ||
                         Slice_Equal_Ignore_Case(attr, S("SAFE_EMAX")) ||
                         Slice_Equal_Ignore_Case(attr, S("STORAGE_SIZE")) ||
                         Slice_Equal_Ignore_Case(attr, S("MODULUS")) ||
                         Slice_Equal_Ignore_Case(attr, S("AFT")) ||
                         Slice_Equal_Ignore_Case(attr, S("FORE"))) {
                    node->type = sm->type_universal_integer;
                }
                /* Floating-point type attributes returning universal_real (RM 3.5.8) */
                else if (Slice_Equal_Ignore_Case(attr, S("EPSILON")) ||
                         Slice_Equal_Ignore_Case(attr, S("SMALL")) ||
                         Slice_Equal_Ignore_Case(attr, S("LARGE")) ||
                         Slice_Equal_Ignore_Case(attr, S("SAFE_SMALL")) ||
                         Slice_Equal_Ignore_Case(attr, S("SAFE_LARGE")) ||
                         Slice_Equal_Ignore_Case(attr, S("DELTA")) ||
                         Slice_Equal_Ignore_Case(attr, S("MODEL_EPSILON")) ||
                         Slice_Equal_Ignore_Case(attr, S("MODEL_SMALL"))) {
                    node->type = sm->type_universal_real;
                }
                /* Boolean attributes (RM 3.5.8, 3.7.1, 9.9) */
                else if (Slice_Equal_Ignore_Case(attr, S("MACHINE_OVERFLOWS")) ||
                         Slice_Equal_Ignore_Case(attr, S("MACHINE_ROUNDS")) ||
                         Slice_Equal_Ignore_Case(attr, S("CONSTRAINED")) ||
                         Slice_Equal_Ignore_Case(attr, S("CALLABLE")) ||
                         Slice_Equal_Ignore_Case(attr, S("TERMINATED"))) {
                    node->type = sm->type_boolean;
                }
                /* ADDRESS attribute returns SYSTEM.ADDRESS (RM 13.7.2) */
                else if (Slice_Equal_Ignore_Case(attr, S("ADDRESS"))) {
                    node->type = sm->type_address;
                }
                /* BASE attribute returns the base type (RM 3.3.2) */
                else if (Slice_Equal_Ignore_Case(attr, S("BASE"))) {
                    /* T'BASE is a type, used as prefix for other attributes like T'BASE'FIRST
                     * The type should be the base type of the prefix type.
                     * For derived types (TYPE T IS NEW X), follow parent_type chain.
                     * For constrained subtypes (SUBTYPE S IS X RANGE ...), follow base_type chain.
                     * Use Type_Root to handle both cases and find the root type. */
                    if (prefix_type) {
                        Type_Info *base = Type_Root(prefix_type);
                        node->type = base ? base : prefix_type;
                    } else {
                        node->type = sm->type_integer;
                    }
                }
                /* VALUE attribute returns the type itself (converts string to type) */
                else if (Slice_Equal_Ignore_Case(attr, S("VALUE"))) {
                    /* T'VALUE(S) returns a value of type T */
                    node->type = prefix_type ? prefix_type : sm->type_integer;
                }
                /* Default to integer for unhandled attributes */
                else {
                    node->type = sm->type_integer;
                }
            }
            return node->type;

        case NK_QUALIFIED:
            /* Resolve subtype mark first to get the type */
            Resolve_Expression(sm, node->qualified.subtype_mark);
            /* Propagate type to expression (critical for aggregates) */
            if (node->qualified.expression &&
                node->qualified.expression->kind == NK_AGGREGATE &&
                node->qualified.subtype_mark->type) {
                node->qualified.expression->type = node->qualified.subtype_mark->type;
            }
            Resolve_Expression(sm, node->qualified.expression);
            node->type = node->qualified.subtype_mark->type;
            return node->type;

        case NK_AGGREGATE:
            {
                Type_Info *agg_type = node->type;
                bool is_record_agg = agg_type && agg_type->kind == TYPE_RECORD;
                uint32_t positional_idx = 0;

                for (uint32_t i = 0; i < node->aggregate.items.count; i++) {
                    Syntax_Node *item = node->aggregate.items.items[i];

                    if (is_record_agg && item->kind == NK_ASSOCIATION) {
                        /* For record aggregates, choices are field names - don't resolve as variables */
                        /* Find component type from first choice for nested aggregates */
                        Type_Info *comp_type = NULL;
                        if (item->association.choices.count > 0) {
                            Syntax_Node *choice = item->association.choices.items[0];
                            if (choice->kind == NK_IDENTIFIER) {
                                String_Slice comp_name = choice->string_val.text;
                                for (uint32_t j = 0; j < agg_type->record.component_count; j++) {
                                    if (Slice_Equal_Ignore_Case(agg_type->record.components[j].name, comp_name)) {
                                        comp_type = agg_type->record.components[j].component_type;
                                        break;
                                    }
                                }
                            }
                        }
                        /* Propagate component type to nested aggregates */
                        if (item->association.expression) {
                            if (item->association.expression->kind == NK_AGGREGATE && comp_type) {
                                item->association.expression->type = comp_type;
                            }
                            Resolve_Expression(sm, item->association.expression);
                        }
                    } else if (is_record_agg) {
                        /* Positional item in record aggregate - propagate component type */
                        if (positional_idx < agg_type->record.component_count) {
                            Type_Info *comp_type = agg_type->record.components[positional_idx].component_type;
                            if (item->kind == NK_AGGREGATE && comp_type) {
                                item->type = comp_type;
                            }
                            positional_idx++;
                        }
                        Resolve_Expression(sm, item);
                    } else {
                        /* For array aggregates, propagate element type to nested aggregates */
                        Type_Info *elem_type = NULL;
                        if (agg_type && agg_type->kind == TYPE_ARRAY && agg_type->array.element_type) {
                            elem_type = agg_type->array.element_type;
                        }
                        if (elem_type && item->kind == NK_ASSOCIATION && item->association.expression) {
                            Syntax_Node *expr = item->association.expression;
                            if (expr->kind == NK_AGGREGATE) {
                                expr->type = elem_type;
                            }
                        } else if (elem_type && item->kind == NK_AGGREGATE) {
                            item->type = elem_type;
                        }
                        Resolve_Expression(sm, item);
                    }
                }
                return node->type;  /* Type from context */
            }

        case NK_ALLOCATOR:
            /* Resolve subtype mark first to get allocated type */
            Resolve_Expression(sm, node->allocator.subtype_mark);
            if (node->allocator.expression) {
                /* Propagate type to initializer (critical for aggregates).
                 * Parser destructures T'(agg) so expression is directly the aggregate */
                if (node->allocator.expression->kind == NK_AGGREGATE &&
                    node->allocator.subtype_mark &&
                    node->allocator.subtype_mark->type) {
                    node->allocator.expression->type = node->allocator.subtype_mark->type;
                }
                Resolve_Expression(sm, node->allocator.expression);
            }
            /* Create access type pointing to allocated type */
            {
                Type_Info *access_type = Type_New(TYPE_ACCESS, S(""));
                access_type->size = 8;
                access_type->alignment = 8;
                if (node->allocator.subtype_mark && node->allocator.subtype_mark->type) {
                    access_type->access.designated_type = node->allocator.subtype_mark->type;
                }
                node->type = access_type;
            }
            return node->type;

        case NK_RANGE:
            if (node->range.low) Resolve_Expression(sm, node->range.low);
            if (node->range.high) Resolve_Expression(sm, node->range.high);
            node->type = node->range.low ? node->range.low->type : NULL;
            return node->type;

        case NK_ASSOCIATION:
            for (uint32_t i = 0; i < node->association.choices.count; i++) {
                Resolve_Expression(sm, node->association.choices.items[i]);
            }
            if (node->association.expression) {
                /* For case alternatives, expression is a block with statements */
                if (node->association.expression->kind == NK_BLOCK) {
                    Resolve_Statement(sm, node->association.expression);
                } else {
                    Resolve_Expression(sm, node->association.expression);
                }
            }
            return node->association.expression ? node->association.expression->type : NULL;

        case NK_ARRAY_TYPE:
            {
                /* Create array type info from syntax node */
                Type_Info *array_type = Type_New(TYPE_ARRAY, S(""));
                array_type->array.is_constrained = node->array_type.is_constrained;
                array_type->array.index_count = (uint32_t)node->array_type.indices.count;

                /* Allocate index info */
                if (array_type->array.index_count > 0) {
                    array_type->array.indices = Arena_Allocate(
                        array_type->array.index_count * sizeof(Index_Info));

                    for (uint32_t i = 0; i < array_type->array.index_count; i++) {
                        Syntax_Node *idx = node->array_type.indices.items[i];
                        Resolve_Expression(sm, idx);

                        Index_Info *info = &array_type->array.indices[i];
                        info->index_type = sm->type_integer;

                        /* Extract bounds from range or subtype indication */
                        Syntax_Node *range_node = NULL;
                        if (idx->kind == NK_RANGE) {
                            range_node = idx;
                            /* Infer index type from range bounds' type */
                            if (idx->range.low && idx->range.low->type) {
                                info->index_type = idx->range.low->type;
                            } else if (idx->range.high && idx->range.high->type) {
                                info->index_type = idx->range.high->type;
                            }
                        } else if (idx->kind == NK_SUBTYPE_INDICATION &&
                                   idx->subtype_ind.constraint &&
                                   idx->subtype_ind.constraint->kind == NK_RANGE_CONSTRAINT) {
                            range_node = idx->subtype_ind.constraint->range_constraint.range;
                            /* Also use the subtype mark's type for index type */
                            if (idx->subtype_ind.subtype_mark && idx->subtype_ind.subtype_mark->type) {
                                info->index_type = idx->subtype_ind.subtype_mark->type;
                            }
                        } else if (idx->kind == NK_SUBTYPE_INDICATION &&
                                   idx->subtype_ind.subtype_mark &&
                                   idx->subtype_ind.subtype_mark->type) {
                            /* Unconstrained index type (just a type mark, no constraint) */
                            info->index_type = idx->subtype_ind.subtype_mark->type;
                        } else if (idx->type) {
                            /* Use resolved type from identifier/expression (e.g., BOOLEAN) */
                            info->index_type = idx->type;
                        }
                        if (range_node && range_node->kind == NK_RANGE &&
                            range_node->range.low && range_node->range.high) {
                            /* Helper to extract static integer from various expression forms */
                            bool extract_static_bound(Syntax_Node *expr, int64_t *out) {
                                if (!expr) return false;
                                /* Integer literal */
                                if (expr->kind == NK_INTEGER) {
                                    *out = expr->integer_lit.value;
                                    return true;
                                }
                                /* Character/enum literal (symbol with frame_offset as position) */
                                if (expr->symbol && expr->symbol->kind == SYMBOL_LITERAL) {
                                    *out = expr->symbol->frame_offset;
                                    return true;
                                }
                                /* Qualified expression: TYPE'(expr) - evaluate inner expression */
                                if (expr->kind == NK_QUALIFIED && expr->qualified.expression) {
                                    Syntax_Node *inner = expr->qualified.expression;
                                    if (inner->kind == NK_INTEGER) {
                                        *out = inner->integer_lit.value;
                                        return true;
                                    }
                                    if (inner->symbol && inner->symbol->kind == SYMBOL_LITERAL) {
                                        *out = inner->symbol->frame_offset;
                                        return true;
                                    }
                                    /* Handle character literal inside qualified expression:
                                     * look up in the qualifying type's enumeration literals */
                                    if (inner->kind == NK_CHARACTER && expr->qualified.subtype_mark) {
                                        /* First resolve the subtype_mark to get its type */
                                        if (!expr->qualified.subtype_mark->type) {
                                            Resolve_Expression(sm, expr->qualified.subtype_mark);
                                        }
                                        Type_Info *qual_type = expr->qualified.subtype_mark->type;
                                        /* Walk up to find the base enumeration type with literals */
                                        while (qual_type && qual_type->kind == TYPE_ENUMERATION &&
                                               !qual_type->enumeration.literals) {
                                            qual_type = qual_type->base_type ? qual_type->base_type : qual_type->parent_type;
                                        }
                                        if (qual_type && qual_type->kind == TYPE_ENUMERATION &&
                                            qual_type->enumeration.literals) {
                                            /* Extract the character from 'X' format */
                                            String_Slice lit_text = inner->string_val.text;
                                            char ch = lit_text.length >= 2 ? lit_text.data[1] : 0;
                                            /* Look for matching character literal in enum */
                                            for (uint32_t j = 0; j < qual_type->enumeration.literal_count; j++) {
                                                String_Slice lit_name = qual_type->enumeration.literals[j];
                                                if (lit_name.length == 3 &&
                                                    lit_name.data[0] == '\'' &&
                                                    lit_name.data[1] == ch &&
                                                    lit_name.data[2] == '\'') {
                                                    *out = (int64_t)j;  /* Position in enumeration */
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                    /* Try constant evaluation for other inner expressions */
                                    double val = Eval_Const_Numeric(inner);
                                    if (val == val) {  /* Not NaN */
                                        *out = (int64_t)val;
                                        return true;
                                    }
                                }
                                /* Try general constant evaluation */
                                double val = Eval_Const_Numeric(expr);
                                if (val == val) {  /* Not NaN */
                                    *out = (int64_t)val;
                                    return true;
                                }
                                return false;
                            }
                            int64_t low_val, high_val;
                            if (extract_static_bound(range_node->range.low, &low_val)) {
                                info->low_bound = (Type_Bound){
                                    .kind = BOUND_INTEGER,
                                    .int_value = low_val
                                };
                            } else {
                                /* Non-static bound - store expression reference */
                                info->low_bound = (Type_Bound){
                                    .kind = BOUND_EXPR,
                                    .expr = range_node->range.low
                                };
                            }
                            if (extract_static_bound(range_node->range.high, &high_val)) {
                                info->high_bound = (Type_Bound){
                                    .kind = BOUND_INTEGER,
                                    .int_value = high_val
                                };
                            } else {
                                /* Non-static bound - store expression reference */
                                info->high_bound = (Type_Bound){
                                    .kind = BOUND_EXPR,
                                    .expr = range_node->range.high
                                };
                            }
                        }
                    }
                }

                /* Resolve component type */
                if (node->array_type.component_type) {
                    Resolve_Expression(sm, node->array_type.component_type);
                    array_type->array.element_type = node->array_type.component_type->type;
                } else {
                    array_type->array.element_type = sm->type_integer;
                }

                /* Compute size */
                if (array_type->array.is_constrained && array_type->array.index_count > 0) {
                    int64_t count = 1;
                    for (uint32_t i = 0; i < array_type->array.index_count; i++) {
                        int64_t lo = Type_Bound_Value(array_type->array.indices[i].low_bound);
                        int64_t hi = Type_Bound_Value(array_type->array.indices[i].high_bound);
                        count *= (hi - lo + 1);
                    }
                    uint32_t elem_size = array_type->array.element_type ?
                                         array_type->array.element_type->size : 8;
                    array_type->size = (uint32_t)(count * elem_size);
                }

                node->type = array_type;
                return array_type;
            }

        case NK_ENUMERATION_TYPE:
            {
                /* Create enumeration type info from syntax node
                 * Note: Literal symbols are created later in NK_TYPE_DECL processing
                 * so they reference the named type, not this anonymous type */
                Type_Info *enum_type = Type_New(TYPE_ENUMERATION, S(""));
                uint32_t lit_count = (uint32_t)node->enum_type.literals.count;

                enum_type->enumeration.literal_count = lit_count;
                if (lit_count > 0) {
                    enum_type->enumeration.literals = Arena_Allocate(
                        lit_count * sizeof(String_Slice));

                    for (uint32_t i = 0; i < lit_count; i++) {
                        Syntax_Node *lit = node->enum_type.literals.items[i];
                        enum_type->enumeration.literals[i] = lit->string_val.text;
                    }
                }

                /* Size based on number of literals */
                if (lit_count <= 256) {
                    enum_type->size = 1;  /* Fits in 1 byte */
                } else if (lit_count <= 65536) {
                    enum_type->size = 2;  /* Fits in 2 bytes */
                } else {
                    enum_type->size = 4;  /* 4 bytes for large enums */
                }
                enum_type->alignment = enum_type->size;
                enum_type->low_bound = (Type_Bound){.kind = BOUND_INTEGER, .int_value = 0};
                enum_type->high_bound = (Type_Bound){.kind = BOUND_INTEGER, .int_value = lit_count - 1};

                node->type = enum_type;
                return enum_type;
            }

        case NK_DERIVED_TYPE:
            {
                /* Derived type: type T is new Parent [constraint] */
                Resolve_Expression(sm, node->derived_type.parent_type);
                Type_Info *parent = node->derived_type.parent_type ?
                                    node->derived_type.parent_type->type : NULL;
                if (!parent) {
                    node->type = NULL;
                    return NULL;
                }

                /* Create new type that inherits from parent */
                Type_Info *derived = Type_New(parent->kind, S(""));
                derived->parent_type = parent;
                derived->size = parent->size;
                derived->alignment = parent->alignment;
                derived->low_bound = parent->low_bound;
                derived->high_bound = parent->high_bound;

                /* Copy kind-specific info */
                if (parent->kind == TYPE_ENUMERATION) {
                    derived->enumeration = parent->enumeration;
                } else if (parent->kind == TYPE_ARRAY) {
                    derived->array = parent->array;
                } else if (parent->kind == TYPE_RECORD) {
                    derived->record = parent->record;
                } else if (parent->kind == TYPE_ACCESS) {
                    derived->access = parent->access;
                } else if (parent->kind == TYPE_FIXED) {
                    derived->fixed = parent->fixed;
                }

                /* Apply constraint if present */
                if (node->derived_type.constraint) {
                    Resolve_Expression(sm, node->derived_type.constraint);
                    /* Constraint would override bounds - handled in subtype_indication */
                }

                node->type = derived;
                return derived;
            }

        case NK_ACCESS_TYPE:
            {
                /* Create access type pointing to designated type */
                Type_Info *access_type = Type_New(TYPE_ACCESS, S(""));
                access_type->size = 8;  /* Pointer size */
                access_type->alignment = 8;

                /* Resolve designated subtype */
                if (node->access_type.designated) {
                    Resolve_Expression(sm, node->access_type.designated);
                    access_type->access.designated_type = node->access_type.designated->type;
                }

                node->type = access_type;
                return access_type;
            }

        case NK_RECORD_TYPE:
            {
                /* Create record type info from syntax node */
                Type_Info *record_type = Type_New(TYPE_RECORD, S(""));

                /* Helper: count components in a variant part recursively */
                uint32_t Count_Variant_Components(Syntax_Node *vp) {
                    if (!vp) return 0;
                    uint32_t count = 0;
                    for (uint32_t i = 0; i < vp->variant_part.variants.count; i++) {
                        Syntax_Node *v = vp->variant_part.variants.items[i];
                        for (uint32_t j = 0; j < v->variant.components.count; j++) {
                            Syntax_Node *c = v->variant.components.items[j];
                            if (c->kind == NK_COMPONENT_DECL)
                                count += (uint32_t)c->component.names.count;
                        }
                        count += Count_Variant_Components(v->variant.variant_part);
                    }
                    return count;
                }

                /* Count total components (each decl may have multiple names) */
                uint32_t total_comps = 0;
                for (uint32_t i = 0; i < node->record_type.components.count; i++) {
                    Syntax_Node *comp = node->record_type.components.items[i];
                    if (comp->kind == NK_COMPONENT_DECL) {
                        total_comps += (uint32_t)comp->component.names.count;
                    }
                }
                /* Also count components in variant parts */
                total_comps += Count_Variant_Components(node->record_type.variant_part);

                record_type->record.component_count = total_comps;
                if (total_comps > 0) {
                    record_type->record.components = Arena_Allocate(
                        total_comps * sizeof(Component_Info));

                    uint32_t offset = 0;
                    uint32_t comp_idx = 0;

                    /* Helper: add component to list */
                    void Add_Component(Syntax_Node *comp) {
                        if (comp->kind != NK_COMPONENT_DECL) return;
                        Resolve_Expression(sm, comp->component.component_type);
                        Type_Info *comp_type = comp->component.component_type ?
                                               comp->component.component_type->type : sm->type_integer;
                        uint32_t comp_size = comp_type ? comp_type->size : 8;
                        for (uint32_t j = 0; j < comp->component.names.count; j++) {
                            Component_Info *info = &record_type->record.components[comp_idx++];
                            info->name = comp->component.names.items[j]->string_val.text;
                            info->component_type = comp_type;
                            info->byte_offset = offset;
                            info->bit_offset = 0;
                            info->bit_size = comp_type ? comp_type->size * 8 : 64;
                            offset += comp_size;
                        }
                    }

                    /* Helper: add components from variant part recursively */
                    void Add_Variant_Components(Syntax_Node *vp) {
                        if (!vp) return;
                        for (uint32_t i = 0; i < vp->variant_part.variants.count; i++) {
                            Syntax_Node *v = vp->variant_part.variants.items[i];
                            for (uint32_t j = 0; j < v->variant.components.count; j++)
                                Add_Component(v->variant.components.items[j]);
                            Add_Variant_Components(v->variant.variant_part);
                        }
                    }

                    /* Process regular components */
                    for (uint32_t i = 0; i < node->record_type.components.count; i++) {
                        Add_Component(node->record_type.components.items[i]);
                    }
                    /* Process variant part components */
                    Add_Variant_Components(node->record_type.variant_part);

                    record_type->size = offset;
                    record_type->alignment = 8;
                }

                node->type = record_type;
                return record_type;
            }

        case NK_SUBTYPE_INDICATION:
            {
                /* Helper: Try to extract a static integer value from a bound expression.
                 * Returns true if value was extracted, false otherwise. */
                bool Try_Static_Bound(Syntax_Node *expr, int64_t *out_val) {
                    if (!expr) return false;
                    if (expr->kind == NK_INTEGER) {
                        *out_val = expr->integer_lit.value;
                        return true;
                    }
                    if (expr->kind == NK_UNARY_OP && expr->unary.operand &&
                        expr->unary.operand->kind == NK_INTEGER) {
                        int64_t val = expr->unary.operand->integer_lit.value;
                        if (expr->unary.op == TK_MINUS) val = -val;
                        *out_val = val;
                        return true;
                    }
                    if (expr->symbol && expr->symbol->kind == SYMBOL_LITERAL) {
                        *out_val = expr->symbol->frame_offset;
                        return true;
                    }
                    /* Handle TYPE'POS(X) or TYPE'VAL(N) as NK_APPLY */
                    if (expr->kind == NK_APPLY && expr->apply.prefix &&
                        expr->apply.prefix->kind == NK_ATTRIBUTE) {
                        Syntax_Node *attr = expr->apply.prefix;
                        String_Slice attr_name = attr->attribute.name;
                        if (Slice_Equal_Ignore_Case(attr_name, S("POS")) &&
                            expr->apply.arguments.count == 1) {
                            Syntax_Node *arg = expr->apply.arguments.items[0];
                            if (arg && arg->symbol && arg->symbol->kind == SYMBOL_LITERAL) {
                                *out_val = arg->symbol->frame_offset;
                                return true;
                            }
                        }
                        /* Handle TYPE'VAL(N) where N is static */
                        if (Slice_Equal_Ignore_Case(attr_name, S("VAL")) &&
                            expr->apply.arguments.count == 1) {
                            Syntax_Node *arg = expr->apply.arguments.items[0];
                            int64_t inner_val;
                            if (Try_Static_Bound(arg, &inner_val)) {
                                *out_val = inner_val;
                                return true;
                            }
                        }
                    }
                    /* Handle type conversions: TYPE_NAME(arg) where arg is static */
                    if (expr->kind == NK_APPLY && expr->apply.prefix &&
                        expr->apply.prefix->kind == NK_IDENTIFIER &&
                        expr->apply.prefix->symbol &&
                        expr->apply.prefix->symbol->kind == SYMBOL_TYPE &&
                        expr->apply.arguments.count == 1) {
                        int64_t arg_val;
                        if (Try_Static_Bound(expr->apply.arguments.items[0], &arg_val)) {
                            *out_val = arg_val;
                            return true;
                        }
                    }
                    /* Handle TYPE'VAL(...) or TYPE'POS(...) as NK_ATTRIBUTE with arguments */
                    if (expr->kind == NK_ATTRIBUTE && expr->attribute.arguments.count == 1) {
                        String_Slice attr_name = expr->attribute.name;
                        Syntax_Node *arg = expr->attribute.arguments.items[0];
                        if (Slice_Equal_Ignore_Case(attr_name, S("VAL"))) {
                            int64_t inner_val;
                            if (Try_Static_Bound(arg, &inner_val)) {
                                *out_val = inner_val;
                                return true;
                            }
                        }
                        if (Slice_Equal_Ignore_Case(attr_name, S("POS"))) {
                            if (arg && arg->symbol && arg->symbol->kind == SYMBOL_LITERAL) {
                                *out_val = arg->symbol->frame_offset;
                                return true;
                            }
                        }
                    }
                    return false;
                }

                /* Resolve the base type */
                Resolve_Expression(sm, node->subtype_ind.subtype_mark);
                Type_Info *base_type = node->subtype_ind.subtype_mark->type;

                if (!base_type) {
                    return NULL;
                }

                /* Check for index constraint (STRING(1..5) style) */
                Syntax_Node *constraint = node->subtype_ind.constraint;
                if (constraint && constraint->kind == NK_INDEX_CONSTRAINT &&
                    Type_Is_Array_Like(base_type)) {
                    /* Create constrained array type */
                    Type_Info *constrained = Type_New(TYPE_ARRAY, base_type->name);
                    constrained->array.is_constrained = true;
                    constrained->array.index_count = (uint32_t)constraint->index_constraint.ranges.count;
                    /* Set base_type to original type for tracing unconstrained arrays */
                    constrained->base_type = base_type;

                    /* For STRING, element type is CHARACTER */
                    if (base_type->kind == TYPE_STRING) {
                        constrained->array.element_type = sm->type_character;
                    } else if (base_type->array.element_type) {
                        constrained->array.element_type = base_type->array.element_type;
                    }

                    /* Process index constraints */
                    if (constrained->array.index_count > 0) {
                        constrained->array.indices = Arena_Allocate(
                            constrained->array.index_count * sizeof(Index_Info));

                        for (uint32_t i = 0; i < constrained->array.index_count; i++) {
                            Syntax_Node *range = constraint->index_constraint.ranges.items[i];
                            Resolve_Expression(sm, range);

                            Index_Info *info = &constrained->array.indices[i];
                            info->index_type = sm->type_integer;

                            if (range->kind == NK_RANGE) {
                                /* Try to evaluate bounds as static constants */
                                if (range->range.low) {
                                    double val = Eval_Const_Numeric(range->range.low);
                                    if (val == val) {  /* Not NaN - static value */
                                        info->low_bound = (Type_Bound){
                                            .kind = BOUND_INTEGER,
                                            .int_value = (int64_t)val
                                        };
                                    } else {
                                        /* Non-static bound - store expression reference */
                                        info->low_bound = (Type_Bound){
                                            .kind = BOUND_EXPR,
                                            .expr = range->range.low
                                        };
                                    }
                                }
                                if (range->range.high) {
                                    double val = Eval_Const_Numeric(range->range.high);
                                    if (val == val) {  /* Not NaN - static value */
                                        info->high_bound = (Type_Bound){
                                            .kind = BOUND_INTEGER,
                                            .int_value = (int64_t)val
                                        };
                                    } else {
                                        /* Non-static bound - store expression reference */
                                        info->high_bound = (Type_Bound){
                                            .kind = BOUND_EXPR,
                                            .expr = range->range.high
                                        };
                                    }
                                }
                            }
                        }

                        /* Compute size */
                        int64_t count = 1;
                        for (uint32_t i = 0; i < constrained->array.index_count; i++) {
                            int64_t lo = Type_Bound_Value(constrained->array.indices[i].low_bound);
                            int64_t hi = Type_Bound_Value(constrained->array.indices[i].high_bound);
                            count *= (hi - lo + 1);
                        }
                        uint32_t elem_size = constrained->array.element_type ?
                                             constrained->array.element_type->size : 1;
                        constrained->size = (uint32_t)(count * elem_size);
                    }

                    node->type = constrained;
                    return constrained;
                }

                /* Check for scalar range constraint (ENUM RANGE A..B or INTEGER RANGE X..Y) */
                if (constraint && constraint->kind == NK_RANGE_CONSTRAINT) {
                    Syntax_Node *range = constraint->range_constraint.range;
                    if (range) {
                        Resolve_Expression(sm, range);

                        /* Create a constrained subtype */
                        Type_Info *constrained = Type_New(base_type->kind, base_type->name);
                        constrained->base_type = base_type;
                        constrained->size = base_type->size;
                        constrained->alignment = base_type->alignment;

                        /* Copy enumeration info if applicable */
                        if (base_type->kind == TYPE_ENUMERATION) {
                            constrained->enumeration = base_type->enumeration;
                        }

                        /* Set bounds from range.
                         * Following GNAT's approach: try compile-time evaluation first,
                         * if not possible, store expression for later evaluation. */
                        if (range->kind == NK_RANGE) {
                            Syntax_Node *lo = range->range.low;
                            Syntax_Node *hi = range->range.high;
                            int64_t val;
                            if (lo) {
                                if (Try_Static_Bound(lo, &val)) {
                                    constrained->low_bound = (Type_Bound){
                                        .kind = BOUND_INTEGER, .int_value = val
                                    };
                                } else {
                                    /* Store expression for later evaluation */
                                    constrained->low_bound = (Type_Bound){
                                        .kind = BOUND_EXPR, .expr = lo
                                    };
                                }
                            }
                            if (hi) {
                                if (Try_Static_Bound(hi, &val)) {
                                    constrained->high_bound = (Type_Bound){
                                        .kind = BOUND_INTEGER, .int_value = val
                                    };
                                } else {
                                    /* Store expression for later evaluation */
                                    constrained->high_bound = (Type_Bound){
                                        .kind = BOUND_EXPR, .expr = hi
                                    };
                                }
                            }
                        }

                        node->type = constrained;
                        return constrained;
                    }
                }

                /* Check for DELTA constraint (fixed-point subtypes with different delta) */
                if (constraint && constraint->kind == NK_DELTA_CONSTRAINT) {
                    Resolve_Expression(sm, constraint->delta_constraint.delta_expr);
                    if (constraint->delta_constraint.range)
                        Resolve_Expression(sm, constraint->delta_constraint.range);

                    /* Create constrained fixed-point subtype with new delta */
                    Type_Info *constrained = Type_New(TYPE_FIXED, base_type->name);
                    constrained->base_type = base_type;
                    constrained->size = base_type->size;
                    constrained->alignment = base_type->alignment;

                    /* Evaluate the delta expression */
                    double delta = Eval_Const_Numeric(constraint->delta_constraint.delta_expr);
                    if (delta != delta || delta <= 0.0) delta = base_type->fixed.delta;

                    /* Compute small as largest power of 2 <= delta (per RM 3.5.9) */
                    double small = 1.0;
                    if (delta > 0.0) {
                        while (small > delta) small /= 2.0;
                        while (small * 2.0 <= delta) small *= 2.0;
                    }

                    constrained->fixed.delta = delta;
                    constrained->fixed.small = small;

                    /* Compute scale factor: small = 2^scale */
                    int scale = 0;
                    double temp = small;
                    while (temp < 1.0 && scale > -64) { temp *= 2.0; scale--; }
                    while (temp > 1.0 && scale < 64) { temp /= 2.0; scale++; }
                    constrained->fixed.scale = scale;

                    /* Set bounds from range, or inherit from base type */
                    /* Start by inheriting base type bounds */
                    constrained->low_bound = base_type->low_bound;
                    constrained->high_bound = base_type->high_bound;
                    /* If explicit range given, override with evaluated bounds.
                     * Following GNAT's approach: try compile-time evaluation first,
                     * if not possible, store expression for later evaluation. */
                    if (constraint->delta_constraint.range &&
                        constraint->delta_constraint.range->kind == NK_RANGE) {
                        Syntax_Node *range = constraint->delta_constraint.range;
                        if (range->range.low) {
                            double lo = Eval_Const_Numeric(range->range.low);
                            if (lo == lo) {
                                /* Compile-time known */
                                constrained->low_bound = (Type_Bound){
                                    .kind = BOUND_FLOAT, .float_value = lo
                                };
                            } else {
                                /* Store expression for later evaluation (per GNAT sem_attr) */
                                constrained->low_bound = (Type_Bound){
                                    .kind = BOUND_EXPR, .expr = range->range.low
                                };
                            }
                        }
                        if (range->range.high) {
                            double hi = Eval_Const_Numeric(range->range.high);
                            if (hi == hi) {
                                /* Compile-time known */
                                constrained->high_bound = (Type_Bound){
                                    .kind = BOUND_FLOAT, .float_value = hi
                                };
                            } else {
                                /* Store expression for later evaluation (per GNAT sem_attr) */
                                constrained->high_bound = (Type_Bound){
                                    .kind = BOUND_EXPR, .expr = range->range.high
                                };
                            }
                        }
                    }

                    node->type = constrained;
                    return constrained;
                }

                /* Check for discriminant constraint (REC(A => E1, B => E2) style)
                 * Discriminant constraints use named associations where the choices
                 * are discriminant names - they should NOT be resolved as identifiers.
                 * Only the value expressions should be resolved. */
                if (constraint && constraint->kind == NK_DISCRIMINANT_CONSTRAINT) {
                    for (uint32_t i = 0; i < constraint->discriminant_constraint.associations.count; i++) {
                        Syntax_Node *assoc = constraint->discriminant_constraint.associations.items[i];
                        if (assoc->kind == NK_ASSOCIATION && assoc->association.expression) {
                            /* Only resolve the value expression, not the choices */
                            Resolve_Expression(sm, assoc->association.expression);
                        }
                    }
                    /* Return the base type */
                    node->type = base_type;
                    return base_type;
                }

                /* Otherwise just use base type */
                node->type = base_type;
                return base_type;
            }

        case NK_INTEGER_TYPE:
            {
                /* Integer type definition: range L .. H or mod M */
                Type_Info *int_type = Type_New(TYPE_INTEGER, S(""));

                /* Resolve range bounds if present */
                if (node->integer_type.range) {
                    Resolve_Expression(sm, node->integer_type.range);
                    Syntax_Node *range = node->integer_type.range;
                    if (range->kind == NK_RANGE && range->range.low && range->range.high) {
                        /* Extract low bound - handle integer literals and unary minus */
                        Syntax_Node *lo = range->range.low;
                        if (lo->kind == NK_INTEGER) {
                            int_type->low_bound = (Type_Bound){
                                .kind = BOUND_INTEGER,
                                .int_value = lo->integer_lit.value
                            };
                        } else if (lo->kind == NK_UNARY_OP && lo->unary.operand &&
                                   lo->unary.operand->kind == NK_INTEGER) {
                            int64_t val = lo->unary.operand->integer_lit.value;
                            if (lo->unary.op == TK_MINUS) val = -val;
                            int_type->low_bound = (Type_Bound){
                                .kind = BOUND_INTEGER,
                                .int_value = val
                            };
                        }
                        /* Extract high bound - handle integer literals and unary minus */
                        Syntax_Node *hi = range->range.high;
                        if (hi->kind == NK_INTEGER) {
                            int_type->high_bound = (Type_Bound){
                                .kind = BOUND_INTEGER,
                                .int_value = hi->integer_lit.value
                            };
                        } else if (hi->kind == NK_UNARY_OP && hi->unary.operand &&
                                   hi->unary.operand->kind == NK_INTEGER) {
                            int64_t val = hi->unary.operand->integer_lit.value;
                            if (hi->unary.op == TK_MINUS) val = -val;
                            int_type->high_bound = (Type_Bound){
                                .kind = BOUND_INTEGER,
                                .int_value = val
                            };
                        }
                    }
                }

                /* Compute appropriate size */
                int_type->size = 8;  /* Default to 64-bit */
                int_type->alignment = 8;
                node->type = int_type;
                return int_type;
            }

        case NK_REAL_TYPE:
            {
                /* Real type definition: digits D or delta D */
                if (node->real_type.delta) {
                    /* Fixed-point type: TYPE_FIXED with delta */
                    Type_Info *fixed_type = Type_New(TYPE_FIXED, S(""));
                    Resolve_Expression(sm, node->real_type.delta);

                    /* Extract delta value using constant expression evaluation */
                    double delta = Eval_Const_Numeric(node->real_type.delta);
                    if (delta != delta || delta <= 0.0) delta = 0.001;  /* NaN or invalid -> fallback */

                    /* Compute small as largest power of 2 <= delta (per RM 3.5.9) */
                    double small = 1.0;
                    if (delta > 0.0) {
                        /* Find largest 2^n <= delta */
                        while (small > delta) small /= 2.0;
                        while (small * 2.0 <= delta) small *= 2.0;
                    }

                    /* Compute scale factor: small = 2^scale */
                    int scale = 0;
                    double temp = small;
                    if (temp >= 1.0) {
                        while (temp >= 2.0) { temp /= 2.0; scale++; }
                    } else {
                        while (temp < 1.0) { temp *= 2.0; scale--; }
                    }

                    fixed_type->fixed.delta = delta;
                    fixed_type->fixed.small = small;
                    fixed_type->fixed.scale = scale;

                    /* Resolve range if present */
                    if (node->real_type.range) {
                        Resolve_Expression(sm, node->real_type.range);
                        Syntax_Node *range = node->real_type.range;
                        if (range->kind == NK_RANGE) {
                            /* Extract bound values using constant expression evaluation */
                            Syntax_Node *lo = range->range.low;
                            Syntax_Node *hi = range->range.high;
                            if (lo) {
                                double val = Eval_Const_Numeric(lo);
                                if (val == val) {  /* not NaN */
                                    fixed_type->low_bound = (Type_Bound){.kind = BOUND_FLOAT, .float_value = val};
                                }
                            }
                            if (hi) {
                                double val = Eval_Const_Numeric(hi);
                                if (val == val) {  /* not NaN */
                                    fixed_type->high_bound = (Type_Bound){.kind = BOUND_FLOAT, .float_value = val};
                                }
                            }
                        }
                    }

                    /* Size: typically 32 or 64 bits depending on range and precision */
                    fixed_type->size = 8;  /* 64-bit for safe default */
                    fixed_type->alignment = 8;
                    node->type = fixed_type;
                    return fixed_type;
                } else {
                    /* Floating-point type: digits D */
                    Type_Info *float_type = Type_New(TYPE_FLOAT, S(""));

                    /* Resolve digits expression */
                    if (node->real_type.precision) {
                        Resolve_Expression(sm, node->real_type.precision);
                    }

                    /* Resolve range if present */
                    if (node->real_type.range) {
                        Resolve_Expression(sm, node->real_type.range);
                    }

                    /* Size based on digits: <=6 = float, >6 = double */
                    int digits = 15;  /* Default double precision */
                    if (node->real_type.precision &&
                        node->real_type.precision->kind == NK_INTEGER) {
                        digits = (int)node->real_type.precision->integer_lit.value;
                    }
                    float_type->size = (digits <= 6) ? 4 : 8;
                    float_type->alignment = float_type->size;
                    node->type = float_type;
                    return float_type;
                }
            }

        default:
            return NULL;
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §12.2 Statement Resolution
 * ───────────────────────────────────────────────────────────────────────── */

static void Resolve_Statement(Symbol_Manager *sm, Syntax_Node *node);
static void Resolve_Declaration_List(Symbol_Manager *sm, Node_List *list);
static void Freeze_Declaration_List(Node_List *list);
static void Populate_Package_Exports(Symbol *pkg_sym, Syntax_Node *pkg_spec);

/* Pre-register labels in a statement list to allow forward gotos.
 * Labels can appear as:
 *   1. NK_LABEL nodes wrapping other statements
 *   2. The .label field of NK_BLOCK or NK_LOOP nodes (Ada allows naming blocks/loops) */
static void Preregister_Labels(Symbol_Manager *sm, Node_List *list) {
    for (uint32_t i = 0; i < list->count; i++) {
        Syntax_Node *node = list->items[i];
        if (!node) continue;

        String_Slice label_name = Empty_Slice;
        Source_Location label_loc = node->location;
        Symbol **label_sym_ptr = NULL;

        switch (node->kind) {
            case NK_LABEL:
                label_name = node->label_node.name;
                label_sym_ptr = &node->label_node.symbol;
                break;
            case NK_BLOCK:
                label_name = node->block_stmt.label;
                label_sym_ptr = &node->block_stmt.label_symbol;
                break;
            case NK_LOOP:
                label_name = node->loop_stmt.label;
                label_sym_ptr = &node->loop_stmt.label_symbol;
                break;
            default:
                break;
        }

        if (label_name.data && label_name.length > 0) {
            Symbol *label_sym = Symbol_New(SYMBOL_LABEL, label_name, label_loc);
            label_sym->type = sm->type_address;
            Symbol_Add(sm, label_sym);
            if (label_sym_ptr) *label_sym_ptr = label_sym;
        }
    }
}

static void Resolve_Statement_List(Symbol_Manager *sm, Node_List *list) {
    /* First pass: register all labels to allow forward gotos */
    Preregister_Labels(sm, list);
    /* Second pass: resolve all statements */
    for (uint32_t i = 0; i < list->count; i++) {
        Resolve_Statement(sm, list->items[i]);
    }
}

static void Resolve_Statement(Symbol_Manager *sm, Syntax_Node *node) {
    if (!node) return;

    switch (node->kind) {
        case NK_ASSIGNMENT:
            Resolve_Expression(sm, node->assignment.target);
            /* Propagate target type to aggregate values for context-dependent typing */
            if (node->assignment.value->kind == NK_AGGREGATE &&
                node->assignment.target->type) {
                node->assignment.value->type = node->assignment.target->type;
            }
            Resolve_Expression(sm, node->assignment.value);
            /* Type check: value must be compatible with target */
            if (node->assignment.target->type && node->assignment.value->type) {
                if (!Type_Covers(node->assignment.target->type,
                                node->assignment.value->type)) {
                    Report_Error(node->location, "type mismatch in assignment");
                }
            }
            break;

        case NK_CALL_STMT:
            Resolve_Expression(sm, node->assignment.target);
            break;

        case NK_RETURN:
            if (node->return_stmt.expression) {
                Resolve_Expression(sm, node->return_stmt.expression);
            }
            break;

        case NK_IF:
            Resolve_Expression(sm, node->if_stmt.condition);
            Resolve_Statement_List(sm, &node->if_stmt.then_stmts);
            for (uint32_t i = 0; i < node->if_stmt.elsif_parts.count; i++) {
                Resolve_Statement(sm, node->if_stmt.elsif_parts.items[i]);
            }
            Resolve_Statement_List(sm, &node->if_stmt.else_stmts);
            break;

        case NK_CASE:
            Resolve_Expression(sm, node->case_stmt.expression);
            for (uint32_t i = 0; i < node->case_stmt.alternatives.count; i++) {
                Resolve_Statement(sm, node->case_stmt.alternatives.items[i]);
            }
            break;

        case NK_LOOP:
            {
                Syntax_Node *iter = node->loop_stmt.iteration_scheme;
                bool is_for_loop = iter && iter->kind == NK_BINARY_OP &&
                                   iter->binary.op == TK_IN;
                if (is_for_loop) {
                    /* FOR loop - create loop variable in new scope.
                     * Inherit owner from enclosing scope for proper name mangling */
                    Symbol *enclosing_owner = sm->current_scope->owner;
                    Symbol_Manager_Push_Scope(sm, enclosing_owner);
                    Syntax_Node *loop_id = iter->binary.left;
                    /* Resolve range expression FIRST to get its type */
                    Resolve_Expression(sm, iter->binary.right);
                    if (loop_id && loop_id->kind == NK_IDENTIFIER) {
                        Symbol *loop_var = Symbol_New(SYMBOL_VARIABLE,
                                                      loop_id->string_val.text,
                                                      loop_id->location);
                        /* Loop variable type comes from the range expression.
                         * For X IN A..B, the range's type is the type of the bounds */
                        Type_Info *range_type = iter->binary.right->type;
                        loop_var->type = range_type ? range_type : sm->type_integer;
                        Symbol_Add(sm, loop_var);
                        loop_id->symbol = loop_var;
                    }
                    Resolve_Statement_List(sm, &node->loop_stmt.statements);
                    Symbol_Manager_Pop_Scope(sm);
                } else {
                    /* WHILE or bare LOOP */
                    if (iter) Resolve_Expression(sm, iter);
                    Resolve_Statement_List(sm, &node->loop_stmt.statements);
                }
            }
            break;

        case NK_BLOCK:
            /* Inherit owner from enclosing scope for proper symbol parenting */
            Symbol_Manager_Push_Scope(sm, sm->current_scope->owner);
            /* Resolve declarations first (adds symbols to scope) */
            Resolve_Declaration_List(sm, &node->block_stmt.declarations);
            /* Freeze all types at end of declarative part (RM 13.14) */
            Freeze_Declaration_List(&node->block_stmt.declarations);
            /* Then resolve statements that use those symbols */
            Resolve_Statement_List(sm, &node->block_stmt.statements);
            for (uint32_t i = 0; i < node->block_stmt.handlers.count; i++) {
                Resolve_Statement(sm, node->block_stmt.handlers.items[i]);
            }
            Symbol_Manager_Pop_Scope(sm);
            break;

        case NK_EXIT:
            if (node->exit_stmt.condition) {
                Resolve_Expression(sm, node->exit_stmt.condition);
            }
            break;

        case NK_RAISE:
            if (node->raise_stmt.exception_name) {
                Resolve_Expression(sm, node->raise_stmt.exception_name);
            }
            break;

        case NK_EXCEPTION_HANDLER:
            /* Resolve exception names */
            for (uint32_t i = 0; i < node->handler.exceptions.count; i++) {
                Syntax_Node *exc = node->handler.exceptions.items[i];
                if (exc && exc->kind != NK_OTHERS) {
                    Resolve_Expression(sm, exc);
                }
            }
            Resolve_Statement_List(sm, &node->handler.statements);
            break;

        case NK_ASSOCIATION:
            /* Case alternative - resolve choices and body */
            for (uint32_t i = 0; i < node->association.choices.count; i++) {
                Resolve_Expression(sm, node->association.choices.items[i]);
            }
            if (node->association.expression) {
                if (node->association.expression->kind == NK_BLOCK) {
                    Resolve_Statement(sm, node->association.expression);
                } else {
                    Resolve_Expression(sm, node->association.expression);
                }
            }
            break;

        case NK_LABEL:
            {
                /* Label symbol was pre-registered by Preregister_Labels.
                 * Just resolve the labeled statement. */
                if (node->label_node.statement) {
                    Resolve_Statement(sm, node->label_node.statement);
                }
            }
            break;

        case NK_GOTO:
            {
                /* Look up the target label */
                Symbol *label = Symbol_Find(sm, node->goto_stmt.name);
                if (!label) {
                    Report_Error(node->location, "undefined label '%.*s'",
                                (int)node->goto_stmt.name.length,
                                node->goto_stmt.name.data);
                } else if (label->kind != SYMBOL_LABEL && label->kind != SYMBOL_LOOP) {
                    Report_Error(node->location, "'%.*s' is not a label",
                                (int)node->goto_stmt.name.length,
                                node->goto_stmt.name.data);
                } else {
                    /* Store resolved label for code generation */
                    node->goto_stmt.target = label;
                }
            }
            break;

        case NK_ACCEPT:
            /* ACCEPT statement for task entry - resolve index and parameters.
             * Each accept statement has its own scope for parameters to avoid
             * naming conflicts with parameters from other accept statements
             * in the same selective wait (e.g., multiple accepts with param X). */

            /* Look up the entry symbol by name - it should be in the task's scope */
            node->accept_stmt.entry_sym = Symbol_Find(sm, node->accept_stmt.entry_name);

            if (node->accept_stmt.index) {
                Resolve_Expression(sm, node->accept_stmt.index);
            }
            /* Push new scope for accept parameters - use current scope owner
             * so parameters are considered local (not global) for naming.
             * Each accept statement needs its own scope because multiple accepts
             * in a selective wait may have parameters with the same name. */
            Symbol_Manager_Push_Scope(sm, sm->current_scope->owner);
            /* Resolve accept parameters */
            for (uint32_t i = 0; i < node->accept_stmt.parameters.count; i++) {
                Syntax_Node *param = node->accept_stmt.parameters.items[i];
                if (param && param->kind == NK_PARAM_SPEC) {
                    if (param->param_spec.param_type) {
                        Resolve_Expression(sm, param->param_spec.param_type);
                    }
                    /* Add parameter names to scope for the accept body */
                    for (uint32_t j = 0; j < param->param_spec.names.count; j++) {
                        Syntax_Node *name = param->param_spec.names.items[j];
                        if (name && name->kind == NK_IDENTIFIER) {
                            Symbol *param_sym = Symbol_New(SYMBOL_PARAMETER,
                                name->string_val.text, name->location);
                            if (param->param_spec.param_type)
                                param_sym->type = param->param_spec.param_type->type;
                            Symbol_Add(sm, param_sym);
                            name->symbol = param_sym;
                        }
                    }
                }
            }
            /* Resolve accept body statements */
            Resolve_Statement_List(sm, &node->accept_stmt.statements);
            /* Pop accept scope */
            Symbol_Manager_Pop_Scope(sm);
            break;

        case NK_SELECT:
            /* SELECT statement - resolve alternatives */
            for (uint32_t i = 0; i < node->select_stmt.alternatives.count; i++) {
                Syntax_Node *alt = node->select_stmt.alternatives.items[i];
                if (alt) Resolve_Statement(sm, alt);
            }
            break;

        case NK_DELAY:
            /* DELAY statement - resolve delay expression */
            if (node->delay_stmt.expression) {
                Resolve_Expression(sm, node->delay_stmt.expression);
            }
            break;

        default:
            break;
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §12.3 Declaration Resolution
 * ───────────────────────────────────────────────────────────────────────── */

static void Resolve_Declaration(Symbol_Manager *sm, Syntax_Node *node);
static char *Lookup_Path(String_Slice name);
static void Load_Package_Spec(Symbol_Manager *sm, String_Slice name, char *src);
static bool Body_Already_Loaded(String_Slice name);
static void Mark_Body_Loaded(String_Slice name);
static void Expand_Generic_Package(Symbol_Manager *sm, Symbol *instance_sym);

static void Resolve_Declaration_List(Symbol_Manager *sm, Node_List *list) {
    for (uint32_t i = 0; i < list->count; i++) {
        Resolve_Declaration(sm, list->items[i]);
    }
}

/* Freeze all types declared in a list
 * Per RM 13.14: At the end of a declarative part, all entities are frozen */
static void Freeze_Declaration_List(Node_List *list) {
    for (uint32_t i = 0; i < list->count; i++) {
        Syntax_Node *node = list->items[i];
        if (!node) continue;

        switch (node->kind) {
            case NK_TYPE_DECL:
            case NK_SUBTYPE_DECL:
                if (node->symbol && node->symbol->type) {
                    Freeze_Type(node->symbol->type);
                }
                break;

            case NK_OBJECT_DECL:
                /* Objects already freeze their type at declaration */
                break;

            case NK_PROCEDURE_BODY:
            case NK_FUNCTION_BODY:
                /* Subprogram bodies freeze all visible entities */
                break;

            default:
                break;
        }
    }
}

/* Populate a package symbol's exported[] array from its visible declarations.
 * This must be called after all visible declarations are resolved so that
 * decl->symbol pointers are valid. Used by both inline packages and loaded specs. */
static void Populate_Package_Exports(Symbol *pkg_sym, Syntax_Node *pkg_spec) {
    if (!pkg_sym || !pkg_spec || pkg_spec->kind != NK_PACKAGE_SPEC) return;

    Node_List *visible = &pkg_spec->package_spec.visible_decls;

    /* Count exports including nested items (enum literals, multiple object names) */
    uint32_t count = 0;
    for (uint32_t i = 0; i < visible->count; i++) {
        Syntax_Node *decl = visible->items[i];
        if (!decl) continue;
        if (decl->kind == NK_OBJECT_DECL) {
            count += (uint32_t)decl->object_decl.names.count;
        } else if (decl->kind == NK_TYPE_DECL || decl->kind == NK_SUBTYPE_DECL) {
            count++;
            /* Enumeration literals */
            if (decl->type_decl.definition &&
                decl->type_decl.definition->kind == NK_ENUMERATION_TYPE) {
                count += (uint32_t)decl->type_decl.definition->enum_type.literals.count;
            }
        } else if (decl->kind == NK_PROCEDURE_SPEC || decl->kind == NK_FUNCTION_SPEC ||
                   decl->kind == NK_PROCEDURE_BODY || decl->kind == NK_FUNCTION_BODY) {
            count++;
        } else if (decl->kind == NK_EXCEPTION_DECL) {
            count += (uint32_t)decl->exception_decl.names.count;
        } else if (decl->kind == NK_PACKAGE_SPEC) {
            count++;  /* Nested packages */
        } else if (decl->kind == NK_GENERIC_DECL) {
            count++;  /* Nested generics (e.g., TEXT_IO.INTEGER_IO) */
        }
    }

    if (count == 0) return;

    /* Allocate and fill */
    pkg_sym->exported = Arena_Allocate(count * sizeof(Symbol*));
    pkg_sym->exported_count = 0;

    for (uint32_t i = 0; i < visible->count; i++) {
        Syntax_Node *decl = visible->items[i];
        if (!decl) continue;

        if (decl->kind == NK_OBJECT_DECL) {
            for (uint32_t j = 0; j < decl->object_decl.names.count; j++) {
                Syntax_Node *name_node = decl->object_decl.names.items[j];
                if (name_node->symbol) {
                    pkg_sym->exported[pkg_sym->exported_count++] = name_node->symbol;
                }
            }
        } else if ((decl->kind == NK_TYPE_DECL || decl->kind == NK_SUBTYPE_DECL) && decl->symbol) {
            pkg_sym->exported[pkg_sym->exported_count++] = decl->symbol;
            /* Enumeration literals */
            if (decl->type_decl.definition &&
                decl->type_decl.definition->kind == NK_ENUMERATION_TYPE) {
                Node_List *lits = &decl->type_decl.definition->enum_type.literals;
                for (uint32_t j = 0; j < lits->count; j++) {
                    if (lits->items[j]->symbol) {
                        pkg_sym->exported[pkg_sym->exported_count++] = lits->items[j]->symbol;
                    }
                }
            }
        } else if ((decl->kind == NK_PROCEDURE_SPEC || decl->kind == NK_FUNCTION_SPEC ||
                    decl->kind == NK_PROCEDURE_BODY || decl->kind == NK_FUNCTION_BODY) && decl->symbol) {
            pkg_sym->exported[pkg_sym->exported_count++] = decl->symbol;
        } else if (decl->kind == NK_EXCEPTION_DECL) {
            for (uint32_t j = 0; j < decl->exception_decl.names.count; j++) {
                Syntax_Node *name_node = decl->exception_decl.names.items[j];
                if (name_node->symbol) {
                    pkg_sym->exported[pkg_sym->exported_count++] = name_node->symbol;
                }
            }
        } else if (decl->kind == NK_PACKAGE_SPEC && decl->symbol) {
            pkg_sym->exported[pkg_sym->exported_count++] = decl->symbol;
        } else if (decl->kind == NK_GENERIC_DECL && decl->symbol) {
            /* Export nested generic packages/subprograms (e.g., TEXT_IO.INTEGER_IO) */
            pkg_sym->exported[pkg_sym->exported_count++] = decl->symbol;
        }
    }
}

static void Resolve_Declaration(Symbol_Manager *sm, Syntax_Node *node) {
    if (!node) return;

    switch (node->kind) {
        case NK_OBJECT_DECL:
            /* Resolve type */
            if (node->object_decl.object_type) {
                Resolve_Expression(sm, node->object_decl.object_type);
                /* Object declarations freeze the type (RM 13.14) */
                if (node->object_decl.object_type->type) {
                    Freeze_Type(node->object_decl.object_type->type);
                }
            }
            /* Resolve initializer/renamed object - propagate type to aggregates first */
            if (node->object_decl.init) {
                /* Propagate type to aggregate initializer from declared type */
                if (node->object_decl.init->kind == NK_AGGREGATE &&
                    node->object_decl.object_type && node->object_decl.object_type->type) {
                    node->object_decl.init->type = node->object_decl.object_type->type;
                }
                Resolve_Expression(sm, node->object_decl.init);
            }
            /* Add symbols for each name */
            for (uint32_t i = 0; i < node->object_decl.names.count; i++) {
                Syntax_Node *name_node = node->object_decl.names.items[i];
                Symbol *sym = Symbol_New(
                    node->object_decl.is_constant ? SYMBOL_CONSTANT : SYMBOL_VARIABLE,
                    name_node->string_val.text,
                    name_node->location);
                /* Object renames: type comes from renamed object */
                if (node->object_decl.is_rename && node->object_decl.init) {
                    sym->type = node->object_decl.init->type;
                    sym->renamed_object = node->object_decl.init;  /* Point to renamed */
                    sym->is_named_number = false;
                }
                /* For named numbers (constant without type mark), use init expression's type */
                else if (node->object_decl.object_type) {
                    sym->type = node->object_decl.object_type->type;
                    sym->is_named_number = false;
                } else if (node->object_decl.is_constant && node->object_decl.init) {
                    /* Named number: use universal type from init expression */
                    sym->type = node->object_decl.init->type;
                    sym->is_named_number = true;  /* Mark as named number for inline generation */
                } else {
                    sym->type = NULL;
                    sym->is_named_number = node->object_decl.is_constant && !node->object_decl.object_type;
                }
                sym->declaration = node;
                Symbol_Add(sm, sym);
                name_node->symbol = sym;
            }
            break;

        case NK_TYPE_DECL:
            {
                /* Check for existing incomplete type to complete (RM 3.8.1)
                 * Must be in same declarative region (current scope) */
                Symbol *existing = Symbol_Find(sm, node->type_decl.name);
                Symbol *sym;
                Type_Info *type;
                if (existing && existing->kind == SYMBOL_TYPE &&
                    existing->type && existing->type->kind == TYPE_UNKNOWN &&
                    existing->defining_scope == sm->current_scope &&
                    node->type_decl.definition) {
                    /* Complete the existing incomplete type */
                    sym = existing;
                    type = sym->type;
                } else {
                    /* Create new type symbol */
                    sym = Symbol_New(SYMBOL_TYPE, node->type_decl.name, node->location);
                    type = Type_New(TYPE_UNKNOWN, node->type_decl.name);
                    sym->type = type;
                    type->defining_symbol = sym;
                    Symbol_Add(sm, sym);
                }
                node->symbol = sym;

                /* For discriminated types, add discriminant symbols to scope first
                 * so they can be referenced in the type definition (e.g., CASE A IS) */
                bool has_discriminants = node->type_decl.discriminants.count > 0;
                if (has_discriminants) {
                    Symbol_Manager_Push_Scope(sm, sym);
                    for (uint32_t i = 0; i < node->type_decl.discriminants.count; i++) {
                        Syntax_Node *disc_spec = node->type_decl.discriminants.items[i];
                        if (disc_spec->kind == NK_DISCRIMINANT_SPEC) {
                            /* Resolve discriminant type first */
                            Type_Info *disc_type = sm->type_integer;
                            if (disc_spec->discriminant.disc_type) {
                                disc_type = Resolve_Expression(sm, disc_spec->discriminant.disc_type);
                            }
                            /* Add each discriminant name as a symbol */
                            for (uint32_t j = 0; j < disc_spec->discriminant.names.count; j++) {
                                Syntax_Node *name_node = disc_spec->discriminant.names.items[j];
                                Symbol *disc_sym = Symbol_New(SYMBOL_VARIABLE, name_node->string_val.text,
                                                              name_node->location);
                                disc_sym->type = disc_type;
                                disc_sym->parent = sym;
                                Symbol_Add(sm, disc_sym);
                                name_node->symbol = disc_sym;
                            }
                        }
                    }
                }

                /* Resolve definition and copy type info */
                if (node->type_decl.definition) {
                    Type_Info *def_type = Resolve_Expression(sm, node->type_decl.definition);
                    if (def_type) {
                        /* Copy type info from definition to named type */
                        type->kind = def_type->kind;
                        type->size = def_type->size;
                        type->alignment = def_type->alignment;
                        type->low_bound = def_type->low_bound;
                        type->high_bound = def_type->high_bound;

                        /* For derived and subtype types, preserve base/parent chain */
                        type->base_type = def_type->base_type;
                        type->parent_type = def_type->parent_type;

                        /* For user-defined integer types (TYPE T IS RANGE L..R), the declared
                         * type is the "first subtype" and needs a base type (RM 3.5.4).
                         * Use INTEGER as the base type for constraint checking in 'PRED/'SUCC. */
                        if (def_type->kind == TYPE_INTEGER && type->base_type == NULL) {
                            type->base_type = sm->type_integer;
                        }

                        if (def_type->kind == TYPE_ARRAY) {
                            type->array = def_type->array;
                        } else if (def_type->kind == TYPE_FIXED) {
                            type->fixed = def_type->fixed;  /* Copy delta, small, scale */
                        } else if (def_type->kind == TYPE_RECORD) {
                            type->record = def_type->record;

                            /* Add discriminants as accessible record components (RM 3.7.1)
                             * Discriminants can be accessed like normal components: R.D1 */
                            if (has_discriminants) {
                                /* Count total discriminant names */
                                uint32_t disc_count = 0;
                                for (uint32_t i = 0; i < node->type_decl.discriminants.count; i++) {
                                    Syntax_Node *disc_spec = node->type_decl.discriminants.items[i];
                                    if (disc_spec->kind == NK_DISCRIMINANT_SPEC) {
                                        disc_count += disc_spec->discriminant.names.count;
                                    }
                                }

                                /* Create new components array with discriminants at the start */
                                uint32_t old_count = type->record.component_count;
                                uint32_t new_count = old_count + disc_count;
                                Component_Info *new_comps = Arena_Allocate(
                                    new_count * sizeof(Component_Info));

                                /* Add discriminants first (they come before other components) */
                                uint32_t disc_idx = 0;
                                uint32_t disc_offset = 0;  /* Running offset for discriminants */
                                for (uint32_t i = 0; i < node->type_decl.discriminants.count; i++) {
                                    Syntax_Node *disc_spec = node->type_decl.discriminants.items[i];
                                    if (disc_spec->kind == NK_DISCRIMINANT_SPEC) {
                                        Type_Info *disc_type = sm->type_integer;
                                        if (disc_spec->discriminant.disc_type &&
                                            disc_spec->discriminant.disc_type->type) {
                                            disc_type = disc_spec->discriminant.disc_type->type;
                                        }
                                        uint32_t disc_size = disc_type ? disc_type->size : 8;
                                        for (uint32_t j = 0; j < disc_spec->discriminant.names.count; j++) {
                                            Syntax_Node *name_node = disc_spec->discriminant.names.items[j];
                                            new_comps[disc_idx].name = name_node->string_val.text;
                                            new_comps[disc_idx].component_type = disc_type;
                                            new_comps[disc_idx].byte_offset = disc_offset;
                                            new_comps[disc_idx].bit_offset = 0;
                                            new_comps[disc_idx].bit_size = disc_size * 8;
                                            disc_offset += disc_size;
                                            disc_idx++;
                                        }
                                    }
                                }

                                /* Copy existing components after discriminants, adjusting offsets */
                                for (uint32_t i = 0; i < old_count; i++) {
                                    new_comps[disc_count + i] = type->record.components[i];
                                    new_comps[disc_count + i].byte_offset += disc_offset;
                                }

                                /* Update record size to include discriminants */
                                type->size += disc_offset;

                                type->record.components = new_comps;
                                type->record.component_count = new_count;
                            }
                        } else if (def_type->kind == TYPE_ACCESS) {
                            type->access = def_type->access;
                        } else if (def_type->kind == TYPE_ENUMERATION) {
                            type->enumeration = def_type->enumeration;

                            /* Create symbols for enumeration literals
                             * They must reference the named type (type), not the anonymous def_type */
                            if (node->type_decl.definition &&
                                node->type_decl.definition->kind == NK_ENUMERATION_TYPE) {
                                Node_List *lits = &node->type_decl.definition->enum_type.literals;
                                for (uint32_t i = 0; i < lits->count; i++) {
                                    Syntax_Node *lit = lits->items[i];
                                    Symbol *lit_sym = Symbol_New(SYMBOL_LITERAL, lit->string_val.text, lit->location);
                                    lit_sym->type = type;  /* Reference the named type */
                                    lit_sym->frame_offset = (int64_t)i;  /* Store ordinal position */
                                    Symbol_Add(sm, lit_sym);
                                    lit->symbol = lit_sym;
                                }
                            }
                        }
                    }
                }

                /* Pop discriminant scope if we pushed one */
                if (has_discriminants) {
                    Symbol_Manager_Pop_Scope(sm);
                }
            }
            break;

        case NK_SUBTYPE_DECL:
            {
                Symbol *sym = Symbol_New(SYMBOL_SUBTYPE, node->type_decl.name, node->location);
                Symbol_Add(sm, sym);
                node->symbol = sym;

                if (node->type_decl.definition) {
                    Resolve_Expression(sm, node->type_decl.definition);
                    sym->type = node->type_decl.definition->type;
                }
            }
            break;

        case NK_PROCEDURE_SPEC:
        case NK_FUNCTION_SPEC:
            {
                /* Count total parameters first (needed for overload matching) */
                Node_List *param_list = &node->subprogram_spec.parameters;
                uint32_t total_params = 0;
                for (uint32_t i = 0; i < param_list->count; i++) {
                    Syntax_Node *ps = param_list->items[i];
                    if (ps->kind == NK_PARAM_SPEC) {
                        total_params += ps->param_spec.names.count;
                    }
                }

                /* Check if there's already a matching symbol from package spec.
                 * This happens when resolving a subprogram body that completes a spec.
                 * For overloaded subprograms, must match parameter count AND types. */
                Symbol_Kind expected_kind = node->kind == NK_PROCEDURE_SPEC ?
                                           SYMBOL_PROCEDURE : SYMBOL_FUNCTION;
                Symbol *sym = Symbol_Find(sm, node->subprogram_spec.name);
                while (sym) {
                    if (sym->kind == expected_kind && sym->parameter_count == total_params) {
                        /* Check parameter types match */
                        bool types_match = true;
                        uint32_t param_idx = 0;
                        for (uint32_t i = 0; i < param_list->count && types_match; i++) {
                            Syntax_Node *ps = param_list->items[i];
                            if (ps->kind == NK_PARAM_SPEC) {
                                /* Resolve param type first */
                                if (ps->param_spec.param_type) {
                                    Resolve_Expression(sm, ps->param_spec.param_type);
                                }
                                Type_Info *body_type = ps->param_spec.param_type ?
                                                       ps->param_spec.param_type->type : NULL;
                                for (uint32_t j = 0; j < ps->param_spec.names.count; j++) {
                                    if (param_idx < sym->parameter_count) {
                                        Type_Info *spec_type = sym->parameters[param_idx].param_type;
                                        if (body_type != spec_type) {
                                            types_match = false;
                                            break;
                                        }
                                    }
                                    param_idx++;
                                }
                            }
                        }
                        /* For functions, also check return type matches (allows
                         * overloading on return type per Ada RM 6.6) */
                        if (types_match && expected_kind == SYMBOL_FUNCTION) {
                            if (node->subprogram_spec.return_type) {
                                Resolve_Expression(sm, node->subprogram_spec.return_type);
                                Type_Info *body_return = node->subprogram_spec.return_type->type;
                                if (body_return != sym->return_type) {
                                    types_match = false;
                                }
                            }
                        }
                        /* Found matching spec - check it's not already claimed */
                        if (types_match && !sym->body_claimed) {
                            sym->body_claimed = true;
                            node->symbol = sym;
                            goto spec_matched;
                        }
                    }
                    sym = sym->next_overload;
                }

                /* No matching spec found - create new symbol */
                sym = Symbol_New(expected_kind, node->subprogram_spec.name, node->location);
                sym->parameter_count = total_params;
                if (total_params > 0) {
                    sym->parameters = Arena_Allocate(total_params * sizeof(Parameter_Info));
                    uint32_t param_idx = 0;
                    for (uint32_t i = 0; i < param_list->count; i++) {
                        Syntax_Node *ps = param_list->items[i];
                        if (ps->kind == NK_PARAM_SPEC) {
                            /* Resolve parameter type */
                            if (ps->param_spec.param_type) {
                                Resolve_Expression(sm, ps->param_spec.param_type);
                            }
                            Type_Info *pt = ps->param_spec.param_type ?
                                          ps->param_spec.param_type->type : NULL;
                            for (uint32_t j = 0; j < ps->param_spec.names.count; j++) {
                                Syntax_Node *name = ps->param_spec.names.items[j];
                                sym->parameters[param_idx].name = name->string_val.text;
                                sym->parameters[param_idx].param_type = pt;
                                sym->parameters[param_idx].mode = (Parameter_Mode)ps->param_spec.mode;
                                sym->parameters[param_idx].default_value = ps->param_spec.default_expr;
                                param_idx++;
                            }
                        }
                    }
                }

                if (node->subprogram_spec.return_type) {
                    Resolve_Expression(sm, node->subprogram_spec.return_type);
                    sym->return_type = node->subprogram_spec.return_type->type;
                }
                Symbol_Add(sm, sym);
                node->symbol = sym;
            spec_matched:;
            }
            break;

        case NK_SUBPROGRAM_RENAMING:
            /* PROCEDURE P RENAMES Q; or FUNCTION F RENAMES G; */
            {
                /* Resolve the renamed subprogram */
                if (node->subprogram_spec.renamed) {
                    Resolve_Expression(sm, node->subprogram_spec.renamed);
                }
                Symbol *renamed_sym = node->subprogram_spec.renamed ?
                                      node->subprogram_spec.renamed->symbol : NULL;

                /* Create new symbol for the rename */
                bool is_proc = !node->subprogram_spec.return_type;
                Symbol *sym = Symbol_New(
                    is_proc ? SYMBOL_PROCEDURE : SYMBOL_FUNCTION,
                    node->subprogram_spec.name, node->location);

                /* Copy info from renamed subprogram if available */
                if (renamed_sym) {
                    sym->parameters = renamed_sym->parameters;
                    sym->parameter_count = renamed_sym->parameter_count;
                    sym->return_type = renamed_sym->return_type;
                    sym->renamed_object = (Syntax_Node *)renamed_sym;  /* Store reference */
                } else {
                    /* Build parameter info from our own spec */
                    Node_List *param_list = &node->subprogram_spec.parameters;
                    uint32_t total_params = 0;
                    for (uint32_t i = 0; i < param_list->count; i++) {
                        Syntax_Node *ps = param_list->items[i];
                        if (ps->kind == NK_PARAM_SPEC)
                            total_params += ps->param_spec.names.count;
                    }
                    sym->parameter_count = total_params;
                    if (total_params > 0) {
                        sym->parameters = Arena_Allocate(total_params * sizeof(Parameter_Info));
                        uint32_t idx = 0;
                        for (uint32_t i = 0; i < param_list->count; i++) {
                            Syntax_Node *ps = param_list->items[i];
                            if (ps->kind == NK_PARAM_SPEC) {
                                if (ps->param_spec.param_type)
                                    Resolve_Expression(sm, ps->param_spec.param_type);
                                Type_Info *pt = ps->param_spec.param_type ?
                                              ps->param_spec.param_type->type : NULL;
                                for (uint32_t j = 0; j < ps->param_spec.names.count; j++) {
                                    Syntax_Node *nm = ps->param_spec.names.items[j];
                                    sym->parameters[idx].name = nm->string_val.text;
                                    sym->parameters[idx].param_type = pt;
                                    sym->parameters[idx].mode = (Parameter_Mode)ps->param_spec.mode;
                                    sym->parameters[idx].default_value = ps->param_spec.default_expr;
                                    idx++;
                                }
                            }
                        }
                    }
                    if (node->subprogram_spec.return_type) {
                        Resolve_Expression(sm, node->subprogram_spec.return_type);
                        sym->return_type = node->subprogram_spec.return_type->type;
                    }
                }
                Symbol_Add(sm, sym);
                node->symbol = sym;
            }
            break;

        case NK_PROCEDURE_BODY:
        case NK_FUNCTION_BODY:
            {
                /* Check if this body completes a generic declaration */
                Syntax_Node *spec = node->subprogram_body.specification;
                String_Slice body_name = spec ? spec->subprogram_spec.name : (String_Slice){0};

                Symbol *matching_generic = Symbol_Find(sm, body_name);
                if (matching_generic && matching_generic->kind == SYMBOL_GENERIC) {
                    /* This body completes a generic - store it and resolve it.
                     * Push scope with generic formals so T, F etc. are visible. */
                    matching_generic->generic_body = node;
                    node->symbol = matching_generic;

                    /* Push scope for generic body resolution */
                    Symbol_Manager_Push_Scope(sm, matching_generic);

                    /* Add generic formal parameters (types, objects, subprograms) to scope */
                    if (matching_generic->declaration &&
                        matching_generic->declaration->kind == NK_GENERIC_DECL) {
                        Node_List *formals = &matching_generic->declaration->generic_decl.formals;
                        for (uint32_t i = 0; i < formals->count; i++) {
                            Syntax_Node *formal = formals->items[i];
                            if (!formal) continue;
                            if (formal->kind == NK_GENERIC_TYPE_PARAM) {
                                /* Add formal type as a type symbol (use PRIVATE as placeholder) */
                                Symbol *type_sym = Symbol_New(SYMBOL_TYPE,
                                    formal->generic_type_param.name, formal->location);
                                type_sym->type = Type_New(TYPE_PRIVATE,
                                    formal->generic_type_param.name);
                                Symbol_Add(sm, type_sym);
                                formal->symbol = type_sym;
                            } else if (formal->kind == NK_GENERIC_SUBPROGRAM_PARAM) {
                                /* Create and add formal subprogram symbol if not exists */
                                if (!formal->symbol) {
                                    String_Slice name = formal->generic_subprog_param.name;
                                    Symbol_Kind sk = formal->generic_subprog_param.is_function ?
                                                     SYMBOL_FUNCTION : SYMBOL_PROCEDURE;
                                    Symbol *subprog_sym = Symbol_New(sk, name, formal->location);

                                    /* Set up parameter info */
                                    Node_List *fparams = &formal->generic_subprog_param.parameters;
                                    uint32_t total_params = 0;
                                    for (uint32_t j = 0; j < fparams->count; j++) {
                                        Syntax_Node *ps = fparams->items[j];
                                        if (ps && ps->kind == NK_PARAM_SPEC)
                                            total_params += ps->param_spec.names.count;
                                    }
                                    subprog_sym->parameter_count = total_params;
                                    if (total_params > 0) {
                                        subprog_sym->parameters = Arena_Allocate(
                                            total_params * sizeof(Parameter_Info));
                                        uint32_t idx = 0;
                                        for (uint32_t j = 0; j < fparams->count; j++) {
                                            Syntax_Node *ps = fparams->items[j];
                                            if (ps && ps->kind == NK_PARAM_SPEC) {
                                                Type_Info *pt = NULL;
                                                if (ps->param_spec.param_type) {
                                                    Resolve_Expression(sm, ps->param_spec.param_type);
                                                    pt = ps->param_spec.param_type->type;
                                                }
                                                for (uint32_t k = 0; k < ps->param_spec.names.count; k++) {
                                                    Syntax_Node *pn = ps->param_spec.names.items[k];
                                                    subprog_sym->parameters[idx].name = pn->string_val.text;
                                                    subprog_sym->parameters[idx].param_type = pt;
                                                    subprog_sym->parameters[idx].mode =
                                                        (Parameter_Mode)ps->param_spec.mode;
                                                    idx++;
                                                }
                                            }
                                        }
                                    }

                                    /* Set return type for functions */
                                    if (formal->generic_subprog_param.is_function &&
                                        formal->generic_subprog_param.return_type) {
                                        Resolve_Expression(sm, formal->generic_subprog_param.return_type);
                                        subprog_sym->type = formal->generic_subprog_param.return_type->type;
                                        subprog_sym->return_type = subprog_sym->type;
                                    }
                                    formal->symbol = subprog_sym;
                                }
                                Symbol_Add(sm, formal->symbol);
                            } else if (formal->kind == NK_GENERIC_OBJECT_PARAM) {
                                /* Add formal object(s) as variable(s) with their declared type.
                                 * e.g., "I1, I2 : INTEGER" creates two symbols of type INTEGER */
                                Type_Info *obj_type = NULL;
                                if (formal->generic_object_param.object_type) {
                                    Resolve_Expression(sm, formal->generic_object_param.object_type);
                                    obj_type = formal->generic_object_param.object_type->type;
                                }
                                for (uint32_t j = 0; j < formal->generic_object_param.names.count; j++) {
                                    Syntax_Node *name_node = formal->generic_object_param.names.items[j];
                                    Symbol *obj_sym = Symbol_New(SYMBOL_VARIABLE,
                                        name_node->string_val.text, formal->location);
                                    obj_sym->type = obj_type;
                                    Symbol_Add(sm, obj_sym);
                                    name_node->symbol = obj_sym;
                                }
                            }
                        }
                    }

                    /* Add body parameters to scope */
                    if (spec) {
                        Node_List *params = &spec->subprogram_spec.parameters;
                        for (uint32_t i = 0; i < params->count; i++) {
                            Syntax_Node *param = params->items[i];
                            if (param && param->kind == NK_PARAM_SPEC) {
                                /* Resolve parameter type (may reference generic formals) */
                                if (param->param_spec.param_type)
                                    Resolve_Expression(sm, param->param_spec.param_type);
                                /* Add each parameter name as a symbol */
                                for (uint32_t j = 0; j < param->param_spec.names.count; j++) {
                                    Syntax_Node *name = param->param_spec.names.items[j];
                                    Symbol *param_sym = Symbol_New(SYMBOL_PARAMETER,
                                        name->string_val.text, name->location);
                                    if (param->param_spec.param_type)
                                        param_sym->type = param->param_spec.param_type->type;
                                    Symbol_Add(sm, param_sym);
                                    name->symbol = param_sym;
                                }
                            }
                        }
                    }

                    /* Resolve declarations and statements in the generic body */
                    Resolve_Declaration_List(sm, &node->subprogram_body.declarations);
                    Resolve_Statement_List(sm, &node->subprogram_body.statements);

                    /* Resolve exception handlers */
                    for (uint32_t i = 0; i < node->subprogram_body.handlers.count; i++) {
                        Resolve_Statement(sm, node->subprogram_body.handlers.items[i]);
                    }

                    Symbol_Manager_Pop_Scope(sm);
                    break;
                }

                /* Resolve spec if present */
                if (spec) {
                    Resolve_Declaration(sm, spec);
                    node->symbol = spec->symbol;
                }

                /* For stubs (IS SEPARATE), don't claim the symbol - the separate
                 * subunit will provide the actual body and should claim it. */
                if (node->subprogram_body.is_separate && node->symbol) {
                    node->symbol->body_claimed = false;
                }

                /* Push scope for body */
                Symbol_Manager_Push_Scope(sm, node->symbol);

                /* Link the scope to the symbol for static link access */
                if (node->symbol) {
                    node->symbol->scope = sm->current_scope;
                }

                /* Add parameters to scope and link to Parameter_Info */
                if (spec) {
                    Symbol *func_sym = node->symbol;
                    uint32_t param_idx = 0;
                    Node_List *params = &spec->subprogram_spec.parameters;
                    for (uint32_t i = 0; i < params->count; i++) {
                        Syntax_Node *param = params->items[i];
                        if (param->kind == NK_PARAM_SPEC) {
                            /* Resolve parameter type */
                            if (param->param_spec.param_type) {
                                Resolve_Expression(sm, param->param_spec.param_type);
                            }
                            /* Add each parameter name as a symbol */
                            for (uint32_t j = 0; j < param->param_spec.names.count; j++) {
                                Syntax_Node *name = param->param_spec.names.items[j];
                                Symbol *param_sym = Symbol_New(SYMBOL_PARAMETER,
                                    name->string_val.text, name->location);
                                if (param->param_spec.param_type) {
                                    param_sym->type = param->param_spec.param_type->type;
                                }
                                Symbol_Add(sm, param_sym);
                                name->symbol = param_sym;
                                /* Link to Parameter_Info for code generation */
                                if (func_sym && param_idx < func_sym->parameter_count) {
                                    func_sym->parameters[param_idx].param_sym = param_sym;
                                }
                                param_idx++;
                            }
                        }
                    }
                }

                /* Resolve declarations and statements */
                Resolve_Declaration_List(sm, &node->subprogram_body.declarations);
                /* Freeze all types at end of declarative part (RM 13.14) */
                Freeze_Declaration_List(&node->subprogram_body.declarations);
                Resolve_Statement_List(sm, &node->subprogram_body.statements);

                /* Resolve exception handlers */
                for (uint32_t i = 0; i < node->subprogram_body.handlers.count; i++) {
                    Resolve_Statement(sm, node->subprogram_body.handlers.items[i]);
                }

                Symbol_Manager_Pop_Scope(sm);
            }
            break;

        case NK_TASK_SPEC:
            {
                /* Task declaration creates a task type and optionally an object */
                Symbol *type_sym = Symbol_New(SYMBOL_TYPE, node->task_spec.name, node->location);
                Type_Info *type = Type_New(TYPE_TASK, node->task_spec.name);
                type_sym->type = type;
                type->defining_symbol = type_sym;
                type_sym->declaration = node;
                Symbol_Add(sm, type_sym);
                node->symbol = type_sym;

                /* If not a task TYPE, also create an object of that type */
                if (!node->task_spec.is_type) {
                    Symbol *obj_sym = Symbol_New(SYMBOL_VARIABLE, node->task_spec.name, node->location);
                    obj_sym->type = type;
                    obj_sym->declaration = node;
                    /* Add the object symbol - it will shadow the type for normal lookups */
                    Symbol_Add(sm, obj_sym);
                }

                /* Push scope for task entries */
                Symbol_Manager_Push_Scope(sm, type_sym);

                /* Resolve and add entry declarations */
                uint32_t entry_idx_counter = 0;  /* Counter for unique entry indices */
                for (uint32_t i = 0; i < node->task_spec.entries.count; i++) {
                    Syntax_Node *entry = node->task_spec.entries.items[i];
                    if (entry->kind == NK_ENTRY_DECL) {
                        Symbol *entry_sym = Symbol_New(SYMBOL_ENTRY,
                            entry->entry_decl.name, entry->location);
                        entry_sym->declaration = entry;
                        entry_sym->parent = type_sym;
                        entry_sym->entry_index = entry_idx_counter++;  /* Assign unique entry index */

                        /* Count entry parameters */
                        uint32_t param_count = 0;
                        for (uint32_t j = 0; j < entry->entry_decl.parameters.count; j++) {
                            Syntax_Node *ps = entry->entry_decl.parameters.items[j];
                            if (ps->kind == NK_PARAM_SPEC) {
                                param_count += ps->param_spec.names.count;
                            }
                        }
                        entry_sym->parameter_count = param_count;
                        if (param_count > 0) {
                            entry_sym->parameters = Arena_Allocate(param_count * sizeof(Parameter_Info));
                            uint32_t pi = 0;
                            for (uint32_t j = 0; j < entry->entry_decl.parameters.count; j++) {
                                Syntax_Node *ps = entry->entry_decl.parameters.items[j];
                                if (ps->kind == NK_PARAM_SPEC) {
                                    if (ps->param_spec.param_type) {
                                        Resolve_Expression(sm, ps->param_spec.param_type);
                                    }
                                    for (uint32_t k = 0; k < ps->param_spec.names.count; k++) {
                                        entry_sym->parameters[pi].name = ps->param_spec.names.items[k]->string_val.text;
                                        entry_sym->parameters[pi].param_type = ps->param_spec.param_type ?
                                            ps->param_spec.param_type->type : NULL;
                                        entry_sym->parameters[pi].mode = (Parameter_Mode)ps->param_spec.mode;
                                        pi++;
                                    }
                                }
                            }
                        }
                        Symbol_Add(sm, entry_sym);
                        entry->symbol = entry_sym;

                        /* Add entry to type's exported symbols */
                        if (type_sym->exported_count < 100) {
                            if (!type_sym->exported) {
                                type_sym->exported = Arena_Allocate(100 * sizeof(Symbol*));
                            }
                            type_sym->exported[type_sym->exported_count++] = entry_sym;
                        }
                    }
                }
                Symbol_Manager_Pop_Scope(sm);
            }
            break;

        case NK_TASK_BODY:
            {
                /* Find the task spec symbol */
                Symbol *task_sym = Symbol_Find(sm, node->task_body.name);
                if (!task_sym) {
                    /* Create a symbol for the task body if spec wasn't found */
                    task_sym = Symbol_New(SYMBOL_PROCEDURE, node->task_body.name, node->location);
                    task_sym->declaration = node;
                    Symbol_Add(sm, task_sym);
                }
                node->symbol = task_sym;

                /* Push scope for task body */
                Symbol_Manager_Push_Scope(sm, task_sym);

                /* Import entries from task spec into body scope (RM 9.1)
                 * Entries declared in the task spec are visible inside the task body.
                 * For single tasks, task_sym is SYMBOL_VARIABLE with TYPE_TASK;
                 * the entries are on the type's defining_symbol. */
                Symbol *type_sym = NULL;
                if (task_sym->kind == SYMBOL_TYPE && task_sym->type &&
                    task_sym->type->kind == TYPE_TASK) {
                    /* task_sym is the type symbol directly (task type declaration) */
                    type_sym = task_sym;
                } else if (task_sym->type && task_sym->type->kind == TYPE_TASK &&
                           task_sym->type->defining_symbol) {
                    /* task_sym is the variable; get the type's defining symbol */
                    type_sym = task_sym->type->defining_symbol;
                }
                if (type_sym && type_sym->exported) {
                    for (uint32_t i = 0; i < type_sym->exported_count; i++) {
                        Symbol *entry_sym = type_sym->exported[i];
                        if (entry_sym) {
                            Symbol_Add(sm, entry_sym);
                        }
                    }
                }

                /* Resolve declarations and statements */
                Resolve_Declaration_List(sm, &node->task_body.declarations);
                Resolve_Statement_List(sm, &node->task_body.statements);

                /* Resolve exception handlers */
                for (uint32_t i = 0; i < node->task_body.handlers.count; i++) {
                    Resolve_Statement(sm, node->task_body.handlers.items[i]);
                }

                Symbol_Manager_Pop_Scope(sm);
            }
            break;

        case NK_PACKAGE_SPEC:
            {
                Symbol *sym = Symbol_New(SYMBOL_PACKAGE, node->package_spec.name, node->location);
                sym->declaration = node;  /* Store declaration for body to find */
                Symbol_Add(sm, sym);
                node->symbol = sym;

                Symbol_Manager_Push_Scope(sm, sym);
                Resolve_Declaration_List(sm, &node->package_spec.visible_decls);
                Resolve_Declaration_List(sm, &node->package_spec.private_decls);
                /* End of package spec freezes all declared entities (RM 13.14) */
                Freeze_Declaration_List(&node->package_spec.visible_decls);
                Freeze_Declaration_List(&node->package_spec.private_decls);
                /* Populate exports for nested/inline package access (e.g., INNER.ACC) */
                Populate_Package_Exports(sym, node);
                Symbol_Manager_Pop_Scope(sm);
            }
            break;

        case NK_PACKAGE_BODY:
            {
                /* Find or create package symbol for proper name mangling */
                Symbol *pkg_sym = NULL;
                String_Slice pkg_name = node->package_body.name;
                if (pkg_name.length > 0) {
                    /* Mark this body as loaded BEFORE trying to load the spec.
                     * This prevents Load_Package_Spec from recursively loading
                     * the same body when we're compiling a .adb file directly. */
                    Mark_Body_Loaded(pkg_name);

                    pkg_sym = Symbol_Find(sm, pkg_name);
                    if (!pkg_sym) {
                        /* Try to load corresponding package spec first.
                         * This ensures body uses same symbol IDs as spec */
                        char *spec_src = Lookup_Path(pkg_name);
                        if (spec_src) {
                            Load_Package_Spec(sm, pkg_name, spec_src);
                            pkg_sym = Symbol_Find(sm, pkg_name);
                        }
                        if (!pkg_sym) {
                            /* Create package symbol if spec not found */
                            pkg_sym = Symbol_New(SYMBOL_PACKAGE, pkg_name, node->location);
                            Symbol_Add(sm, pkg_sym);
                        }
                    }
                    node->symbol = pkg_sym;
                }
                Symbol_Manager_Push_Scope(sm, pkg_sym);

                /* Set package symbol's scope for separate subunit resolution.
                 * This allows SEPARATE (Parent) subunits to find stub symbols. */
                if (pkg_sym) {
                    pkg_sym->scope = sm->current_scope;
                }

                /* Install visible and private declarations from package spec
                 * into the body's scope (RM 7.1, 7.2) */
                Syntax_Node *spec = NULL;

                /* Handle generic packages: formals and unit are in the generic declaration */
                if (pkg_sym && pkg_sym->kind == SYMBOL_GENERIC) {
                    /* Store this body as the generic's body for later instantiation */
                    pkg_sym->generic_body = node;

                    /* Install generic formal parameters first */
                    if (pkg_sym->declaration &&
                        pkg_sym->declaration->kind == NK_GENERIC_DECL) {
                        Node_List *formals = &pkg_sym->declaration->generic_decl.formals;
                        for (uint32_t i = 0; i < formals->count; i++) {
                            Syntax_Node *formal = formals->items[i];
                            if (formal->symbol) {
                                Symbol_Add(sm, formal->symbol);
                            }
                            /* For generic type parameters, create/install a type symbol */
                            if (formal->kind == NK_GENERIC_TYPE_PARAM && !formal->symbol) {
                                Symbol *type_sym = Symbol_New(SYMBOL_TYPE,
                                    formal->generic_type_param.name, formal->location);
                                /* Map def_kind to appropriate Type_Kind:
                                 * 0=PRIVATE, 1=LIMITED_PRIVATE, 2=DISCRETE, 3=INTEGER, 4=FLOAT, 5=FIXED */
                                Type_Kind tk = TYPE_PRIVATE;
                                switch (formal->generic_type_param.def_kind) {
                                    case 2: tk = TYPE_ENUMERATION; break; /* DISCRETE */
                                    case 3: tk = TYPE_INTEGER; break;     /* INTEGER (range <>) */
                                    case 4: tk = TYPE_FLOAT; break;       /* FLOAT (digits <>) */
                                    case 5: tk = TYPE_FIXED; break;       /* FIXED (delta <>) */
                                    default: tk = TYPE_PRIVATE; break;
                                }
                                Type_Info *type = Type_New(tk, formal->generic_type_param.name);
                                type_sym->type = type;
                                formal->symbol = type_sym;
                                Symbol_Add(sm, type_sym);
                            }
                            /* For generic object parameters, create/install object symbols */
                            if (formal->kind == NK_GENERIC_OBJECT_PARAM) {
                                /* Resolve the object type */
                                Type_Info *obj_type = NULL;
                                if (formal->generic_object_param.object_type) {
                                    Resolve_Expression(sm, formal->generic_object_param.object_type);
                                    obj_type = formal->generic_object_param.object_type->type;
                                }
                                /* Create symbols for each name */
                                for (uint32_t j = 0; j < formal->generic_object_param.names.count; j++) {
                                    Syntax_Node *name_node = formal->generic_object_param.names.items[j];
                                    if (name_node && name_node->kind == NK_IDENTIFIER) {
                                        Symbol *obj_sym = Symbol_New(SYMBOL_CONSTANT,
                                            name_node->string_val.text, name_node->location);
                                        obj_sym->type = obj_type;
                                        name_node->symbol = obj_sym;
                                        Symbol_Add(sm, obj_sym);
                                    }
                                }
                            }
                            /* For generic subprogram parameters, create procedure/function symbols
                             * so calls to formal subprograms resolve during generic body analysis */
                            if (formal->kind == NK_GENERIC_SUBPROGRAM_PARAM) {
                                String_Slice name = formal->generic_subprog_param.name;
                                Symbol_Kind sk = formal->generic_subprog_param.is_function ?
                                                 SYMBOL_FUNCTION : SYMBOL_PROCEDURE;
                                Symbol *subprog_sym = Symbol_New(sk, name, formal->location);

                                /* Count total parameters */
                                Node_List *params = &formal->generic_subprog_param.parameters;
                                uint32_t total_params = 0;
                                for (uint32_t j = 0; j < params->count; j++) {
                                    Syntax_Node *ps = params->items[j];
                                    if (ps->kind == NK_PARAM_SPEC) {
                                        total_params += ps->param_spec.names.count;
                                    }
                                }

                                /* Allocate and fill parameter info */
                                subprog_sym->parameter_count = total_params;
                                if (total_params > 0) {
                                    subprog_sym->parameters = Arena_Allocate(
                                        total_params * sizeof(Parameter_Info));
                                    uint32_t idx = 0;
                                    for (uint32_t j = 0; j < params->count; j++) {
                                        Syntax_Node *ps = params->items[j];
                                        if (ps->kind == NK_PARAM_SPEC) {
                                            /* Resolve param type - may reference earlier formal types */
                                            Type_Info *pt = NULL;
                                            if (ps->param_spec.param_type) {
                                                Resolve_Expression(sm, ps->param_spec.param_type);
                                                pt = ps->param_spec.param_type->type;
                                            }
                                            for (uint32_t k = 0; k < ps->param_spec.names.count; k++) {
                                                Syntax_Node *pn = ps->param_spec.names.items[k];
                                                subprog_sym->parameters[idx].name = pn->string_val.text;
                                                subprog_sym->parameters[idx].param_type = pt;
                                                subprog_sym->parameters[idx].mode =
                                                    (Parameter_Mode)ps->param_spec.mode;
                                                idx++;
                                            }
                                        }
                                    }
                                }

                                /* For functions, set return type */
                                if (formal->generic_subprog_param.is_function &&
                                    formal->generic_subprog_param.return_type) {
                                    Resolve_Expression(sm, formal->generic_subprog_param.return_type);
                                    subprog_sym->type = formal->generic_subprog_param.return_type->type;
                                }

                                formal->symbol = subprog_sym;
                                Symbol_Add(sm, subprog_sym);
                            }
                        }
                    }
                    /* Get the package spec from the generic unit */
                    spec = pkg_sym->generic_unit;

                    /* For generic package body, resolve the spec first if not done */
                    if (spec && spec->kind == NK_PACKAGE_SPEC) {
                        Resolve_Declaration_List(sm, &spec->package_spec.visible_decls);
                        Resolve_Declaration_List(sm, &spec->package_spec.private_decls);
                    }
                } else if (pkg_sym && pkg_sym->declaration &&
                           pkg_sym->declaration->kind == NK_PACKAGE_SPEC) {
                    spec = pkg_sym->declaration;
                }

                if (spec && spec->kind == NK_PACKAGE_SPEC) {
                    /* Install visible declarations */
                    for (uint32_t i = 0; i < spec->package_spec.visible_decls.count; i++) {
                        Syntax_Node *decl = spec->package_spec.visible_decls.items[i];
                        if (decl->symbol) Symbol_Add(sm, decl->symbol);
                        if (decl->kind == NK_OBJECT_DECL) {
                            for (uint32_t j = 0; j < decl->object_decl.names.count; j++) {
                                Syntax_Node *name = decl->object_decl.names.items[j];
                                if (name->symbol) Symbol_Add(sm, name->symbol);
                            }
                        }
                        /* Install exception symbols (similar to object decls) */
                        if (decl->kind == NK_EXCEPTION_DECL) {
                            for (uint32_t j = 0; j < decl->exception_decl.names.count; j++) {
                                Syntax_Node *name = decl->exception_decl.names.items[j];
                                if (name->symbol) Symbol_Add(sm, name->symbol);
                            }
                        }
                        if (decl->kind == NK_TYPE_DECL && decl->type_decl.definition &&
                            decl->type_decl.definition->kind == NK_ENUMERATION_TYPE) {
                            Node_List *lits = &decl->type_decl.definition->enum_type.literals;
                            for (uint32_t j = 0; j < lits->count; j++) {
                                if (lits->items[j]->symbol) Symbol_Add(sm, lits->items[j]->symbol);
                            }
                        }
                    }
                    /* Install private declarations */
                    for (uint32_t i = 0; i < spec->package_spec.private_decls.count; i++) {
                        Syntax_Node *decl = spec->package_spec.private_decls.items[i];
                        if (decl->symbol) Symbol_Add(sm, decl->symbol);
                        if (decl->kind == NK_OBJECT_DECL) {
                            for (uint32_t j = 0; j < decl->object_decl.names.count; j++) {
                                Syntax_Node *name = decl->object_decl.names.items[j];
                                if (name->symbol) Symbol_Add(sm, name->symbol);
                            }
                        }
                        /* Install exception symbols */
                        if (decl->kind == NK_EXCEPTION_DECL) {
                            for (uint32_t j = 0; j < decl->exception_decl.names.count; j++) {
                                Syntax_Node *name = decl->exception_decl.names.items[j];
                                if (name->symbol) Symbol_Add(sm, name->symbol);
                            }
                        }
                        if (decl->kind == NK_TYPE_DECL && decl->type_decl.definition &&
                            decl->type_decl.definition->kind == NK_ENUMERATION_TYPE) {
                            Node_List *lits = &decl->type_decl.definition->enum_type.literals;
                            for (uint32_t j = 0; j < lits->count; j++) {
                                if (lits->items[j]->symbol) Symbol_Add(sm, lits->items[j]->symbol);
                            }
                        }
                    }
                }

                Resolve_Declaration_List(sm, &node->package_body.declarations);
                /* Freeze all types at end of declarative part (RM 13.14) */
                Freeze_Declaration_List(&node->package_body.declarations);
                Resolve_Statement_List(sm, &node->package_body.statements);
                Symbol_Manager_Pop_Scope(sm);
            }
            break;

        case NK_USE_CLAUSE:
            /* Make package contents directly visible (Ada 83 8.4)
             * "A use clause achieves direct visibility of declarations
             *  that appear in the visible parts of the named packages" */
            for (uint32_t i = 0; i < node->use_clause.names.count; i++) {
                Syntax_Node *pkg_name_node = node->use_clause.names.items[i];
                Resolve_Expression(sm, pkg_name_node);

                /* Find the package symbol */
                Symbol *pkg_sym = NULL;
                if (pkg_name_node->kind == NK_IDENTIFIER) {
                    pkg_sym = Symbol_Find(sm, pkg_name_node->string_val.text);
                } else if (pkg_name_node->symbol) {
                    pkg_sym = pkg_name_node->symbol;
                }

                if (pkg_sym && pkg_sym->kind == SYMBOL_PACKAGE) {
                    /* Helper macro: add use-visible alias for a symbol */
                    #define ADD_USE_ALIAS(orig) do { \
                        if (orig) { \
                            /* Check if alias already exists for this symbol */ \
                            uint32_t _hash = Symbol_Hash_Name((orig)->name); \
                            bool _already_aliased = false; \
                            for (Symbol *_ex = sm->current_scope->buckets[_hash]; _ex; _ex = _ex->next_in_bucket) { \
                                if (Slice_Equal_Ignore_Case(_ex->name, (orig)->name) && \
                                    _ex->visibility == VIS_USE_VISIBLE && \
                                    _ex->unique_id == (orig)->unique_id) { \
                                    _already_aliased = true; \
                                    break; \
                                } \
                            } \
                            if (!_already_aliased) { \
                                Symbol *alias = Symbol_New((orig)->kind, (orig)->name, (orig)->location); \
                                alias->type = (orig)->type; \
                                alias->declaration = (orig)->declaration; \
                                alias->visibility = VIS_USE_VISIBLE; \
                                alias->parameter_count = (orig)->parameter_count; \
                                alias->parameters = (orig)->parameters; \
                                alias->return_type = (orig)->return_type; \
                                alias->is_named_number = (orig)->is_named_number; \
                                alias->generic_unit = (orig)->generic_unit; \
                                alias->generic_body = (orig)->generic_body; \
                                alias->generic_formals = (orig)->generic_formals; \
                                Symbol_Add(sm, alias); \
                                alias->parent = (orig)->parent; \
                                alias->unique_id = (orig)->unique_id; \
                            } \
                        } \
                    } while(0)

                    /* For loaded packages with exported array, use it */
                    if (pkg_sym->exported_count > 0) {
                        for (uint32_t j = 0; j < pkg_sym->exported_count; j++)
                            ADD_USE_ALIAS(pkg_sym->exported[j]);
                    }
                    /* For inline packages, iterate visible declarations */
                    else if (pkg_sym->declaration && pkg_sym->declaration->kind == NK_PACKAGE_SPEC) {
                        Syntax_Node *pkg_decl = pkg_sym->declaration;
                        for (uint32_t j = 0; j < pkg_decl->package_spec.visible_decls.count; j++) {
                            Syntax_Node *decl = pkg_decl->package_spec.visible_decls.items[j];
                            if (!decl) continue;
                            if (decl->symbol) ADD_USE_ALIAS(decl->symbol);
                            /* Handle object_decl names (constants, variables) */
                            if (decl->kind == NK_OBJECT_DECL) {
                                for (uint32_t k = 0; k < decl->object_decl.names.count; k++) {
                                    Syntax_Node *nm = decl->object_decl.names.items[k];
                                    if (nm && nm->symbol) ADD_USE_ALIAS(nm->symbol);
                                }
                            }
                            /* Handle enumeration literals */
                            if ((decl->kind == NK_TYPE_DECL || decl->kind == NK_SUBTYPE_DECL) &&
                                decl->type_decl.definition &&
                                decl->type_decl.definition->kind == NK_ENUMERATION_TYPE) {
                                Node_List *lits = &decl->type_decl.definition->enum_type.literals;
                                for (uint32_t k = 0; k < lits->count; k++) {
                                    if (lits->items[k] && lits->items[k]->symbol)
                                        ADD_USE_ALIAS(lits->items[k]->symbol);
                                }
                            }
                            /* Handle exception declarations */
                            if (decl->kind == NK_EXCEPTION_DECL) {
                                for (uint32_t k = 0; k < decl->exception_decl.names.count; k++) {
                                    Syntax_Node *nm = decl->exception_decl.names.items[k];
                                    if (nm && nm->symbol) ADD_USE_ALIAS(nm->symbol);
                                }
                            }
                        }
                    }
                    #undef ADD_USE_ALIAS
                }
            }
            break;

        case NK_PRAGMA:
            /* Process pragma effects */
            {
                String_Slice pragma_name = node->pragma_node.name;

                /* pragma Inline(subprogram_name, ...) */
                if (Slice_Equal_Ignore_Case(pragma_name, S("INLINE"))) {
                    for (uint32_t i = 0; i < node->pragma_node.arguments.count; i++) {
                        Syntax_Node *arg = node->pragma_node.arguments.items[i];
                        Syntax_Node *name_node = (arg->kind == NK_ASSOCIATION) ?
                                                  arg->association.expression : arg;
                        if (name_node && name_node->kind == NK_IDENTIFIER) {
                            Symbol *sym = Symbol_Find(sm, name_node->string_val.text);
                            if (sym && (sym->kind == SYMBOL_PROCEDURE ||
                                        sym->kind == SYMBOL_FUNCTION)) {
                                sym->is_inline = true;
                            }
                        }
                    }
                }

                /* pragma Pack(type_name) */
                else if (Slice_Equal_Ignore_Case(pragma_name, S("PACK"))) {
                    if (node->pragma_node.arguments.count > 0) {
                        Syntax_Node *arg = node->pragma_node.arguments.items[0];
                        Syntax_Node *name_node = (arg->kind == NK_ASSOCIATION) ?
                                                  arg->association.expression : arg;
                        if (name_node && name_node->kind == NK_IDENTIFIER) {
                            Symbol *sym = Symbol_Find(sm, name_node->string_val.text);
                            if (sym && sym->type) {
                                sym->type->is_packed = true;
                            }
                        }
                    }
                }

                /* pragma Suppress(check_name) or pragma Suppress(check_name, entity_name) */
                else if (Slice_Equal_Ignore_Case(pragma_name, S("SUPPRESS"))) {
                    uint32_t check_bit = 0;
                    if (node->pragma_node.arguments.count > 0) {
                        Syntax_Node *arg = node->pragma_node.arguments.items[0];
                        Syntax_Node *check_node = (arg->kind == NK_ASSOCIATION) ?
                                                   arg->association.expression : arg;
                        if (check_node && check_node->kind == NK_IDENTIFIER) {
                            String_Slice check = check_node->string_val.text;
                            if (Slice_Equal_Ignore_Case(check, S("RANGE_CHECK")))
                                check_bit = 1;
                            else if (Slice_Equal_Ignore_Case(check, S("OVERFLOW_CHECK")))
                                check_bit = 2;
                            else if (Slice_Equal_Ignore_Case(check, S("INDEX_CHECK")))
                                check_bit = 4;
                            else if (Slice_Equal_Ignore_Case(check, S("LENGTH_CHECK")))
                                check_bit = 8;
                            else if (Slice_Equal_Ignore_Case(check, S("ALL_CHECKS")))
                                check_bit = 0xFFFFFFFF;
                        }
                    }

                    /* Apply to specific entity or current scope */
                    if (node->pragma_node.arguments.count > 1) {
                        Syntax_Node *arg = node->pragma_node.arguments.items[1];
                        Syntax_Node *entity = (arg->kind == NK_ASSOCIATION) ?
                                               arg->association.expression : arg;
                        if (entity && entity->kind == NK_IDENTIFIER) {
                            Symbol *sym = Symbol_Find(sm, entity->string_val.text);
                            if (sym) sym->suppressed_checks |= check_bit;
                        }
                    }
                    /* else: would apply to enclosing scope */
                }

                /* pragma Import(Convention, Entity, External_Name, Link_Name) */
                else if (Slice_Equal_Ignore_Case(pragma_name, S("IMPORT"))) {
                    if (node->pragma_node.arguments.count >= 2) {
                        /* Get convention */
                        Syntax_Node *conv_arg = node->pragma_node.arguments.items[0];
                        Syntax_Node *conv_node = (conv_arg->kind == NK_ASSOCIATION) ?
                                                  conv_arg->association.expression : conv_arg;

                        /* Get entity */
                        Syntax_Node *ent_arg = node->pragma_node.arguments.items[1];
                        Syntax_Node *ent_node = (ent_arg->kind == NK_ASSOCIATION) ?
                                                 ent_arg->association.expression : ent_arg;

                        if (ent_node && ent_node->kind == NK_IDENTIFIER) {
                            Symbol *sym = Symbol_Find(sm, ent_node->string_val.text);
                            if (sym) {
                                sym->is_imported = true;

                                /* Set convention */
                                if (conv_node && conv_node->kind == NK_IDENTIFIER) {
                                    String_Slice conv = conv_node->string_val.text;
                                    if (Slice_Equal_Ignore_Case(conv, S("C")))
                                        sym->convention = CONVENTION_C;
                                    else if (Slice_Equal_Ignore_Case(conv, S("STDCALL")))
                                        sym->convention = CONVENTION_STDCALL;
                                    else if (Slice_Equal_Ignore_Case(conv, S("INTRINSIC")))
                                        sym->convention = CONVENTION_INTRINSIC;
                                }

                                /* Get external name if provided */
                                if (node->pragma_node.arguments.count >= 3) {
                                    Syntax_Node *name_arg = node->pragma_node.arguments.items[2];
                                    Syntax_Node *name_node = (name_arg->kind == NK_ASSOCIATION) ?
                                                              name_arg->association.expression : name_arg;
                                    if (name_node && name_node->kind == NK_STRING) {
                                        sym->external_name = name_node->string_val.text;
                                    }
                                }
                            }
                        }
                    }
                }

                /* pragma Export(Convention, Entity, External_Name) */
                else if (Slice_Equal_Ignore_Case(pragma_name, S("EXPORT"))) {
                    if (node->pragma_node.arguments.count >= 2) {
                        Syntax_Node *conv_arg = node->pragma_node.arguments.items[0];
                        Syntax_Node *conv_node = (conv_arg->kind == NK_ASSOCIATION) ?
                                                  conv_arg->association.expression : conv_arg;

                        Syntax_Node *ent_arg = node->pragma_node.arguments.items[1];
                        Syntax_Node *ent_node = (ent_arg->kind == NK_ASSOCIATION) ?
                                                 ent_arg->association.expression : ent_arg;

                        if (ent_node && ent_node->kind == NK_IDENTIFIER) {
                            Symbol *sym = Symbol_Find(sm, ent_node->string_val.text);
                            if (sym) {
                                sym->is_exported = true;

                                if (conv_node && conv_node->kind == NK_IDENTIFIER) {
                                    String_Slice conv = conv_node->string_val.text;
                                    if (Slice_Equal_Ignore_Case(conv, S("C")))
                                        sym->convention = CONVENTION_C;
                                }

                                if (node->pragma_node.arguments.count >= 3) {
                                    Syntax_Node *name_arg = node->pragma_node.arguments.items[2];
                                    Syntax_Node *name_node = (name_arg->kind == NK_ASSOCIATION) ?
                                                              name_arg->association.expression : name_arg;
                                    if (name_node && name_node->kind == NK_STRING) {
                                        sym->external_name = name_node->string_val.text;
                                    }
                                }
                            }
                        }
                    }
                }

                /* pragma Unreferenced(name, ...) */
                else if (Slice_Equal_Ignore_Case(pragma_name, S("UNREFERENCED"))) {
                    for (uint32_t i = 0; i < node->pragma_node.arguments.count; i++) {
                        Syntax_Node *arg = node->pragma_node.arguments.items[i];
                        Syntax_Node *name_node = (arg->kind == NK_ASSOCIATION) ?
                                                  arg->association.expression : arg;
                        if (name_node && name_node->kind == NK_IDENTIFIER) {
                            Symbol *sym = Symbol_Find(sm, name_node->string_val.text);
                            if (sym) sym->is_unreferenced = true;
                        }
                    }
                }

                /* pragma Convention(convention, entity) */
                else if (Slice_Equal_Ignore_Case(pragma_name, S("CONVENTION"))) {
                    if (node->pragma_node.arguments.count >= 2) {
                        Syntax_Node *conv_arg = node->pragma_node.arguments.items[0];
                        Syntax_Node *conv_node = (conv_arg->kind == NK_ASSOCIATION) ?
                                                  conv_arg->association.expression : conv_arg;

                        Syntax_Node *ent_arg = node->pragma_node.arguments.items[1];
                        Syntax_Node *ent_node = (ent_arg->kind == NK_ASSOCIATION) ?
                                                 ent_arg->association.expression : ent_arg;

                        if (ent_node && ent_node->kind == NK_IDENTIFIER) {
                            Symbol *sym = Symbol_Find(sm, ent_node->string_val.text);
                            if (sym && conv_node && conv_node->kind == NK_IDENTIFIER) {
                                String_Slice conv = conv_node->string_val.text;
                                if (Slice_Equal_Ignore_Case(conv, S("C")))
                                    sym->convention = CONVENTION_C;
                                else if (Slice_Equal_Ignore_Case(conv, S("STDCALL")))
                                    sym->convention = CONVENTION_STDCALL;
                            }
                        }
                    }
                }

                /* pragma Pure, pragma Preelaborate - informational only ??? */
                /* pragma Elaborate, pragma Elaborate_All - handled at link time ??? */
                /* pragma Restrictions - ??? */
            }
            break;

        case NK_EXCEPTION_DECL:
            /* Exception declaration: E : exception; */
            for (uint32_t i = 0; i < node->exception_decl.names.count; i++) {
                Syntax_Node *name_node = node->exception_decl.names.items[i];
                if (name_node && name_node->kind == NK_IDENTIFIER) {
                    Symbol *sym = Symbol_New(SYMBOL_EXCEPTION,
                                             name_node->string_val.text,
                                             name_node->location);
                    Symbol_Add(sm, sym);
                    name_node->symbol = sym;
                    /* Add to global exception list for codegen */
                    if (Exception_Symbol_Count < 256) {
                        Exception_Symbols[Exception_Symbol_Count++] = sym;
                    }
                }
            }
            break;

        case NK_GENERIC_DECL:
            /* Generic declaration: generic ... procedure/function/package spec */
            {
                Syntax_Node *unit = node->generic_decl.unit;
                if (!unit) break;

                /* Get name from the unit */
                String_Slice name = {0};
                if (unit->kind == NK_PROCEDURE_SPEC || unit->kind == NK_FUNCTION_SPEC) {
                    name = unit->subprogram_spec.name;
                } else if (unit->kind == NK_PACKAGE_SPEC) {
                    name = unit->package_spec.name;
                }

                /* Create generic symbol */
                Symbol *sym = Symbol_New(SYMBOL_GENERIC, name, node->location);
                sym->declaration = node;
                sym->generic_unit = unit;

                /* Store formals list for later */
                if (node->generic_decl.formals.count > 0) {
                    sym->generic_formals = node->generic_decl.formals.items[0];
                }

                Symbol_Add(sm, sym);
                node->symbol = sym;

                /* DON'T resolve the unit here - it contains generic formals
                   that need to be substituted during instantiation */
            }
            break;

        case NK_GENERIC_INST:
            /* Generic instantiation: procedure/function X is new GENERIC_NAME(actuals) */
            {
                /* Find the generic template */
                Syntax_Node *gen_name = node->generic_inst.generic_name;
                if (!gen_name) {
                    Report_Error(node->location, "expected a generic unit name");
                    break;
                }

                /* Resolve the generic name to find template */
                Resolve_Expression(sm, gen_name);
                Symbol *template = NULL;
                if (gen_name->kind == NK_IDENTIFIER) {
                    template = Symbol_Find(sm, gen_name->string_val.text);
                }

                if (!template || template->kind != SYMBOL_GENERIC) {
                    Report_Error(node->location, "expected a generic unit name");
                    break;
                }

                /* Create instance symbol */
                Symbol_Kind inst_kind;
                if (node->generic_inst.unit_kind == TK_FUNCTION)
                    inst_kind = SYMBOL_FUNCTION;
                else if (node->generic_inst.unit_kind == TK_PACKAGE)
                    inst_kind = SYMBOL_PACKAGE;
                else
                    inst_kind = SYMBOL_PROCEDURE;
                Symbol *inst_sym = Symbol_New(inst_kind,
                                              node->generic_inst.instance_name,
                                              node->location);
                inst_sym->declaration = node;
                inst_sym->generic_template = template;

                /* Process generic actuals and build mapping */
                Node_List *formals = &template->declaration->generic_decl.formals;
                Node_List *actuals = &node->generic_inst.actuals;

                inst_sym->generic_actual_count = formals->count;
                if (formals->count > 0) {
                    inst_sym->generic_actuals = Arena_Allocate(
                        formals->count * sizeof(*inst_sym->generic_actuals));

                    /* First pass: resolve type formals */
                    for (uint32_t i = 0; i < formals->count; i++) {
                        Syntax_Node *formal = formals->items[i];
                        Syntax_Node *actual = (i < actuals->count) ? actuals->items[i] : NULL;

                        /* Get formal name */
                        if (formal->kind == NK_GENERIC_TYPE_PARAM) {
                            inst_sym->generic_actuals[i].formal_name =
                                formal->generic_type_param.name;

                            /* Resolve actual type */
                            if (actual) {
                                Syntax_Node *type_node = actual;
                                if (actual->kind == NK_ASSOCIATION) {
                                    type_node = actual->association.expression;
                                }
                                Resolve_Expression(sm, type_node);
                                inst_sym->generic_actuals[i].actual_type = type_node->type;
                            }
                        }
                    }
                    /* Second pass: resolve object formals with substituted types */
                    for (uint32_t i = 0; i < formals->count; i++) {
                        Syntax_Node *formal = formals->items[i];
                        Syntax_Node *actual = (i < actuals->count) ? actuals->items[i] : NULL;

                        if (formal->kind == NK_GENERIC_OBJECT_PARAM) {
                            /* Look up the formal's type, substituting any type formals */
                            Syntax_Node *obj_type_node = formal->generic_object_param.object_type;
                            Type_Info *obj_type = NULL;
                            if (obj_type_node && obj_type_node->kind == NK_IDENTIFIER) {
                                /* Check if it's a type formal by searching earlier formals */
                                for (uint32_t k = 0; k < i; k++) {
                                    Syntax_Node *earlier = formals->items[k];
                                    if (earlier->kind == NK_GENERIC_TYPE_PARAM &&
                                        Slice_Equal_Ignore_Case(obj_type_node->string_val.text,
                                                  earlier->generic_type_param.name)) {
                                        obj_type = inst_sym->generic_actuals[k].actual_type;
                                        break;
                                    }
                                }
                            }
                            /* Propagate type to actual expression and store for substitution */
                            if (actual) {
                                Syntax_Node *expr = actual;
                                if (actual->kind == NK_ASSOCIATION) {
                                    expr = actual->association.expression;
                                }
                                if (obj_type) {
                                    /* Set type before and after resolve to handle aggregates */
                                    expr->type = obj_type;
                                    Resolve_Expression(sm, expr);
                                    /* Ensure type stays set for aggregates */
                                    if (!expr->type || expr->kind == NK_AGGREGATE) {
                                        expr->type = obj_type;
                                    }
                                } else {
                                    Resolve_Expression(sm, expr);
                                }
                                /* Store the actual expression for substitution during clone */
                                inst_sym->generic_actuals[i].actual_expr = expr;
                                /* Store formal name (first name in list) */
                                if (formal->generic_object_param.names.count > 0) {
                                    Syntax_Node *fname = formal->generic_object_param.names.items[0];
                                    if (fname)
                                        inst_sym->generic_actuals[i].formal_name = fname->string_val.text;
                                }
                            }
                        }
                    }
                    /* Third pass: resolve subprogram formals to actual subprograms */
                    for (uint32_t i = 0; i < formals->count; i++) {
                        Syntax_Node *formal = formals->items[i];
                        Syntax_Node *actual = (i < actuals->count) ? actuals->items[i] : NULL;

                        if (formal->kind == NK_GENERIC_SUBPROGRAM_PARAM) {
                            inst_sym->generic_actuals[i].formal_name =
                                formal->generic_subprog_param.name;

                            /* Resolve actual subprogram name */
                            if (actual) {
                                Syntax_Node *name_node = actual;
                                if (actual->kind == NK_ASSOCIATION) {
                                    name_node = actual->association.expression;
                                }
                                if (!name_node) continue;

                                /* Handle operator designators: "&" is the "&" operator */
                                if (name_node->kind == NK_STRING) {
                                    /* Look up operator by name */
                                    if (name_node->string_val.text.data) {
                                        Symbol *op = Symbol_Find(sm, name_node->string_val.text);
                                        if (op && (op->kind == SYMBOL_FUNCTION || op->kind == SYMBOL_PROCEDURE)) {
                                            name_node->symbol = op;
                                            inst_sym->generic_actuals[i].actual_subprogram = op;
                                        } else {
                                            /* Check for built-in operators */
                                            /* String lexer strips quotes: "&" becomes just & */
                                            String_Slice s = name_node->string_val.text;
                                            if (s.length == 1 && s.data[0] == '&')
                                                inst_sym->generic_actuals[i].builtin_operator = TK_AMPERSAND;
                                            else if (s.length == 1 && s.data[0] == '+')
                                                inst_sym->generic_actuals[i].builtin_operator = TK_PLUS;
                                            else if (s.length == 1 && s.data[0] == '-')
                                                inst_sym->generic_actuals[i].builtin_operator = TK_MINUS;
                                            else if (s.length == 1 && s.data[0] == '*')
                                                inst_sym->generic_actuals[i].builtin_operator = TK_STAR;
                                            else if (s.length == 1 && s.data[0] == '/')
                                                inst_sym->generic_actuals[i].builtin_operator = TK_SLASH;
                                        }
                                    }
                                }
                                /* Handle character literals as enum literals: '&' from ADD_OPS */
                                else if (name_node->kind == NK_CHARACTER) {
                                    /* Character literal as enum literal (parameterless function) */
                                    if (name_node->string_val.text.data) {
                                        Symbol *lit = Symbol_Find(sm, name_node->string_val.text);
                                        if (lit && lit->kind == SYMBOL_LITERAL) {
                                            name_node->symbol = lit;
                                            inst_sym->generic_actuals[i].actual_subprogram = lit;
                                        }
                                    }
                                }
                                else {
                                    /* Look up the actual subprogram symbol */
                                    Resolve_Expression(sm, name_node);
                                    if (name_node->symbol) {
                                        inst_sym->generic_actuals[i].actual_subprogram = name_node->symbol;
                                    }
                                }
                            }
                        }
                    }
                }

                /* Copy parameter info from template unit */
                Syntax_Node *unit = template->generic_unit;
                if (unit && (unit->kind == NK_FUNCTION_SPEC || unit->kind == NK_PROCEDURE_SPEC)) {
                    Node_List *params = &unit->subprogram_spec.parameters;
                    uint32_t total_params = 0;
                    for (uint32_t i = 0; i < params->count; i++) {
                        Syntax_Node *ps = params->items[i];
                        if (ps->kind == NK_PARAM_SPEC) {
                            total_params += ps->param_spec.names.count;
                        }
                    }

                    inst_sym->parameter_count = total_params;
                    if (total_params > 0) {
                        inst_sym->parameters = Arena_Allocate(total_params * sizeof(Parameter_Info));
                        uint32_t idx = 0;
                        for (uint32_t i = 0; i < params->count; i++) {
                            Syntax_Node *ps = params->items[i];
                            if (ps->kind == NK_PARAM_SPEC) {
                                /* Resolve param type and substitute formals with actuals */
                                Type_Info *param_type = NULL;
                                if (ps->param_spec.param_type) {
                                    Syntax_Node *pt = ps->param_spec.param_type;
                                    if (pt->kind == NK_IDENTIFIER) {
                                        /* First check if formal type parameter → substitute */
                                        for (uint32_t k = 0; k < inst_sym->generic_actual_count; k++) {
                                            if (Slice_Equal_Ignore_Case(pt->string_val.text,
                                                          inst_sym->generic_actuals[k].formal_name)) {
                                                param_type = inst_sym->generic_actuals[k].actual_type;
                                                break;
                                            }
                                        }
                                        /* If not a formal, resolve actual type (e.g. STRING) */
                                        if (!param_type) {
                                            Symbol *type_sym = Symbol_Find(sm, pt->string_val.text);
                                            if (type_sym && type_sym->type)
                                                param_type = type_sym->type;
                                        }
                                    }
                                }

                                for (uint32_t j = 0; j < ps->param_spec.names.count; j++) {
                                    Syntax_Node *name = ps->param_spec.names.items[j];
                                    inst_sym->parameters[idx].name = name->string_val.text;
                                    inst_sym->parameters[idx].param_type = param_type;
                                    inst_sym->parameters[idx].mode = (Parameter_Mode)ps->param_spec.mode;
                                    idx++;
                                }
                            }
                        }
                    }

                    /* Handle return type for functions */
                    if (unit->kind == NK_FUNCTION_SPEC && unit->subprogram_spec.return_type) {
                        Syntax_Node *rt = unit->subprogram_spec.return_type;
                        if (rt->kind == NK_IDENTIFIER) {
                            /* Check if return type is a formal type parameter */
                            for (uint32_t k = 0; k < inst_sym->generic_actual_count; k++) {
                                if (Slice_Equal_Ignore_Case(rt->string_val.text,
                                              inst_sym->generic_actuals[k].formal_name)) {
                                    inst_sym->return_type = inst_sym->generic_actuals[k].actual_type;
                                    break;
                                }
                            }
                            /* If not a formal, look up the actual type (e.g. INTEGER) */
                            if (!inst_sym->return_type) {
                                Symbol *type_sym = Symbol_Find(sm, rt->string_val.text);
                                if (type_sym && type_sym->type)
                                    inst_sym->return_type = type_sym->type;
                            }
                        }
                    }
                }

                /* For package instantiations, copy and instantiate exported symbols */
                if (node->generic_inst.unit_kind == TK_PACKAGE) {
                    /* Look for exports from the template's generic_unit (package spec) */
                    Syntax_Node *pkg_spec = template->generic_unit;
                    if (pkg_spec && pkg_spec->kind == NK_PACKAGE_SPEC) {
                        /* Count visible declarations */
                        uint32_t export_count = 0;
                        for (uint32_t i = 0; i < pkg_spec->package_spec.visible_decls.count; i++) {
                            Syntax_Node *decl = pkg_spec->package_spec.visible_decls.items[i];
                            if (!decl) continue;
                            if (decl->kind == NK_TYPE_DECL || decl->kind == NK_SUBTYPE_DECL) {
                                export_count++;
                                /* Count enum literals too */
                                if (decl->type_decl.definition &&
                                    decl->type_decl.definition->kind == NK_ENUMERATION_TYPE) {
                                    export_count += decl->type_decl.definition->enum_type.literals.count;
                                }
                            }
                            else if (decl->kind == NK_PROCEDURE_SPEC || decl->kind == NK_FUNCTION_SPEC)
                                export_count++;
                            else if (decl->kind == NK_EXCEPTION_DECL)
                                export_count += decl->exception_decl.names.count;
                            else if (decl->kind == NK_OBJECT_DECL)
                                export_count += decl->object_decl.names.count;
                        }

                        if (export_count > 0) {
                            inst_sym->exported = Arena_Allocate(export_count * sizeof(Symbol*));
                            inst_sym->exported_count = 0;

                            /* Helper: substitute generic formals with actuals in a type */
                            #define SUBSTITUTE_TYPE(ty) do { \
                                if (ty && ty->name.data) { \
                                    for (uint32_t k = 0; k < inst_sym->generic_actual_count; k++) { \
                                        if (Slice_Equal_Ignore_Case(ty->name, \
                                                      inst_sym->generic_actuals[k].formal_name)) { \
                                            ty = inst_sym->generic_actuals[k].actual_type; \
                                            break; \
                                        } \
                                    } \
                                } \
                            } while(0)

                            for (uint32_t i = 0; i < pkg_spec->package_spec.visible_decls.count; i++) {
                                Syntax_Node *decl = pkg_spec->package_spec.visible_decls.items[i];
                                if (!decl) continue;

                                if (decl->kind == NK_TYPE_DECL || decl->kind == NK_SUBTYPE_DECL) {
                                    /* Create type symbol for the instance */
                                    String_Slice name = decl->type_decl.name;
                                    Symbol *exp = Symbol_New(SYMBOL_TYPE, name, decl->location);
                                    /* Use the symbol's type (has the named type) if available */
                                    if (decl->symbol && decl->symbol->type)
                                        exp->type = decl->symbol->type;
                                    else if (decl->type)
                                        exp->type = decl->type;
                                    else if (decl->type_decl.definition)
                                        exp->type = decl->type_decl.definition->type;
                                    /* For subtypes, substitute formal type with actual */
                                    if (!exp->type && decl->kind == NK_SUBTYPE_DECL &&
                                        decl->type_decl.definition) {
                                        Syntax_Node *def = decl->type_decl.definition;
                                        String_Slice def_name = {0};
                                        /* Handle plain identifier: SUBTYPE X IS GEN */
                                        if (def->kind == NK_IDENTIFIER) {
                                            def_name = def->string_val.text;
                                        }
                                        /* Handle constrained: SUBTYPE X IS GEN(4) */
                                        else if (def->kind == NK_APPLY && def->apply.prefix &&
                                                 def->apply.prefix->kind == NK_IDENTIFIER) {
                                            def_name = def->apply.prefix->string_val.text;
                                        }
                                        /* Handle subtype indication: SUBTYPE X IS GEN RANGE ... */
                                        else if (def->kind == NK_SUBTYPE_INDICATION &&
                                                 def->subtype_ind.subtype_mark &&
                                                 def->subtype_ind.subtype_mark->kind == NK_IDENTIFIER) {
                                            def_name = def->subtype_ind.subtype_mark->string_val.text;
                                        }
                                        if (def_name.data) {
                                            for (uint32_t k = 0; k < inst_sym->generic_actual_count; k++) {
                                                Syntax_Node *formal_k = formals->items[k];
                                                if (formal_k->kind == NK_GENERIC_TYPE_PARAM &&
                                                    Slice_Equal_Ignore_Case(def_name, formal_k->generic_type_param.name)) {
                                                    exp->type = inst_sym->generic_actuals[k].actual_type;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    /* Create Type_Info for unresolved enum/range types */
                                    if (!exp->type && decl->type_decl.definition) {
                                        Syntax_Node *def = decl->type_decl.definition;
                                        if (def->kind == NK_ENUMERATION_TYPE) {
                                            Type_Info *ti = Type_New(TYPE_ENUMERATION, name);
                                            ti->size = 4;
                                            uint32_t lit_count = def->enum_type.literals.count;
                                            ti->enumeration.literal_count = lit_count;
                                            if (lit_count > 0) {
                                                ti->enumeration.literals = Arena_Allocate(
                                                    lit_count * sizeof(String_Slice));
                                                for (uint32_t j = 0; j < lit_count; j++) {
                                                    Syntax_Node *lit = def->enum_type.literals.items[j];
                                                    if (lit && lit->kind == NK_IDENTIFIER)
                                                        ti->enumeration.literals[j] = lit->string_val.text;
                                                }
                                            }
                                            exp->type = ti;
                                            def->type = ti;
                                            decl->type = ti;
                                        } else if (def->kind == NK_RANGE) {
                                            /* Integer type with range constraint */
                                            Type_Info *ti = Type_New(TYPE_INTEGER, name);
                                            ti->size = 4;
                                            exp->type = ti;
                                            def->type = ti;
                                            decl->type = ti;
                                        }
                                    }
                                    exp->declaration = decl;
                                    exp->parent = inst_sym;
                                    inst_sym->exported[inst_sym->exported_count++] = exp;

                                    /* Also export enum literals */
                                    if (decl->type_decl.definition &&
                                        decl->type_decl.definition->kind == NK_ENUMERATION_TYPE) {
                                        Node_List *lits = &decl->type_decl.definition->enum_type.literals;
                                        for (uint32_t j = 0; j < lits->count; j++) {
                                            Syntax_Node *lit = lits->items[j];
                                            if (lit && lit->kind == NK_IDENTIFIER) {
                                                Symbol *lit_sym = Symbol_New(SYMBOL_LITERAL,
                                                    lit->string_val.text, lit->location);
                                                lit_sym->type = exp->type;
                                                lit_sym->parent = inst_sym;
                                                inst_sym->exported[inst_sym->exported_count++] = lit_sym;
                                            }
                                        }
                                    }
                                }
                                else if (decl->kind == NK_PROCEDURE_SPEC ||
                                         decl->kind == NK_FUNCTION_SPEC) {
                                    /* Create subprogram symbol with instantiated types.
                                     * Assign unique_id immediately so homographs get distinct IDs. */
                                    String_Slice name = decl->subprogram_spec.name;
                                    Symbol_Kind sk = (decl->kind == NK_PROCEDURE_SPEC) ?
                                                     SYMBOL_PROCEDURE : SYMBOL_FUNCTION;
                                    Symbol *exp = Symbol_New(sk, name, decl->location);
                                    exp->unique_id = sm->next_unique_id++;
                                    exp->declaration = decl;
                                    exp->parent = inst_sym;
                                    exp->generic_template = template;

                                    /* Copy and substitute parameter types */
                                    Node_List *params = &decl->subprogram_spec.parameters;
                                    uint32_t total_params = 0;
                                    for (uint32_t j = 0; j < params->count; j++) {
                                        Syntax_Node *ps = params->items[j];
                                        if (ps->kind == NK_PARAM_SPEC)
                                            total_params += ps->param_spec.names.count;
                                    }
                                    exp->parameter_count = total_params;
                                    if (total_params > 0) {
                                        exp->parameters = Arena_Allocate(
                                            total_params * sizeof(Parameter_Info));
                                        uint32_t idx = 0;
                                        for (uint32_t j = 0; j < params->count; j++) {
                                            Syntax_Node *ps = params->items[j];
                                            if (ps->kind == NK_PARAM_SPEC) {
                                                Type_Info *ptype = ps->param_spec.param_type ?
                                                    ps->param_spec.param_type->type : NULL;
                                                /* If type not resolved, look up by name */
                                                if (!ptype && ps->param_spec.param_type &&
                                                    ps->param_spec.param_type->kind == NK_IDENTIFIER) {
                                                    String_Slice pt_name = ps->param_spec.param_type->string_val.text;
                                                    /* First try instance's own exports */
                                                    for (uint32_t k = 0; k < inst_sym->exported_count; k++) {
                                                        Symbol *es = inst_sym->exported[k];
                                                        if (es && es->kind == SYMBOL_TYPE &&
                                                            Slice_Equal_Ignore_Case(es->name, pt_name)) {
                                                            ptype = es->type;
                                                            break;
                                                        }
                                                    }
                                                    /* Then try global symbol table */
                                                    if (!ptype) {
                                                        Symbol *tsym = Symbol_Find(sm, pt_name);
                                                        if (tsym) ptype = tsym->type;
                                                    }
                                                }
                                                SUBSTITUTE_TYPE(ptype);
                                                for (uint32_t m = 0; m < ps->param_spec.names.count; m++) {
                                                    Syntax_Node *pname = ps->param_spec.names.items[m];
                                                    exp->parameters[idx].name = pname->string_val.text;
                                                    exp->parameters[idx].param_type = ptype;
                                                    exp->parameters[idx].mode =
                                                        (Parameter_Mode)ps->param_spec.mode;
                                                    /* Create param symbol if not present (specs don't have symbols) */
                                                    if (!pname->symbol) {
                                                        Symbol *ps_sym = Symbol_New(SYMBOL_PARAMETER,
                                                            pname->string_val.text, pname->location);
                                                        ps_sym->type = ptype;
                                                        ps_sym->unique_id = sm->next_unique_id++;
                                                        pname->symbol = ps_sym;
                                                    }
                                                    exp->parameters[idx].param_sym = pname->symbol;
                                                    idx++;
                                                }
                                            }
                                        }
                                    }

                                    /* Handle return type */
                                    if (decl->kind == NK_FUNCTION_SPEC &&
                                        decl->subprogram_spec.return_type) {
                                        Type_Info *rtype = decl->subprogram_spec.return_type->type;
                                        /* If return type not resolved, look up by name */
                                        if (!rtype && decl->subprogram_spec.return_type->kind == NK_IDENTIFIER) {
                                            String_Slice rt_name = decl->subprogram_spec.return_type->string_val.text;
                                            /* First try instance's own exports (for types like FILE_MODE) */
                                            for (uint32_t k = 0; k < inst_sym->exported_count; k++) {
                                                Symbol *es = inst_sym->exported[k];
                                                if (es && es->kind == SYMBOL_TYPE &&
                                                    Slice_Equal_Ignore_Case(es->name, rt_name)) {
                                                    rtype = es->type;
                                                    break;
                                                }
                                            }
                                            /* Then try global symbol table */
                                            if (!rtype) {
                                                Symbol *tsym = Symbol_Find(sm, rt_name);
                                                if (tsym) rtype = tsym->type;
                                            }
                                        }
                                        SUBSTITUTE_TYPE(rtype);
                                        exp->return_type = rtype;
                                    }

                                    inst_sym->exported[inst_sym->exported_count++] = exp;
                                }
                                else if (decl->kind == NK_EXCEPTION_DECL) {
                                    for (uint32_t j = 0; j < decl->exception_decl.names.count; j++) {
                                        Syntax_Node *nm = decl->exception_decl.names.items[j];
                                        Symbol *exp = Symbol_New(SYMBOL_EXCEPTION,
                                            nm->string_val.text, nm->location);
                                        exp->parent = inst_sym;
                                        inst_sym->exported[inst_sym->exported_count++] = exp;
                                    }
                                }
                                else if (decl->kind == NK_OBJECT_DECL) {
                                    /* Export object declarations (including renames) */
                                    Type_Info *obj_type = NULL;
                                    if (decl->object_decl.object_type) {
                                        obj_type = decl->object_decl.object_type->type;
                                        /* If type not resolved (generic template), look up by name */
                                        if (!obj_type && decl->object_decl.object_type->kind == NK_IDENTIFIER) {
                                            String_Slice type_name = decl->object_decl.object_type->string_val.text;
                                            Symbol *type_sym = Symbol_Find(sm, type_name);
                                            if (type_sym && type_sym->type)
                                                obj_type = type_sym->type;
                                        }
                                        /* Substitute generic formals with actuals */
                                        SUBSTITUTE_TYPE(obj_type);
                                    }
                                    for (uint32_t j = 0; j < decl->object_decl.names.count; j++) {
                                        Syntax_Node *nm = decl->object_decl.names.items[j];
                                        Symbol_Kind sk = decl->object_decl.is_constant ?
                                            SYMBOL_CONSTANT : SYMBOL_VARIABLE;
                                        Symbol *exp = Symbol_New(sk, nm->string_val.text, nm->location);
                                        exp->type = obj_type;
                                        exp->parent = inst_sym;
                                        /* For renames, store the renamed object expression */
                                        if (decl->object_decl.is_rename && decl->object_decl.init) {
                                            exp->renamed_object = decl->object_decl.init;
                                        }
                                        inst_sym->exported[inst_sym->exported_count++] = exp;
                                    }
                                }
                            }
                            #undef SUBSTITUTE_TYPE
                        }
                    }
                }

                Symbol_Add(sm, inst_sym);
                node->symbol = inst_sym;

                /* For package instantiations, expand the generic now
                 * so we have expanded_spec/expanded_body for codegen */
                if (node->generic_inst.unit_kind == TK_PACKAGE) {
                    Expand_Generic_Package(sm, inst_sym);
                }
            }
            break;

        case NK_REPRESENTATION_CLAUSE:
            /* Representation clause: FOR T'SIZE USE 32; or FOR T USE RECORD ... */
            {
                /* Resolve entity name */
                if (node->rep_clause.entity_name) {
                    Resolve_Expression(sm, node->rep_clause.entity_name);

                    /* Get target type or symbol */
                    Symbol *target_sym = NULL;
                    if (node->rep_clause.entity_name->kind == NK_IDENTIFIER) {
                        target_sym = Symbol_Find(sm, node->rep_clause.entity_name->string_val.text);
                    } else if (node->rep_clause.entity_name->symbol) {
                        target_sym = node->rep_clause.entity_name->symbol;
                    }

                    Type_Info *target_type = target_sym ? target_sym->type : NULL;

                    /* Process attribute clauses: FOR T'SIZE USE 32; */
                    if (node->rep_clause.attribute.data && target_type) {
                        String_Slice attr = node->rep_clause.attribute;

                        if (node->rep_clause.expression) {
                            Resolve_Expression(sm, node->rep_clause.expression);
                            int64_t value = 0;

                            /* Extract constant value */
                            if (node->rep_clause.expression->kind == NK_INTEGER) {
                                value = node->rep_clause.expression->integer_lit.value;
                            }

                            /* Apply representation */
                            if (Slice_Equal_Ignore_Case(attr, S("SIZE"))) {
                                /* Size in bits - convert to bytes */
                                target_type->size = (uint32_t)((value + 7) / 8);
                            } else if (Slice_Equal_Ignore_Case(attr, S("ALIGNMENT"))) {
                                target_type->alignment = (uint32_t)value;
                            } else if (Slice_Equal_Ignore_Case(attr, S("STORAGE_SIZE"))) {
                                /* For task types: storage for task stack */
                                /* Would store in target_sym or target_type */
                            } else if (Slice_Equal_Ignore_Case(attr, S("SMALL"))) {
                                /* For fixed-point: set small value */
                                if (target_type->kind == TYPE_FIXED &&
                                    node->rep_clause.expression->kind == NK_REAL) {
                                    target_type->fixed.small =
                                        node->rep_clause.expression->real_lit.value;
                                }
                            }
                        }
                    }

                    /* Process record representation: FOR T USE RECORD ... */
                    if (node->rep_clause.is_record_rep && target_type &&
                        target_type->kind == TYPE_RECORD) {
                        /* Process alignment clause */
                        if (node->rep_clause.expression) {
                            Resolve_Expression(sm, node->rep_clause.expression);
                            if (node->rep_clause.expression->kind == NK_INTEGER) {
                                target_type->alignment =
                                    (uint32_t)node->rep_clause.expression->integer_lit.value;
                            }
                        }

                        /* Process component clauses (record layout)
                         * Each clause: component_name AT byte_position [RANGE bits]; */
                        for (uint32_t i = 0; i < node->rep_clause.component_clauses.count; i++) {
                            Syntax_Node *cc = node->rep_clause.component_clauses.items[i];
                            if (cc->kind == NK_ASSOCIATION && cc->association.choices.count > 0) {
                                Syntax_Node *name_node = cc->association.choices.items[0];
                                if (name_node && name_node->kind == NK_IDENTIFIER) {
                                    String_Slice comp_name = name_node->string_val.text;
                                    /* Find matching component in record type */
                                    for (uint32_t j = 0; j < target_type->record.component_count; j++) {
                                        Component_Info *comp = &target_type->record.components[j];
                                        if (Slice_Equal_Ignore_Case(comp->name, comp_name)) {
                                            /* Get byte offset from expression */
                                            Syntax_Node *pos_expr = cc->association.expression;
                                            if (pos_expr && pos_expr->kind == NK_INTEGER) {
                                                comp->byte_offset = (uint32_t)pos_expr->integer_lit.value;
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    /* Process enumeration representation: FOR T USE (val0, val1, ...); */
                    if (node->rep_clause.is_enum_rep && target_type &&
                        target_type->kind == TYPE_ENUMERATION) {
                        /* Store internal representation values for enum literals
                         * The component_clauses list contains the values in order */
                        uint32_t val_count = node->rep_clause.component_clauses.count;
                        if (val_count > 0 && val_count <= target_type->enumeration.literal_count) {
                            /* Allocate array for representation values */
                            target_type->enumeration.rep_values =
                                Arena_Allocate(val_count * sizeof(int64_t));
                            for (uint32_t i = 0; i < val_count; i++) {
                                Syntax_Node *val_node = node->rep_clause.component_clauses.items[i];
                                if (val_node && val_node->kind == NK_INTEGER) {
                                    target_type->enumeration.rep_values[i] =
                                        val_node->integer_lit.value;
                                } else {
                                    /* Default to position value */
                                    target_type->enumeration.rep_values[i] = (int64_t)i;
                                }
                            }
                        }
                    }
                }
            }
            break;

        default:
            break;
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §12.4 Compilation Unit Resolution
 * ───────────────────────────────────────────────────────────────────────── */

static void Resolve_Compilation_Unit(Symbol_Manager *sm, Syntax_Node *node) {
    if (!node) return;

    /* Load WITH'd packages from include paths */
    if (node->compilation_unit.context) {
        Syntax_Node *ctx = node->compilation_unit.context;
        for (uint32_t i = 0; i < ctx->context.with_clauses.count; i++) {
            Syntax_Node *with_node = ctx->context.with_clauses.items[i];
            /* WITH clause contains a list of package names */
            for (uint32_t j = 0; j < with_node->use_clause.names.count; j++) {
                Syntax_Node *pkg_name = with_node->use_clause.names.items[j];
                if (pkg_name->kind == NK_IDENTIFIER) {
                    char *pkg_src = Lookup_Path(pkg_name->string_val.text);
                    if (pkg_src) {
                        Load_Package_Spec(sm, pkg_name->string_val.text, pkg_src);
                    }
                    /* Resolve the identifier to the package symbol */
                    Resolve_Expression(sm, pkg_name);
                }
            }
        }
        /* Resolve USE clauses (make package contents visible) */
        for (uint32_t i = 0; i < ctx->context.use_clauses.count; i++) {
            Resolve_Declaration(sm, ctx->context.use_clauses.items[i]);
        }
    }

    /* Handle separate subunits (SEPARATE (parent) ...) */
    Symbol *parent_sym = NULL;
    if (node->compilation_unit.separate_parent) {
        Syntax_Node *parent = node->compilation_unit.separate_parent;
        String_Slice parent_name = {0};
        if (parent->kind == NK_IDENTIFIER) {
            parent_name = parent->string_val.text;
        } else if (parent->kind == NK_SELECTED) {
            /* Handle qualified names like A.B - use the selector (rightmost part) */
            parent_name = parent->selected.selector;
        }
        if (parent_name.length > 0) {
            parent_sym = Symbol_Find(sm, parent_name);
            if (parent_sym && parent_sym->scope) {
                /* Push the parent's actual scope so we can find the stub symbol.
                 * This reuses the scope where the stub was declared. */
                Symbol_Manager_Push_Existing_Scope(sm, parent_sym->scope);
            }
        }
    }

    /* Resolve main unit */
    if (node->compilation_unit.unit) {
        Resolve_Declaration(sm, node->compilation_unit.unit);
    }

    /* Pop parent scope if we pushed it */
    if (parent_sym && parent_sym->scope) {
        Symbol_Manager_Pop_Scope(sm);
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §13. LLVM IR CODE GENERATION
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * The AST is semantic and the IR is operational, with translation bridging the gap.
 *
 * Generate LLVM IR from the resolved AST. Key principles:
 *
 * 1. Widen to i64 for computation, truncate for storage
 * 2. All pointer types use opaque 'ptr' (LLVM 15+)
 * 3. Static links for nested subprogram access
 * 4. Fat pointers for unconstrained arrays (ptr + bounds)
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §13.1 Code Generator State
 * ───────────────────────────────────────────────────────────────────────── */

typedef struct {
    FILE         *output;
    Symbol_Manager *sm;

    /* ID counters */
    uint32_t      temp_id;
    uint32_t      label_id;
    uint32_t      global_id;
    uint32_t      string_id;

    /* Current function context */
    Symbol       *current_function;
    uint32_t      current_nesting_level;

    /* Generic instance context for type substitution */
    Symbol       *current_instance;

    /* Loop/exit context */
    uint32_t      loop_exit_label;
    uint32_t      loop_continue_label;

    /* Function exit tracking */
    bool          has_return;
    bool          block_terminated;  /* True if current block has a terminator (ret/br) */

    /* Module header tracking for multi-unit files */
    bool          header_emitted;
    Symbol       *main_candidate;  /* Last parameterless library-level procedure */

    /* Deferred nested subprogram bodies */
    Syntax_Node  *deferred_bodies[64];
    uint32_t      deferred_count;

    /* Static link support for nested functions */
    Symbol       *enclosing_function;    /* Function containing current nested function */
    bool          is_nested;              /* True if current function is nested */

    /* Exception handling support */
    uint32_t      exception_handler_label;  /* Label of current exception handler */
    uint32_t      exception_jmp_buf;        /* Current setjmp buffer temp */
    bool          in_exception_region;      /* True if inside exception-handled block */

    /* String constant buffer (emitted at module level) */
    char         *string_const_buffer;
    size_t        string_const_size;
    size_t        string_const_capacity;

    /* Address markers needed for 'ADDRESS on packages/generics */
    Symbol       *address_markers[256];
    uint32_t      address_marker_count;

    /* Track emitted function unique_ids to prevent duplicate definitions */
    uint32_t      emitted_func_ids[1024];
    uint32_t      emitted_func_count;
} Code_Generator;

static Code_Generator *Code_Generator_New(FILE *output, Symbol_Manager *sm) {
    Code_Generator *cg = Arena_Allocate(sizeof(Code_Generator));
    cg->output = output;
    cg->sm = sm;
    cg->temp_id = 1;
    cg->label_id = 1;
    cg->global_id = 1;
    cg->string_id = 1;
    cg->deferred_count = 0;
    /* Initialize string constant buffer */
    cg->string_const_capacity = 4096;
    cg->string_const_buffer = Arena_Allocate(cg->string_const_capacity);
    cg->string_const_size = 0;
    return cg;
}

/* Emit to string constant buffer instead of main output */
static void Emit_String_Const(Code_Generator *cg, const char *format, ...) {
    va_list args;
    va_start(args, format);
    char temp[1024];
    int len = vsnprintf(temp, sizeof(temp), format, args);
    va_end(args);
    if (len < 0) return;  /* Format error */
    size_t slen = (size_t)len;

    /* Expand buffer if needed */
    while (cg->string_const_size + slen + 1 > cg->string_const_capacity) {
        size_t new_cap = cg->string_const_capacity * 2;
        char *new_buf = Arena_Allocate(new_cap);
        memcpy(new_buf, cg->string_const_buffer, cg->string_const_size);
        cg->string_const_buffer = new_buf;
        cg->string_const_capacity = new_cap;
    }
    memcpy(cg->string_const_buffer + cg->string_const_size, temp, slen);
    cg->string_const_size += slen;
    cg->string_const_buffer[cg->string_const_size] = '\0';
}

/* Emit a single char to string constant buffer */
static void Emit_String_Const_Char(Code_Generator *cg, char c) {
    if (cg->string_const_size + 2 > cg->string_const_capacity) {
        size_t new_cap = cg->string_const_capacity * 2;
        char *new_buf = Arena_Allocate(new_cap);
        memcpy(new_buf, cg->string_const_buffer, cg->string_const_size);
        cg->string_const_buffer = new_buf;
        cg->string_const_capacity = new_cap;
    }
    cg->string_const_buffer[cg->string_const_size++] = c;
    cg->string_const_buffer[cg->string_const_size] = '\0';
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.2 IR Emission Helpers
 * ───────────────────────────────────────────────────────────────────────── */

static uint32_t Emit_Temp(Code_Generator *cg) {
    return cg->temp_id++;
}

static uint32_t Emit_Label(Code_Generator *cg) {
    return cg->label_id++;
}

static void Emit(Code_Generator *cg, const char *format, ...) {
    va_list args;
    va_start(args, format);
    vfprintf(cg->output, format, args);
    va_end(args);
}

/* Emit a label and reset block termination state */
static void Emit_Label_Here(Code_Generator *cg, uint32_t label) {
    Emit(cg, "L%u:\n", label);
    cg->block_terminated = false;
}

/* Emit a branch only if block is not already terminated */
static void Emit_Branch_If_Needed(Code_Generator *cg, uint32_t label) {
    if (!cg->block_terminated) {
        Emit(cg, "  br label %%L%u\n", label);
        cg->block_terminated = true;
    }
}

/* Check if symbol is package-level (global storage with @ prefix in LLVM).
 * A symbol is global only if it's at package level AND no ancestor is a subprogram.
 * This handles nested packages inside subprogram bodies correctly. */
static inline bool Symbol_Is_Global(Symbol *sym) {
    if (!sym->parent) return true;  /* Top-level */
    /* Walk up parent chain - if any ancestor is a subprogram, symbol is local */
    Symbol *p = sym->parent;
    while (p) {
        if (p->kind == SYMBOL_FUNCTION || p->kind == SYMBOL_PROCEDURE) {
            return false;  /* Inside a subprogram - use local (%) prefix */
        }
        p = p->parent;
    }
    return true;  /* No subprogram ancestor - use global (@) prefix */
}

/* ─────────────────────────────────────────────────────────────────────────
 * Symbol_Mangle_Name — Unified LLVM-compatible name mangling
 *
 * Produces consistent mangled names for:
 *   1. Code generation (LLVM IR identifiers)
 *   2. ALI files (linkage names)
 *   3. Cross-compilation linking
 *
 * Format: parent__name[_SN] (all lowercase, special chars as _XX)
 *
 * This is the SINGLE SOURCE OF TRUTH for name mangling.
 * ───────────────────────────────────────────────────────────────────────── */

/* Internal recursive helper */
static size_t Mangle_Into_Buffer(char *buf, size_t pos, size_t max, Symbol *sym) {
    if (!sym) return pos;

    /* Recursively mangle parent first */
    if (sym->parent && sym->parent->kind == SYMBOL_PACKAGE) {
        pos = Mangle_Into_Buffer(buf, pos, max, sym->parent);
        if (pos + 2 < max) { buf[pos++] = '_'; buf[pos++] = '_'; }
    }

    /* Mangle this symbol's name: lowercase + escape special chars */
    for (uint32_t i = 0; i < sym->name.length && pos < max - 4; i++) {
        char c = sym->name.data[i];
        if (c >= 'A' && c <= 'Z') c = c - 'A' + 'a';  /* Lowercase */
        if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_') {
            buf[pos++] = c;
        } else if (c == '"') {
            /* Operator symbols */
            if (pos + 4 < max) { buf[pos++] = '_'; buf[pos++] = 'o'; buf[pos++] = 'p'; buf[pos++] = '_'; }
        } else {
            /* Escape as _XX */
            if (pos + 3 < max) {
                buf[pos++] = '_';
                buf[pos++] = "0123456789abcdef"[(c >> 4) & 0xF];
                buf[pos++] = "0123456789abcdef"[c & 0xF];
            }
        }
    }

    return pos;
}

/* Get mangled name for a symbol (thread-safe via rotation) */
static String_Slice Symbol_Mangle_Name(Symbol *sym) {
    static char bufs[4][512];
    static int buf_idx = 0;

    char *buf = bufs[buf_idx++ & 3];
    size_t pos = 0;

    /* Build mangled name from parent chain */
    pos = Mangle_Into_Buffer(buf, 0, 510, sym);

    /* Add unique_id suffix for local/overloaded symbols */
    if (sym && (!Symbol_Is_Global(sym) || sym->is_overloaded)) {
        pos += snprintf(buf + pos, 512 - pos, "_s%u", sym->unique_id);
    }

    buf[pos] = '\0';
    return (String_Slice){buf, pos};
}

/* Get mangled name for parent+name pair (for ALI generation before symbols exist) */
static String_Slice Mangle_Qualified_Name(String_Slice parent, String_Slice name) {
    static char bufs[4][512];
    static int buf_idx = 0;

    char *buf = bufs[buf_idx++ & 3];
    size_t pos = 0;

    /* Parent prefix (lowercased) */
    for (size_t i = 0; i < parent.length && pos < 500; i++) {
        char c = parent.data[i];
        if (c >= 'A' && c <= 'Z') c = c - 'A' + 'a';
        if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_')
            buf[pos++] = c;
        else { buf[pos++] = '_'; buf[pos++] = "0123456789abcdef"[(c>>4)&0xF]; buf[pos++] = "0123456789abcdef"[c&0xF]; }
    }

    if (parent.length > 0) { buf[pos++] = '_'; buf[pos++] = '_'; }

    /* Name (lowercased) */
    for (size_t i = 0; i < name.length && pos < 508; i++) {
        char c = name.data[i];
        if (c >= 'A' && c <= 'Z') c = c - 'A' + 'a';
        if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_')
            buf[pos++] = c;
        else { buf[pos++] = '_'; buf[pos++] = "0123456789abcdef"[(c>>4)&0xF]; buf[pos++] = "0123456789abcdef"[c&0xF]; }
    }

    buf[pos] = '\0';
    return Slice_Duplicate((String_Slice){buf, pos});
}

/* Emit symbol name for LLVM identifier (uses unified Symbol_Mangle_Name) */
static void Emit_Symbol_Name(Code_Generator *cg, Symbol *sym) {
    if (!sym) {
        Emit(cg, "unknown");
        return;
    }

    /* For imported symbols with external name, use that directly */
    if (sym->is_imported && sym->external_name.length > 0) {
        String_Slice name = sym->external_name;
        /* Strip quotes if present (from pragma Import) */
        if (name.length >= 2 && name.data[0] == '"' && name.data[name.length-1] == '"') {
            name.data++;
            name.length -= 2;
        }
        for (uint32_t i = 0; i < name.length; i++) {
            fputc(name.data[i], cg->output);
        }
        return;
    }

    /* For generic instance code generation: prefix global OBJECT symbols
     * (variables) from the template body with the instance name to avoid
     * collisions when multiple instances of the same generic are created.
     * Do NOT prefix exceptions, types, or subprograms. */
    if (cg->current_instance && sym->kind == SYMBOL_VARIABLE && Symbol_Is_Global(sym)) {
        /* Find the package instance - current_instance might be a procedure
         * within a package, in which case use the procedure's parent package */
        Symbol *inst = cg->current_instance;
        if ((inst->kind == SYMBOL_FUNCTION || inst->kind == SYMBOL_PROCEDURE) &&
            inst->parent && inst->parent->kind == SYMBOL_PACKAGE &&
            inst->parent->generic_template) {
            inst = inst->parent;  /* Use owning package instance for globals */
        }
        Symbol *tmpl = inst->generic_template;
        if (tmpl && sym->parent && sym->parent != inst &&
            (sym->parent == tmpl || sym->parent->kind == SYMBOL_GENERIC)) {
            /* Emit instance name prefix */
            String_Slice inst_mangled = Symbol_Mangle_Name(inst);
            for (uint32_t i = 0; i < inst_mangled.length; i++) {
                fputc(inst_mangled.data[i], cg->output);
            }
            Emit(cg, "__");
            /* Emit just the symbol name (not parent chain) */
            for (uint32_t i = 0; i < sym->name.length; i++) {
                char c = sym->name.data[i];
                if (c >= 'A' && c <= 'Z') c = c - 'A' + 'a';
                fputc(c, cg->output);
            }
            return;
        }
    }

    /* Use unified mangling (lowercase, parent__name format, _sN suffix) */
    String_Slice mangled = Symbol_Mangle_Name(sym);
    for (uint32_t i = 0; i < mangled.length; i++) {
        fputc(mangled.data[i], cg->output);
    }
}

/* Emit symbol reference with appropriate prefix (@ for global, % for local) */
static void Emit_Symbol_Ref(Code_Generator *cg, Symbol *sym) {
    Emit(cg, Symbol_Is_Global(sym) ? "@" : "%%");
    Emit_Symbol_Name(cg, sym);
}

/* Parse LLVM type width: "i64"→64, "float"→32, "double"→64 */
static inline int Type_Bits(const char *ty) {
    if (ty[0] == 'i') return atoi(ty + 1);
    if (strcmp(ty, "float") == 0) return 32;
    if (strcmp(ty, "double") == 0) return 64;
    return 64;
}

/* Check if LLVM type is floating-point */
static inline bool Is_Float_Type(const char *ty) {
    return strcmp(ty, "float") == 0 || strcmp(ty, "double") == 0;
}

/* Check if expression produces boolean (i1) result directly.
 * Only comparisons and logical operators produce i1 - loaded variables
 * are widened to i64 even for BOOLEAN type. */
static inline bool Expression_Is_Boolean(Syntax_Node *node) {
    if (!node) return false;
    if (node->kind == NK_BINARY_OP) {
        switch (node->binary.op) {
            case TK_EQ: case TK_NE: case TK_LT: case TK_LE: case TK_GT: case TK_GE:
            case TK_AND: case TK_AND_THEN: case TK_OR: case TK_OR_ELSE: case TK_XOR:
            case TK_IN:   /* Membership test */
            case TK_NOT:  /* NOT IN (binary) is also a membership test */
                return true;
            default: break;
        }
    }
    if (node->kind == NK_UNARY_OP && node->unary.op == TK_NOT) {
        Type_Info *ty = node->unary.operand ? node->unary.operand->type : NULL;
        if (ty && ty->kind == TYPE_BOOLEAN) return true;
    }
    /* Attributes that return boolean (i1) */
    if (node->kind == NK_ATTRIBUTE) {
        String_Slice attr = node->attribute.name;
        if (Slice_Equal_Ignore_Case(attr, S("CONSTRAINED")) ||
            Slice_Equal_Ignore_Case(attr, S("CALLABLE")) ||
            Slice_Equal_Ignore_Case(attr, S("TERMINATED"))) {
            return true;
        }
    }
    return false;
}

/* Check if expression produces float result */
static inline bool Expression_Is_Float(Syntax_Node *node) {
    if (!node) return false;
    /* Attributes that return floating-point (double) */
    if (node->kind == NK_ATTRIBUTE) {
        String_Slice attr = node->attribute.name;
        if (Slice_Equal_Ignore_Case(attr, S("EPSILON")) ||
            Slice_Equal_Ignore_Case(attr, S("SMALL")) ||
            Slice_Equal_Ignore_Case(attr, S("LARGE")) ||
            Slice_Equal_Ignore_Case(attr, S("SAFE_SMALL")) ||
            Slice_Equal_Ignore_Case(attr, S("SAFE_LARGE")) ||
            Slice_Equal_Ignore_Case(attr, S("DELTA"))) {
            return true;
        }
        /* FIRST/LAST with float prefix type (not fixed-point) */
        if (Slice_Equal_Ignore_Case(attr, S("FIRST")) ||
            Slice_Equal_Ignore_Case(attr, S("LAST"))) {
            Syntax_Node *prefix = node->attribute.prefix;
            if (prefix && prefix->type &&
                prefix->type->kind != TYPE_FIXED &&
                (prefix->type->kind == TYPE_FLOAT ||
                 prefix->type->kind == TYPE_UNIVERSAL_REAL ||
                 prefix->type->low_bound.kind == BOUND_FLOAT)) {
                return true;
            }
        }
    }
    /* Check node type for general float expressions */
    if (node->type && (node->type->kind == TYPE_FLOAT ||
                       node->type->kind == TYPE_UNIVERSAL_REAL)) {
        return true;
    }
    return false;
}

/* Get LLVM type string for expression result */
static inline const char *Expression_Llvm_Type(Syntax_Node *node) {
    if (Expression_Is_Boolean(node)) return "i1";
    /* For float types, return the correct LLVM type based on actual size */
    if (node && node->type && (node->type->kind == TYPE_FLOAT ||
                                node->type->kind == TYPE_UNIVERSAL_REAL)) {
        return Llvm_Float_Type((uint32_t)To_Bits(node->type->size));
    }
    /* Check for pointer/access types */
    if (node && node->type && node->type->kind == TYPE_ACCESS) return "ptr";
    if (node && node->kind == NK_ALLOCATOR) return "ptr";
    if (node && node->kind == NK_NULL) return "ptr";
    /* Record types and aggregates return pointers (alloca addresses) */
    if (node && node->type && node->type->kind == TYPE_RECORD) return "ptr";
    if (node && node->kind == NK_AGGREGATE && node->type &&
        node->type->kind == TYPE_RECORD) return "ptr";
    /* ALL array aggregates return ptr (alloca address), not fat pointers.
     * The aggregate creates stack storage and returns its address.
     * Fat pointers are only used when loading from unconstrained array variables. */
    if (node && node->kind == NK_AGGREGATE && node->type &&
        node->type->kind == TYPE_ARRAY) return "ptr";
    /* Array indexing (NK_APPLY) that returns composite element yields ptr not fat ptr.
     * The codegen returns a pointer to the element's storage, not a fat pointer. */
    if (node && node->kind == NK_APPLY && node->apply.prefix &&
        node->apply.prefix->type &&
        (node->apply.prefix->type->kind == TYPE_ARRAY ||
         node->apply.prefix->type->kind == TYPE_STRING)) {
        Type_Info *elem_type = node->type;
        if (elem_type && (elem_type->kind == TYPE_RECORD ||
            elem_type->kind == TYPE_STRING ||
            (elem_type->kind == TYPE_ARRAY && elem_type->array.is_constrained))) {
            return "ptr";  /* Composite elements return ptr */
        }
    }
    /* Check for string literals and string types (generate fat pointers) */
    if (node && node->kind == NK_STRING) return "{ ptr, { i64, i64 } }";
    if (node && node->type && node->type->kind == TYPE_STRING) return "{ ptr, { i64, i64 } }";
    /* Check for unconstrained array types (fat pointers) - for variable references */
    if (node && node->kind != NK_AGGREGATE &&
        node->type && node->type->kind == TYPE_ARRAY &&
        !node->type->array.is_constrained) {
        return "{ ptr, { i64, i64 } }";
    }
    return "i64";
}

/* Emit type conversion if needed */
static uint32_t Emit_Convert(Code_Generator *cg, uint32_t src, const char *src_type,
                            const char *dst_type) {
    if (strcmp(src_type, dst_type) == 0) return src;

    bool src_is_float = Is_Float_Type(src_type);
    bool dst_is_float = Is_Float_Type(dst_type);
    int src_bits = Type_Bits(src_type), dst_bits = Type_Bits(dst_type);

    uint32_t t = Emit_Temp(cg);

    if (src_is_float && dst_is_float) {
        /* float ↔ double */
        if (dst_bits > src_bits) {
            Emit(cg, "  %%t%u = fpext %s %%t%u to %s\n", t, src_type, src, dst_type);
        } else {
            Emit(cg, "  %%t%u = fptrunc %s %%t%u to %s\n", t, src_type, src, dst_type);
        }
    } else if (src_is_float && !dst_is_float) {
        /* float/double → integer */
        Emit(cg, "  %%t%u = fptosi %s %%t%u to %s\n", t, src_type, src, dst_type);
    } else if (!src_is_float && dst_is_float) {
        /* integer → float/double */
        Emit(cg, "  %%t%u = sitofp %s %%t%u to %s\n", t, src_type, src, dst_type);
    } else if (strcmp(src_type, "ptr") == 0 && strcmp(dst_type, "ptr") == 0) {
        /* ptr → ptr: no conversion needed */
        return src;
    } else if (strcmp(src_type, "ptr") == 0 && strcmp(dst_type, "i64") == 0) {
        /* ptr → i64: ptrtoint */
        Emit(cg, "  %%t%u = ptrtoint ptr %%t%u to i64\n", t, src);
    } else if (strcmp(src_type, "i64") == 0 && strcmp(dst_type, "ptr") == 0) {
        /* i64 → ptr: inttoptr */
        Emit(cg, "  %%t%u = inttoptr i64 %%t%u to ptr\n", t, src);
    } else if (strstr(src_type, "{ ptr,") && strstr(dst_type, "{ ptr,")) {
        /* fat pointer → fat pointer: no conversion needed */
        return src;
    } else if (strstr(src_type, "{ ptr,") && strcmp(dst_type, "ptr") == 0) {
        /* fat pointer → ptr: extract data pointer (field 0) */
        /* Note: this loses bounds information, used when assigning to access type */
        uint32_t fat_alloca = Emit_Temp(cg);
        Emit(cg, "  %%t%u = alloca %s\n", fat_alloca, src_type);
        Emit(cg, "  store %s %%t%u, ptr %%t%u\n", src_type, src, fat_alloca);
        Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i32 0, i32 0\n", t, src_type, fat_alloca);
        uint32_t data_ptr = Emit_Temp(cg);
        Emit(cg, "  %%t%u = load ptr, ptr %%t%u\n", data_ptr, t);
        return data_ptr;
    } else if (strstr(src_type, "{ ptr,") || strstr(dst_type, "{ ptr,")) {
        /* One is fat pointer, other is something else - can't convert, return as-is */
        return src;
    } else {
        /* integer conversions */
        if (src_bits == dst_bits) return src;
        if (dst_bits > src_bits) {
            /* Use zext for boolean (i1) to preserve 0/1 semantics,
             * sext for other integer extensions */
            if (src_bits == 1) {
                Emit(cg, "  %%t%u = zext %s %%t%u to %s\n", t, src_type, src, dst_type);
            } else {
                Emit(cg, "  %%t%u = sext %s %%t%u to %s\n", t, src_type, src, dst_type);
            }
        } else if (dst_bits == 1) {
            /* Boolean: icmp ne 0 preserves semantics (any non-zero → true) */
            Emit(cg, "  %%t%u = icmp ne %s %%t%u, 0\n", t, src_type, src);
        } else {
            Emit(cg, "  %%t%u = trunc %s %%t%u to %s\n", t, src_type, src, dst_type);
        }
    }
    return t;
}

/* Forward declaration for use in bound evaluation */
static uint32_t Generate_Expression(Code_Generator *cg, Syntax_Node *node);

/* ─────────────────────────────────────────────────────────────────────────
 * §13.1.2 Constraint Checks
 *
 * Per RM 3.5.4: CONSTRAINT_ERROR raised when value falls outside subtype range.
 * Handles both static (BOUND_INTEGER) and dynamic (BOUND_EXPR) bounds.
 * Generates: if (val < low || val > high) __ada_raise(CONSTRAINT_ERROR)
 * ───────────────────────────────────────────────────────────────────────── */
static uint32_t Emit_Bound_Value(Code_Generator *cg, Type_Bound *bound) {
    if (bound->kind == BOUND_INTEGER) {
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = add i64 0, %lld  ; literal bound\n", t, (long long)bound->int_value);
        return t;
    } else if (bound->kind == BOUND_EXPR && bound->expr) {
        return Generate_Expression(cg, bound->expr);
    }
    return 0;  /* Cannot determine bound */
}

static uint32_t Emit_Constraint_Check(Code_Generator *cg, uint32_t val, Type_Info *target) {
    if (!target) return val;
    /* Only check scalar types */
    if (target->kind != TYPE_INTEGER && target->kind != TYPE_ENUMERATION &&
        target->kind != TYPE_CHARACTER) return val;
    /* Need either static or dynamic bounds */
    if ((target->low_bound.kind != BOUND_INTEGER && target->low_bound.kind != BOUND_EXPR) ||
        (target->high_bound.kind != BOUND_INTEGER && target->high_bound.kind != BOUND_EXPR))
        return val;

    uint32_t lo = Emit_Bound_Value(cg, &target->low_bound);
    uint32_t hi = Emit_Bound_Value(cg, &target->high_bound);
    if (!lo || !hi) return val;  /* Skip if bounds unavailable */

    uint32_t ok_label = cg->label_id++, raise_label = cg->label_id++, cont_label = cg->label_id++;

    /* val < low? */
    uint32_t cmp_lo = Emit_Temp(cg);
    Emit(cg, "  %%t%u = icmp slt i64 %%t%u, %%t%u\n", cmp_lo, val, lo);
    Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cmp_lo, raise_label, ok_label);

    Emit(cg, "L%u:\n", ok_label);
    /* val > high? */
    uint32_t cmp_hi = Emit_Temp(cg);
    Emit(cg, "  %%t%u = icmp sgt i64 %%t%u, %%t%u\n", cmp_hi, val, hi);
    Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cmp_hi, raise_label, cont_label);

    Emit(cg, "L%u:  ; raise CONSTRAINT_ERROR\n", raise_label);
    uint32_t exc_id = Emit_Temp(cg);
    Emit(cg, "  %%t%u = ptrtoint ptr @__exc.constraint_error to i64\n", exc_id);
    Emit(cg, "  call void @__ada_raise(i64 %%t%u)\n", exc_id);
    Emit(cg, "  unreachable\n");

    Emit(cg, "L%u:\n", cont_label);
    cg->block_terminated = false;
    return val;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.2.1 Fat Pointer Support for Unconstrained Arrays
 *
 * Unconstrained arrays use a "fat pointer" representation:
 *   %fat_ptr = type { ptr, { i64, i64 } }
 *
 * Where:
 *   - Field 0: pointer to array data
 *   - Field 1: bounds struct { low_bound, high_bound }
 *
 * This allows passing arrays without knowing their bounds at compile time.
 * ───────────────────────────────────────────────────────────────────────── */

/* Fat pointer type name */
#define FAT_PTR_TYPE "{ ptr, { i64, i64 } }"

/* Create a fat pointer from data pointer and bounds
 * Returns the temp ID of the fat pointer struct */
static uint32_t Emit_Fat_Pointer(Code_Generator *cg, uint32_t data_ptr,
                                  int64_t low, int64_t high) {
    /* Allocate fat pointer struct on stack */
    uint32_t fat_alloca = Emit_Temp(cg);
    Emit(cg, "  %%t%u = alloca " FAT_PTR_TYPE "\n", fat_alloca);

    /* Store data pointer */
    uint32_t data_gep = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr " FAT_PTR_TYPE ", ptr %%t%u, i32 0, i32 0\n",
         data_gep, fat_alloca);
    Emit(cg, "  store ptr %%t%u, ptr %%t%u\n", data_ptr, data_gep);

    /* Store low bound */
    uint32_t low_gep = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr " FAT_PTR_TYPE ", ptr %%t%u, i32 0, i32 1, i32 0\n",
         low_gep, fat_alloca);
    Emit(cg, "  store i64 %lld, ptr %%t%u\n", (long long)low, low_gep);

    /* Store high bound */
    uint32_t high_gep = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr " FAT_PTR_TYPE ", ptr %%t%u, i32 0, i32 1, i32 1\n",
         high_gep, fat_alloca);
    Emit(cg, "  store i64 %lld, ptr %%t%u\n", (long long)high, high_gep);

    /* Load and return the fat pointer struct */
    uint32_t fat_val = Emit_Temp(cg);
    Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u\n", fat_val, fat_alloca);
    return fat_val;
}

/* Extract data pointer from fat pointer */
static uint32_t Emit_Fat_Pointer_Data(Code_Generator *cg, uint32_t fat_ptr) {
    uint32_t t = Emit_Temp(cg);
    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 0\n", t, fat_ptr);
    return t;
}

/* Extract low bound from fat pointer */
static uint32_t Emit_Fat_Pointer_Low(Code_Generator *cg, uint32_t fat_ptr) {
    uint32_t t = Emit_Temp(cg);
    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 0\n", t, fat_ptr);
    return t;
}

/* Extract high bound from fat pointer */
static uint32_t Emit_Fat_Pointer_High(Code_Generator *cg, uint32_t fat_ptr) {
    uint32_t t = Emit_Temp(cg);
    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 1\n", t, fat_ptr);
    return t;
}

/* Create a fat pointer from data pointer and dynamic bounds (temp IDs)
 * Returns the temp ID of the fat pointer struct */
static uint32_t Emit_Fat_Pointer_Dynamic(Code_Generator *cg, uint32_t data_ptr,
                                          uint32_t low_temp, uint32_t high_temp) {
    /* Allocate fat pointer struct on stack */
    uint32_t fat_alloca = Emit_Temp(cg);
    Emit(cg, "  %%t%u = alloca " FAT_PTR_TYPE "\n", fat_alloca);

    /* Store data pointer */
    uint32_t data_gep = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr " FAT_PTR_TYPE ", ptr %%t%u, i32 0, i32 0\n",
         data_gep, fat_alloca);
    Emit(cg, "  store ptr %%t%u, ptr %%t%u\n", data_ptr, data_gep);

    /* Store low bound */
    uint32_t low_gep = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr " FAT_PTR_TYPE ", ptr %%t%u, i32 0, i32 1, i32 0\n",
         low_gep, fat_alloca);
    Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", low_temp, low_gep);

    /* Store high bound */
    uint32_t high_gep = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr " FAT_PTR_TYPE ", ptr %%t%u, i32 0, i32 1, i32 1\n",
         high_gep, fat_alloca);
    Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", high_temp, high_gep);

    /* Load and return the fat pointer struct */
    uint32_t fat_val = Emit_Temp(cg);
    Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u\n", fat_val, fat_alloca);
    return fat_val;
}

/* Compute length from fat pointer bounds: high - low + 1
 * Returns temp ID holding the i64 length */
static uint32_t Emit_Fat_Pointer_Length(Code_Generator *cg, uint32_t fat_ptr) {
    uint32_t low = Emit_Fat_Pointer_Low(cg, fat_ptr);
    uint32_t high = Emit_Fat_Pointer_High(cg, fat_ptr);
    uint32_t diff = Emit_Temp(cg);
    Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", diff, high, low);
    uint32_t len = Emit_Temp(cg);
    Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", len, diff);
    return len;
}

/* Copy data from fat pointer to a named destination
 * Emits: memcpy(dst, src_data, length) */
static void Emit_Fat_Pointer_Copy_To_Name(Code_Generator *cg, uint32_t fat_ptr, Symbol *dst) {
    uint32_t src_ptr = Emit_Fat_Pointer_Data(cg, fat_ptr);
    uint32_t len = Emit_Fat_Pointer_Length(cg, fat_ptr);
    Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%");
    Emit_Symbol_Name(cg, dst);
    Emit(cg, ", ptr %%t%u, i64 %%t%u, i1 false)\n", src_ptr, len);
}

/* Copy data from fat pointer to a temp pointer destination
 * Emits: memcpy(dst_ptr, src_data, length) */
__attribute__((unused))
static void Emit_Fat_Pointer_Copy_To_Ptr(Code_Generator *cg, uint32_t fat_ptr, uint32_t dst_ptr) {
    uint32_t src_ptr = Emit_Fat_Pointer_Data(cg, fat_ptr);
    uint32_t len = Emit_Fat_Pointer_Length(cg, fat_ptr);
    Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %%t%u, i1 false)\n",
         dst_ptr, src_ptr, len);
}

/* Load fat pointer from a symbol's storage — consolidates common pattern */
static uint32_t Emit_Load_Fat_Pointer(Code_Generator *cg, Symbol *sym) {
    uint32_t fat = Emit_Temp(cg);
    Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr ", fat);
    Emit_Symbol_Ref(cg, sym);
    Emit(cg, "\n");
    return fat;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.3 Expression Code Generation
 *
 * Returns the LLVM SSA value ID holding the expression result.
 * Every expression yields a value, and in SSA form every value has one definition.
 * ───────────────────────────────────────────────────────────────────────── */

static uint32_t Generate_Expression(Code_Generator *cg, Syntax_Node *node);

/* Generate code to evaluate a type bound at runtime.
 * Returns the temp register containing the bound value.
 * Per GNAT exp_imgv.adb, when bounds are not compile-time known,
 * we must generate code to evaluate them at runtime. */
static uint32_t Generate_Bound_Value(Code_Generator *cg, Type_Bound b) {
    uint32_t t = cg->temp_id++;
    if (b.kind == BOUND_INTEGER) {
        Emit(cg, "  %%t%u = add i64 0, %lld  ; bound (integer)\n", t, (long long)b.int_value);
        return t;
    }
    if (b.kind == BOUND_FLOAT) {
        Emit(cg, "  %%t%u = fptosi double %e to i64  ; bound (float)\n", t, b.float_value);
        return t;
    }
    if (b.kind == BOUND_EXPR && b.expr) {
        /* First try compile-time evaluation */
        double val = Eval_Const_Numeric(b.expr);
        if (val == val) {  /* Not NaN */
            Emit(cg, "  %%t%u = add i64 0, %lld  ; bound (const expr)\n", t, (long long)val);
            return t;
        }
        /* Must evaluate expression at runtime */
        return Generate_Expression(cg, b.expr);
    }
    Emit(cg, "  %%t%u = add i64 0, 0  ; bound (unknown)\n", t);
    return t;
}

static uint32_t Generate_Integer_Literal(Code_Generator *cg, Syntax_Node *node) {
    uint32_t t = Emit_Temp(cg);
    Emit(cg, "  %%t%u = add i64 0, %lld\n", t, (long long)node->integer_lit.value);
    return t;
}

static uint32_t Generate_Real_Literal(Code_Generator *cg, Syntax_Node *node) {
    uint32_t t = Emit_Temp(cg);
    /* Use IEEE 754 hex encoding for full precision
     * This preserves all 53 bits of mantissa (vs %f which loses precision)
     * The double value was computed from Big_Real during parsing */
    double d = node->real_lit.value;
    uint64_t bits;
    memcpy(&bits, &d, sizeof(bits));
    Emit(cg, "  %%t%u = fadd double 0.0, 0x%016llX\n", t, (unsigned long long)bits);
    return t;
}

static uint32_t Generate_String_Literal(Code_Generator *cg, Syntax_Node *node) {
    /* Allocate string constant */
    uint32_t str_id = cg->string_id++;
    uint32_t len = node->string_val.text.length;

    /* Generate global constant to buffer (without null terminator for Ada strings)
     * Use linkonce_odr to allow merging of duplicate string constants across units */
    Emit_String_Const(cg, "@.str%u = linkonce_odr unnamed_addr constant [%u x i8] c\"", str_id, len);
    for (uint32_t i = 0; i < len; i++) {
        char c = node->string_val.text.data[i];
        if (c >= 32 && c < 127 && c != '"' && c != '\\') {
            Emit_String_Const_Char(cg, c);
        } else {
            Emit_String_Const(cg, "\\%02X", (unsigned char)c);
        }
    }
    Emit_String_Const(cg, "\"\n");

    /* Get pointer to string data */
    uint32_t data_ptr = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr [%u x i8], ptr @.str%u, i64 0, i64 0\n",
         data_ptr, len, str_id);

    /* Return fat pointer with Ada STRING bounds (1..length) */
    return Emit_Fat_Pointer(cg, data_ptr, 1, (int64_t)len);
}

static uint32_t Generate_Identifier(Code_Generator *cg, Syntax_Node *node) {
    Symbol *sym = node->symbol;
    if (!sym) {
        Report_Error(node->location, "unresolved identifier in codegen");
        return 0;
    }

    /* Generic formal object substitution: if this is a formal object inside
     * a generic instantiation, generate code for the actual expression. */
    if (cg->current_instance && cg->current_instance->generic_actuals) {
        for (uint32_t i = 0; i < cg->current_instance->generic_actual_count; i++) {
            if (cg->current_instance->generic_actuals[i].actual_expr &&
                Slice_Equal_Ignore_Case(sym->name,
                    cg->current_instance->generic_actuals[i].formal_name)) {
                return Generate_Expression(cg,
                    cg->current_instance->generic_actuals[i].actual_expr);
            }
        }
    }

    /* For RENAMES: redirect to the renamed object */
    if (sym->renamed_object) {
        return Generate_Expression(cg, sym->renamed_object);
    }

    uint32_t t = Emit_Temp(cg);
    Type_Info *ty = sym->type;

    switch (sym->kind) {
        case SYMBOL_VARIABLE:
        case SYMBOL_PARAMETER: {
            /* Check for constrained string/array - return fat pointer */
            if (ty && ty->kind == TYPE_ARRAY && ty->array.is_constrained &&
                ty->array.element_type && ty->array.element_type->kind == TYPE_CHARACTER) {

                /* Get bounds from type */
                int64_t low = 1, high = 0;
                if (ty->array.index_count > 0) {
                    low = Type_Bound_Value(ty->array.indices[0].low_bound);
                    high = Type_Bound_Value(ty->array.indices[0].high_bound);
                }

                /* Get pointer to array data */
                uint32_t data_ptr = Emit_Temp(cg);
                Emit(cg, "  %%t%u = getelementptr i8, ptr ", data_ptr);
                Emit_Symbol_Ref(cg, sym);
                Emit(cg, ", i64 0\n");

                /* Create fat pointer with bounds */
                return Emit_Fat_Pointer(cg, data_ptr, low, high);
            }

            /* Check if this is an uplevel (outer scope) variable access
             * A variable is "uplevel" if its defining scope's owner is different
             * from the current function. For generic instances, the variable's
             * owner is the template, not the instance, so also check that. */
            Symbol *var_owner = sym->defining_scope ? sym->defining_scope->owner : NULL;
            bool is_uplevel = cg->current_function && var_owner &&
                              var_owner != cg->current_function &&
                              var_owner != cg->current_function->generic_template;

            const char *type_str = Type_To_Llvm(ty);
            if (is_uplevel && cg->is_nested) {
                /* Uplevel access through frame pointer parameter */
                Emit(cg, "  ; UPLEVEL ACCESS: %.*s via frame pointer\n",
                     (int)sym->name.length, sym->name.data);
                Emit(cg, "  %%t%u = load %s, ptr %%__frame.", t, type_str);
                Emit_Symbol_Name(cg, sym);
                Emit(cg, "\n");
            } else {
                Emit(cg, "  %%t%u = load %s, ptr ", t, type_str);
                Emit_Symbol_Ref(cg, sym);
                Emit(cg, "\n");
            }
            /* Widen to i64 for computation if narrower integer type.
             * But keep ptr types as ptr - they're used for dereference (.ALL)
             * and implicit dereference operations.
             * Also keep float types as their native type (float/double). */
            if (strcmp(type_str, "ptr") != 0 &&
                strcmp(type_str, "float") != 0 &&
                strcmp(type_str, "double") != 0) {
                t = Emit_Convert(cg, t, type_str, "i64");
            }
        } break;

        case SYMBOL_CONSTANT:
        case SYMBOL_LITERAL:
            /* Enumeration literal or constant */
            if (sym->type && sym->type->kind == TYPE_ENUMERATION) {
                /* Find position in enumeration */
                int64_t pos = 0;
                for (uint32_t i = 0; i < sym->type->enumeration.literal_count; i++) {
                    if (Slice_Equal_Ignore_Case(sym->type->enumeration.literals[i], sym->name)) {
                        pos = i;
                        break;
                    }
                }
                Emit(cg, "  %%t%u = add i64 0, %lld\n", t, (long long)pos);
            } else if (ty && ty->kind == TYPE_BOOLEAN) {
                /* Boolean literal: TRUE=1, FALSE=0 */
                int64_t pos = Slice_Equal_Ignore_Case(sym->name, S("TRUE")) ? 1 : 0;
                Emit(cg, "  %%t%u = add i64 0, %lld\n", t, (long long)pos);
            } else if (ty && ty->kind == TYPE_CHARACTER) {
                /* Character literal - already handled as NK_CHARACTER, but safety check */
                Emit(cg, "  %%t%u = add i64 0, 0  ; character literal\n", t);
            } else if (ty && ty->kind == TYPE_ARRAY && ty->array.is_constrained &&
                       ty->array.element_type && ty->array.element_type->kind == TYPE_CHARACTER) {
                /* Constant string/character array - return fat pointer like variable */
                int64_t low = 1, high = 0;
                if (ty->array.index_count > 0) {
                    low = Type_Bound_Value(ty->array.indices[0].low_bound);
                    high = Type_Bound_Value(ty->array.indices[0].high_bound);
                }

                /* Get pointer to constant array data */
                uint32_t data_ptr = Emit_Temp(cg);
                Emit(cg, "  %%t%u = getelementptr i8, ptr ", data_ptr);
                Emit_Symbol_Ref(cg, sym);
                Emit(cg, ", i64 0\n");

                /* Create fat pointer with bounds */
                return Emit_Fat_Pointer(cg, data_ptr, low, high);
            } else if (sym->kind == SYMBOL_CONSTANT && sym->is_named_number) {
                /* Named number (constant without explicit type) - evaluate initializer
                 * Named numbers in Ada are compile-time constants with no storage.
                 * Per RM 3.2.2: "A named number provides a name for a numeric value
                 * known at compile time." */
                Syntax_Node *decl = sym->declaration;
                if (decl && decl->kind == NK_OBJECT_DECL && decl->object_decl.init) {
                    /* Generate code for the initializer expression */
                    return Generate_Expression(cg, decl->object_decl.init);
                } else {
                    /* ??? Fallback if no initializer found */
                    Emit(cg, "  %%t%u = add i64 0, 0  ; named number without init\n", t);
                }
            } else if (sym->kind == SYMBOL_CONSTANT && !sym->is_named_number) {
                /* Typed constant - load value from storage like variable */
                const char *type_str = Type_To_Llvm(ty);
                Emit(cg, "  %%t%u = load %s, ptr ", t, type_str);
                Emit_Symbol_Ref(cg, sym);
                Emit(cg, "\n");
                /* Widen to i64 for computation if narrower integer type.
                 * But keep ptr types as ptr - records/access need pointers.
                 * Also keep float types as their native type (float/double). */
                if (strcmp(type_str, "ptr") != 0 &&
                    strcmp(type_str, "float") != 0 &&
                    strcmp(type_str, "double") != 0) {
                    t = Emit_Convert(cg, t, type_str, "i64");
                }
            } else {
                /* ??? Unknown literal type - emit 0 as fallback */
                Emit(cg, "  %%t%u = add i64 0, 0  ; unknown literal\n", t);
            }
            break;

        case SYMBOL_FUNCTION: {
            /* Parameterless function call: F is syntactically an identifier
             * but semantically a function call with zero arguments.
             * Generic formal subprogram substitution: if this is a formal subprogram
             * inside a generic instantiation, substitute with actual. */
            Symbol *actual = sym;
            if (cg->current_instance && cg->current_instance->generic_actuals) {
                for (uint32_t i = 0; i < cg->current_instance->generic_actual_count; i++) {
                    if (cg->current_instance->generic_actuals[i].actual_subprogram &&
                        Slice_Equal_Ignore_Case(sym->name,
                            cg->current_instance->generic_actuals[i].formal_name)) {
                        actual = cg->current_instance->generic_actuals[i].actual_subprogram;
                        break;
                    }
                }
            }

            /* Check if actual is an enumeration literal (e.g., RED, YELLOW) */
            if (actual->kind == SYMBOL_LITERAL &&
                actual->type && actual->type->kind == TYPE_ENUMERATION) {
                int64_t pos = 0;
                for (uint32_t i = 0; i < actual->type->enumeration.literal_count; i++) {
                    if (Slice_Equal_Ignore_Case(actual->type->enumeration.literals[i],
                                                actual->name)) {
                        pos = i;
                        break;
                    }
                }
                Emit(cg, "  %%t%u = add i64 0, %lld  ; enum literal as function\n",
                     t, (long long)pos);
            } else if (actual->kind == SYMBOL_FUNCTION) {
                /* Generate actual function call */
                const char *ret_type = actual->return_type ?
                    Type_To_Llvm(actual->return_type) : "i64";
                Emit(cg, "  %%t%u = call %s @", t, ret_type);
                Emit_Symbol_Name(cg, actual);
                /* Handle nested function: pass parent frame if needed */
                bool callee_is_nested = actual->parent &&
                    (actual->parent->kind == SYMBOL_FUNCTION ||
                     actual->parent->kind == SYMBOL_PROCEDURE);
                if (callee_is_nested) {
                    if (cg->current_function == actual->parent) {
                        Emit(cg, "(ptr %%__frame_base)\n");
                    } else if (cg->is_nested && cg->current_function &&
                               cg->current_function->parent == actual->parent) {
                        Emit(cg, "(ptr %%__parent_frame)\n");
                    } else {
                        Emit(cg, "(ptr null)\n");
                    }
                } else {
                    Emit(cg, "()\n");
                }
                /* Convert to i64 if narrower */
                t = Emit_Convert(cg, t, ret_type, "i64");
            } else {
                /* Fallback for other symbol kinds */
                Emit(cg, "  %%t%u = add i64 0, 0  ; unhandled function symbol\n", t);
            }
        } break;

        default:
            /* ??? */
            Emit(cg, "  %%t%u = add i64 0, 0  ; unhandled symbol kind\n", t);
    }

    return t;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.3.1 Implicit Operators for Composite Types
 *
 * Ada requires equality operators for all non-limited types. For composite
 * types (records, arrays), equality is defined component-wise.
 * ───────────────────────────────────────────────────────────────────────── */

/* Forward declaration for mutual recursion */
static uint32_t Generate_Array_Equality(Code_Generator *cg, uint32_t left_ptr,
                                        uint32_t right_ptr, Type_Info *array_type);

/* Generate equality comparison for record types (component-by-component) */
static uint32_t Generate_Record_Equality(Code_Generator *cg, uint32_t left_ptr,
                                         uint32_t right_ptr, Type_Info *record_type) {
    if (!record_type || record_type->kind != TYPE_RECORD ||
        record_type->record.component_count == 0) {
        /* Empty record or invalid - always equal */
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = add i1 0, 1  ; empty record equality\n", t);
        return t;
    }

    uint32_t result = 0;
    for (uint32_t i = 0; i < record_type->record.component_count; i++) {
        Component_Info *comp = &record_type->record.components[i];
        const char *comp_llvm_type = Type_To_Llvm(comp->component_type);

        /* Get pointers to components */
        uint32_t left_gep = Emit_Temp(cg);
        uint32_t right_gep = Emit_Temp(cg);
        Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n",
             left_gep, left_ptr, comp->byte_offset);
        Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n",
             right_gep, right_ptr, comp->byte_offset);

        /* Compare component - handle arrays/strings specially */
        uint32_t cmp;
        Type_Info *ct = comp->component_type;
        bool is_fat_ptr_access = ct && ct->kind == TYPE_ACCESS &&
            ct->access.designated_type &&
            (ct->access.designated_type->kind == TYPE_STRING ||
             (ct->access.designated_type->kind == TYPE_ARRAY &&
              !ct->access.designated_type->array.is_constrained));

        if (ct && (ct->kind == TYPE_STRING ||
                   (ct->kind == TYPE_ARRAY && !ct->array.is_constrained))) {
            /* Unconstrained array/string - use array equality on the fat pointers */
            cmp = Generate_Array_Equality(cg, left_gep, right_gep, ct);
        } else if (ct && ct->kind == TYPE_ARRAY && ct->array.is_constrained) {
            /* Constrained array - use array equality directly on pointers */
            cmp = Generate_Array_Equality(cg, left_gep, right_gep, ct);
        } else if (ct && ct->kind == TYPE_RECORD) {
            /* Nested record - recurse */
            cmp = Generate_Record_Equality(cg, left_gep, right_gep, ct);
        } else if (is_fat_ptr_access) {
            /* ACCESS to unconstrained array - compare fat pointer components
             * Fat pointer: { ptr data, { i64 low, i64 high } }
             * Access equality compares pointer identity (same object) */
            uint32_t left_val = Emit_Temp(cg);
            uint32_t right_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u\n", left_val, left_gep);
            Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u\n", right_val, right_gep);
            uint32_t lp = Emit_Temp(cg), rp = Emit_Temp(cg);
            uint32_t ll = Emit_Temp(cg), rl = Emit_Temp(cg);
            uint32_t lh = Emit_Temp(cg), rh = Emit_Temp(cg);
            Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 0\n", lp, left_val);
            Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 0\n", rp, right_val);
            Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 0\n", ll, left_val);
            Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 0\n", rl, right_val);
            Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 1\n", lh, left_val);
            Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 1\n", rh, right_val);
            uint32_t cmp_p = Emit_Temp(cg), cmp_l = Emit_Temp(cg), cmp_h = Emit_Temp(cg);
            Emit(cg, "  %%t%u = icmp eq ptr %%t%u, %%t%u\n", cmp_p, lp, rp);
            Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n", cmp_l, ll, rl);
            Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n", cmp_h, lh, rh);
            uint32_t and1 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", and1, cmp_p, cmp_l);
            cmp = Emit_Temp(cg);
            Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", cmp, and1, cmp_h);
        } else {
            /* Scalar type - load and compare */
            uint32_t left_val = Emit_Temp(cg);
            uint32_t right_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load %s, ptr %%t%u\n", left_val, comp_llvm_type, left_gep);
            Emit(cg, "  %%t%u = load %s, ptr %%t%u\n", right_val, comp_llvm_type, right_gep);

            cmp = Emit_Temp(cg);
            if (Type_Is_Float_Representation(ct)) {
                Emit(cg, "  %%t%u = fcmp oeq %s %%t%u, %%t%u\n",
                     cmp, comp_llvm_type, left_val, right_val);
            } else {
                Emit(cg, "  %%t%u = icmp eq %s %%t%u, %%t%u\n",
                     cmp, comp_llvm_type, left_val, right_val);
            }
        }

        /* AND with previous results */
        if (i == 0) {
            result = cmp;
        } else {
            uint32_t and_result = Emit_Temp(cg);
            Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", and_result, result, cmp);
            result = and_result;
        }
    }

    return result;
}

/* Generate equality comparison for constrained array types (element-by-element) */
static uint32_t Generate_Array_Equality(Code_Generator *cg, uint32_t left_ptr,
                                        uint32_t right_ptr, Type_Info *array_type) {
    if (!array_type || (array_type->kind != TYPE_ARRAY && array_type->kind != TYPE_STRING)) {
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = add i1 0, 1  ; invalid array equality\n", t);
        return t;
    }

    /* For constrained arrays, use memcmp */
    if (array_type->array.is_constrained) {
        int64_t count = Array_Element_Count(array_type);
        uint32_t elem_size = array_type->array.element_type ?
                             array_type->array.element_type->size : 4;
        int64_t total_size = count * elem_size;

        /* Call llvm.memcmp or compare byte-by-byte */
        uint32_t result = Emit_Temp(cg);
        uint32_t cmp_result = Emit_Temp(cg);

        /* Use LLVM's memcmp intrinsic equivalent */
        Emit(cg, "  %%t%u = call i32 @memcmp(ptr %%t%u, ptr %%t%u, i64 %lld)\n",
             result, left_ptr, right_ptr, (long long)total_size);
        Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", cmp_result, result);
        return cmp_result;
    }

    /*
     * Unconstrained array equality (per RM 4.5.2):
     * Two arrays are equal iff they have the same length and matching components.
     * Bounds themselves need not match—only length and content.
     *
     * For fat pointers: compare lengths, then data if lengths match.
     * Use select instead of phi to avoid block label complications.
     */

    /* Extract bounds from fat pointer structures */
    uint32_t left_low = Emit_Fat_Pointer_Low(cg, left_ptr);
    uint32_t left_high = Emit_Fat_Pointer_High(cg, left_ptr);
    uint32_t right_low = Emit_Fat_Pointer_Low(cg, right_ptr);
    uint32_t right_high = Emit_Fat_Pointer_High(cg, right_ptr);

    /* Compute lengths: high - low + 1 */
    uint32_t left_len = Emit_Temp(cg);
    Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", left_len, left_high, left_low);
    uint32_t left_len1 = Emit_Temp(cg);
    Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", left_len1, left_len);

    uint32_t right_len = Emit_Temp(cg);
    Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", right_len, right_high, right_low);
    uint32_t right_len1 = Emit_Temp(cg);
    Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", right_len1, right_len);

    /* Compare lengths */
    uint32_t len_eq = Emit_Temp(cg);
    Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n", len_eq, left_len1, right_len1);

    /* Extract data pointers */
    uint32_t left_data = Emit_Fat_Pointer_Data(cg, left_ptr);
    uint32_t right_data = Emit_Fat_Pointer_Data(cg, right_ptr);

    /* Compute byte size for memcmp */
    uint32_t elem_size = array_type->array.element_type ?
                         array_type->array.element_type->size : 1;
    uint32_t byte_size = Emit_Temp(cg);
    Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_size, left_len1, elem_size);

    /* Call memcmp */
    uint32_t memcmp_result = Emit_Temp(cg);
    Emit(cg, "  %%t%u = call i32 @memcmp(ptr %%t%u, ptr %%t%u, i64 %%t%u)\n",
         memcmp_result, left_data, right_data, byte_size);
    uint32_t data_eq = Emit_Temp(cg);
    Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", data_eq, memcmp_result);

    /* Result: lengths match AND data matches */
    uint32_t result = Emit_Temp(cg);
    Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", result, len_eq, data_eq);

    return result;
}

/* Generate the address of a composite type expression (for equality comparison) */
static uint32_t Generate_Composite_Address(Code_Generator *cg, Syntax_Node *node) {
    /* Generate the ADDRESS of an lvalue (identifier, selected, indexed) */
    if (node->kind == NK_IDENTIFIER) {
        Symbol *sym = node->symbol;
        if (sym) {
            /* Check if this is an uplevel (outer scope) variable access */
            Symbol *var_owner = sym->defining_scope ? sym->defining_scope->owner : NULL;
            bool is_uplevel = cg->current_function && var_owner &&
                              var_owner != cg->current_function &&
                              var_owner != cg->current_function->generic_template;

            uint32_t t = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr i8, ptr ", t);
            if (is_uplevel && cg->is_nested) {
                /* Uplevel access through frame pointer */
                Emit(cg, "%%__frame.");
                Emit_Symbol_Name(cg, sym);
            } else {
                Emit_Symbol_Ref(cg, sym);
            }
            Emit(cg, ", i64 0\n");
            return t;
        }
    }

    if (node->kind == NK_SELECTED) {
        /* Field access: Rec.Field - compute address of field */
        Type_Info *prefix_type = node->selected.prefix ? node->selected.prefix->type : NULL;

        /* Handle implicit dereference: U.A where U is access-to-record.
         * First load the pointer, then compute field address. */
        Type_Info *record_type = prefix_type;
        bool implicit_deref = false;
        if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
            prefix_type->access.designated_type &&
            prefix_type->access.designated_type->kind == TYPE_RECORD) {
            record_type = prefix_type->access.designated_type;
            implicit_deref = true;
        }

        if (record_type && record_type->kind == TYPE_RECORD) {
            uint32_t base;
            if (implicit_deref) {
                /* Load the access value (pointer to record) */
                Symbol *access_sym = node->selected.prefix->symbol;
                base = Emit_Temp(cg);
                if (access_sym) {
                    /* Check for uplevel access (variable in outer scope) */
                    Symbol *var_owner = access_sym->defining_scope
                                       ? access_sym->defining_scope->owner : NULL;
                    bool is_uplevel = cg->current_function && var_owner &&
                                      var_owner != cg->current_function &&
                                      var_owner != cg->current_function->generic_template;
                    if (is_uplevel && cg->is_nested) {
                        Emit(cg, "  %%t%u = load ptr, ptr %%__frame.", base);
                        Emit_Symbol_Name(cg, access_sym);
                        Emit(cg, "  ; uplevel implicit deref for field address\n");
                    } else {
                        Emit(cg, "  %%t%u = load ptr, ptr ", base);
                        Emit_Symbol_Ref(cg, access_sym);
                        Emit(cg, "  ; implicit deref for field address\n");
                    }
                } else {
                    uint32_t ptr = Generate_Expression(cg, node->selected.prefix);
                    base = ptr;  /* Already a ptr from access expr */
                }
            } else {
                base = Generate_Composite_Address(cg, node->selected.prefix);
            }
            /* Find field offset */
            uint32_t offset = 0;
            for (uint32_t i = 0; i < record_type->record.component_count; i++) {
                if (Slice_Equal_Ignore_Case(
                        record_type->record.components[i].name, node->selected.selector)) {
                    offset = record_type->record.components[i].byte_offset;
                    break;
                }
            }
            uint32_t addr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n", addr, base, offset);
            return addr;
        }
    }

    if (node->kind == NK_APPLY && node->apply.arguments.count == 1) {
        /* Array indexing: Arr(I) - compute address of element */
        Type_Info *prefix_type = node->apply.prefix ? node->apply.prefix->type : NULL;
        if (prefix_type && prefix_type->kind == TYPE_ARRAY) {
            uint32_t elem_size = prefix_type->array.element_type
                                 ? prefix_type->array.element_type->size : 1;
            if (elem_size == 0) elem_size = 1;
            int64_t low = Array_Low_Bound(prefix_type);

            uint32_t base = Generate_Composite_Address(cg, node->apply.prefix);
            uint32_t idx = Generate_Expression(cg, node->apply.arguments.items[0]);

            /* Adjust index: byte_offset = (idx - low) * elem_size */
            uint32_t adj_idx = idx;
            if (low != 0) {
                adj_idx = Emit_Temp(cg);
                Emit(cg, "  %%t%u = sub i64 %%t%u, %lld\n", adj_idx, idx, (long long)low);
            }
            uint32_t byte_off = Emit_Temp(cg);
            if (elem_size == 1) {
                byte_off = adj_idx;
            } else {
                Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_off, adj_idx, elem_size);
            }
            uint32_t addr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n", addr, base, byte_off);
            return addr;
        }
        /* Handle unconstrained arrays passed as fat pointers */
        if (prefix_type && prefix_type->kind == TYPE_STRING) {
            /* Fat pointer - extract data and compute element address */
            uint32_t fat = Generate_Expression(cg, node->apply.prefix);
            uint32_t data = Emit_Fat_Pointer_Data(cg, fat);
            uint32_t low = Emit_Fat_Pointer_Low(cg, fat);
            uint32_t idx = Generate_Expression(cg, node->apply.arguments.items[0]);
            uint32_t adj_idx = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", adj_idx, idx, low);
            uint32_t addr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n", addr, data, adj_idx);
            return addr;
        }
    }

    /* Fallback: for expressions that return a pointer (like composite values) */
    return Generate_Expression(cg, node);
}

static uint32_t Generate_Binary_Op(Code_Generator *cg, Syntax_Node *node) {
    /* Check if this is equality/inequality on composite types */
    Type_Info *left_type = node->binary.left ? node->binary.left->type : NULL;

    if ((node->binary.op == TK_EQ || node->binary.op == TK_NE) &&
        left_type && Type_Is_Composite(left_type)) {
        /* Composite type comparison */
        uint32_t eq_result;

        bool left_is_slice = Expression_Is_Slice(node->binary.left);
        bool right_is_slice = Expression_Is_Slice(node->binary.right);
        bool is_unconstrained = Type_Is_Unconstrained_Array(left_type) ||
                                left_type->kind == TYPE_STRING;

        /* Handle slice comparisons specially - they have mixed representations */
        if ((left_is_slice || right_is_slice) && !is_unconstrained) {
            /* At least one slice with constrained type - generate inline comparison */
            uint32_t left_data, right_data;
            uint32_t left_low, left_high, right_low, right_high;
            uint32_t elem_size = left_type->array.element_type ?
                                 left_type->array.element_type->size : 8;

            /* Generate left operand */
            if (left_is_slice) {
                uint32_t left_fat = Generate_Expression(cg, node->binary.left);
                left_data = Emit_Fat_Pointer_Data(cg, left_fat);
                left_low = Emit_Fat_Pointer_Low(cg, left_fat);
                left_high = Emit_Fat_Pointer_High(cg, left_fat);
            } else {
                left_data = Generate_Composite_Address(cg, node->binary.left);
                /* Get static bounds from type */
                int64_t low_val = Type_Bound_Value(left_type->array.indices[0].low_bound);
                int64_t high_val = Type_Bound_Value(left_type->array.indices[0].high_bound);
                left_low = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", left_low, (long long)low_val);
                left_high = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", left_high, (long long)high_val);
            }

            /* Generate right operand */
            if (right_is_slice) {
                uint32_t right_fat = Generate_Expression(cg, node->binary.right);
                right_data = Emit_Fat_Pointer_Data(cg, right_fat);
                right_low = Emit_Fat_Pointer_Low(cg, right_fat);
                right_high = Emit_Fat_Pointer_High(cg, right_fat);
            } else {
                right_data = Generate_Composite_Address(cg, node->binary.right);
                /* Get static bounds from type - use right type if available */
                Type_Info *rtype = node->binary.right->type ? node->binary.right->type : left_type;
                int64_t low_val = 1, high_val = 1;
                if (rtype && (rtype->kind == TYPE_ARRAY || rtype->kind == TYPE_STRING) &&
                    rtype->array.index_count > 0) {
                    low_val = Type_Bound_Value(rtype->array.indices[0].low_bound);
                    high_val = Type_Bound_Value(rtype->array.indices[0].high_bound);
                }
                right_low = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", right_low, (long long)low_val);
                right_high = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", right_high, (long long)high_val);
            }

            /* Compute lengths */
            uint32_t left_len = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", left_len, left_high, left_low);
            uint32_t left_len1 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", left_len1, left_len);

            uint32_t right_len = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", right_len, right_high, right_low);
            uint32_t right_len1 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", right_len1, right_len);

            /* Compare lengths */
            uint32_t len_eq = Emit_Temp(cg);
            Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n", len_eq, left_len1, right_len1);

            /* Compare data with memcmp */
            uint32_t byte_size = Emit_Temp(cg);
            Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_size, left_len1, elem_size);
            uint32_t memcmp_result = Emit_Temp(cg);
            Emit(cg, "  %%t%u = call i32 @memcmp(ptr %%t%u, ptr %%t%u, i64 %%t%u)\n",
                 memcmp_result, left_data, right_data, byte_size);
            uint32_t data_eq = Emit_Temp(cg);
            Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", data_eq, memcmp_result);

            /* Result: lengths match AND data matches */
            eq_result = Emit_Temp(cg);
            Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", eq_result, len_eq, data_eq);
        } else {
            /* Standard path: both operands have same representation */
            uint32_t left_ptr, right_ptr;
            if (is_unconstrained) {
                left_ptr = Generate_Expression(cg, node->binary.left);
                right_ptr = Generate_Expression(cg, node->binary.right);
            } else {
                left_ptr = Generate_Composite_Address(cg, node->binary.left);
                right_ptr = Generate_Composite_Address(cg, node->binary.right);
            }
            eq_result = Emit_Temp(cg);

            if (left_type->equality_func_name) {
                const char *arg_type = Type_To_Llvm(left_type);
                Emit(cg, "  %%t%u = call i1 @%s(%s %%t%u, %s %%t%u)\n",
                     eq_result, left_type->equality_func_name, arg_type, left_ptr, arg_type, right_ptr);
            } else {
                if (left_type->kind == TYPE_RECORD) {
                    eq_result = Generate_Record_Equality(cg, left_ptr, right_ptr, left_type);
                } else {
                    eq_result = Generate_Array_Equality(cg, left_ptr, right_ptr, left_type);
                }
            }
        }

        /* For /= operator, negate the result */
        if (node->binary.op == TK_NE) {
            uint32_t ne_result = Emit_Temp(cg);
            Emit(cg, "  %%t%u = xor i1 %%t%u, 1\n", ne_result, eq_result);
            return ne_result;
        }
        return eq_result;
    }

    /* Array relational comparisons (lexicographic) */
    if ((node->binary.op == TK_LT || node->binary.op == TK_LE ||
         node->binary.op == TK_GT || node->binary.op == TK_GE) &&
        left_type && (left_type->kind == TYPE_ARRAY || left_type->kind == TYPE_STRING)) {
        /* Get addresses of both arrays for comparison */
        uint32_t left_ptr, right_ptr;
        /* Slices produce fat pointers at runtime even with constrained type */
        bool is_unconstrained = Type_Is_Unconstrained_Array(left_type) ||
                                left_type->kind == TYPE_STRING ||
                                Expression_Is_Slice(node->binary.left) ||
                                Expression_Is_Slice(node->binary.right);
        if (is_unconstrained) {
            left_ptr = Generate_Expression(cg, node->binary.left);
            right_ptr = Generate_Expression(cg, node->binary.right);
        } else {
            left_ptr = Generate_Composite_Address(cg, node->binary.left);
            right_ptr = Generate_Composite_Address(cg, node->binary.right);
        }

        uint32_t memcmp_result, cmp_result;

        if (left_type->array.is_constrained) {
            /* Constrained array: same size, use memcmp directly */
            int64_t count = Array_Element_Count(left_type);
            uint32_t elem_size = left_type->array.element_type ?
                                 left_type->array.element_type->size : 1;
            int64_t total_size = count * elem_size;

            memcmp_result = Emit_Temp(cg);
            Emit(cg, "  %%t%u = call i32 @memcmp(ptr %%t%u, ptr %%t%u, i64 %lld)\n",
                 memcmp_result, left_ptr, right_ptr, (long long)total_size);
        } else {
            /* Unconstrained array: compare min length, handle different lengths.
             * For lexicographic: compare common prefix, shorter array is "less" if prefix equal. */
            uint32_t left_low = Emit_Fat_Pointer_Low(cg, left_ptr);
            uint32_t left_high = Emit_Fat_Pointer_High(cg, left_ptr);
            uint32_t right_low = Emit_Fat_Pointer_Low(cg, right_ptr);
            uint32_t right_high = Emit_Fat_Pointer_High(cg, right_ptr);

            /* Compute lengths */
            uint32_t left_len = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", left_len, left_high, left_low);
            uint32_t left_len1 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", left_len1, left_len);

            uint32_t right_len = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", right_len, right_high, right_low);
            uint32_t right_len1 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", right_len1, right_len);

            /* Get min length for comparison */
            uint32_t len_cmp = Emit_Temp(cg);
            Emit(cg, "  %%t%u = icmp slt i64 %%t%u, %%t%u\n", len_cmp, left_len1, right_len1);
            uint32_t min_len = Emit_Temp(cg);
            Emit(cg, "  %%t%u = select i1 %%t%u, i64 %%t%u, i64 %%t%u\n",
                 min_len, len_cmp, left_len1, right_len1);

            /* Get data pointers */
            uint32_t left_data = Emit_Fat_Pointer_Data(cg, left_ptr);
            uint32_t right_data = Emit_Fat_Pointer_Data(cg, right_ptr);

            /* Compute byte size for memcmp */
            uint32_t elem_size = left_type->array.element_type ?
                                 left_type->array.element_type->size : 1;
            uint32_t byte_size = Emit_Temp(cg);
            Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_size, min_len, elem_size);

            /* Compare common prefix */
            uint32_t prefix_cmp = Emit_Temp(cg);
            Emit(cg, "  %%t%u = call i32 @memcmp(ptr %%t%u, ptr %%t%u, i64 %%t%u)\n",
                 prefix_cmp, left_data, right_data, byte_size);

            /* If prefix equal, compare lengths:
             * left < right if prefix equal and left shorter
             * Encode as: prefix_cmp != 0 ? prefix_cmp : (left_len - right_len) clamped to -1/0/1 */
            uint32_t len_diff = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", len_diff, left_len1, right_len1);
            uint32_t len_diff32 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = trunc i64 %%t%u to i32\n", len_diff32, len_diff);

            uint32_t prefix_zero = Emit_Temp(cg);
            Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", prefix_zero, prefix_cmp);

            memcmp_result = Emit_Temp(cg);
            Emit(cg, "  %%t%u = select i1 %%t%u, i32 %%t%u, i32 %%t%u\n",
                 memcmp_result, prefix_zero, len_diff32, prefix_cmp);
        }

        /* Compare memcmp result with 0 based on operator */
        cmp_result = Emit_Temp(cg);
        switch (node->binary.op) {
            case TK_LT:
                Emit(cg, "  %%t%u = icmp slt i32 %%t%u, 0\n", cmp_result, memcmp_result);
                break;
            case TK_LE:
                Emit(cg, "  %%t%u = icmp sle i32 %%t%u, 0\n", cmp_result, memcmp_result);
                break;
            case TK_GT:
                Emit(cg, "  %%t%u = icmp sgt i32 %%t%u, 0\n", cmp_result, memcmp_result);
                break;
            case TK_GE:
                Emit(cg, "  %%t%u = icmp sge i32 %%t%u, 0\n", cmp_result, memcmp_result);
                break;
            default:
                Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", cmp_result, memcmp_result);
        }
        return cmp_result;
    }

    /* Short-circuit boolean operators: AND THEN, OR ELSE
     * These must NOT evaluate the right operand if the left operand
     * determines the result (Ada RM 4.5.1). */
    if (node->binary.op == TK_AND_THEN) {
        /* AND THEN: if left is false, result is false (don't evaluate right)
         *           if left is true, result is right */
        uint32_t left = Generate_Expression(cg, node->binary.left);
        const char *left_llvm = Expression_Llvm_Type(node->binary.left);
        uint32_t left_i1 = Emit_Convert(cg, left, left_llvm, "i1");

        uint32_t eval_right_label = cg->label_id++;
        uint32_t done_label = cg->label_id++;
        uint32_t left_block_label = cg->label_id++;

        /* Save current block for phi */
        Emit(cg, "  br label %%Landthen_check%u\n", left_block_label);
        Emit(cg, "Landthen_check%u:\n", left_block_label);
        Emit(cg, "  br i1 %%t%u, label %%Landthen_right%u, label %%Landthen_done%u\n",
             left_i1, eval_right_label, done_label);

        /* Evaluate right if left was true */
        Emit(cg, "Landthen_right%u:\n", eval_right_label);
        uint32_t right = Generate_Expression(cg, node->binary.right);
        const char *right_llvm = Expression_Llvm_Type(node->binary.right);
        uint32_t right_i1 = Emit_Convert(cg, right, right_llvm, "i1");
        uint32_t right_done_label = cg->label_id++;
        Emit(cg, "  br label %%Landthen_merge%u\n", right_done_label);
        Emit(cg, "Landthen_merge%u:\n", right_done_label);
        Emit(cg, "  br label %%Landthen_done%u\n", done_label);

        /* Merge point */
        Emit(cg, "Landthen_done%u:\n", done_label);
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = phi i1 [ false, %%Landthen_check%u ], [ %%t%u, %%Landthen_merge%u ]\n",
             t, left_block_label, right_i1, right_done_label);
        return t;
    }

    if (node->binary.op == TK_OR_ELSE) {
        /* OR ELSE: if left is true, result is true (don't evaluate right)
         *          if left is false, result is right */
        uint32_t left = Generate_Expression(cg, node->binary.left);
        const char *left_llvm = Expression_Llvm_Type(node->binary.left);
        uint32_t left_i1 = Emit_Convert(cg, left, left_llvm, "i1");

        uint32_t eval_right_label = cg->label_id++;
        uint32_t done_label = cg->label_id++;
        uint32_t left_block_label = cg->label_id++;

        /* Save current block for phi */
        Emit(cg, "  br label %%Lorelse_check%u\n", left_block_label);
        Emit(cg, "Lorelse_check%u:\n", left_block_label);
        Emit(cg, "  br i1 %%t%u, label %%Lorelse_done%u, label %%Lorelse_right%u\n",
             left_i1, done_label, eval_right_label);

        /* Evaluate right if left was false */
        Emit(cg, "Lorelse_right%u:\n", eval_right_label);
        uint32_t right = Generate_Expression(cg, node->binary.right);
        const char *right_llvm = Expression_Llvm_Type(node->binary.right);
        uint32_t right_i1 = Emit_Convert(cg, right, right_llvm, "i1");
        uint32_t right_done_label = cg->label_id++;
        Emit(cg, "  br label %%Lorelse_merge%u\n", right_done_label);
        Emit(cg, "Lorelse_merge%u:\n", right_done_label);
        Emit(cg, "  br label %%Lorelse_done%u\n", done_label);

        /* Merge point */
        Emit(cg, "Lorelse_done%u:\n", done_label);
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = phi i1 [ true, %%Lorelse_check%u ], [ %%t%u, %%Lorelse_merge%u ]\n",
             t, left_block_label, right_i1, right_done_label);
        return t;
    }

    /* String/array concatenation */
    if (node->binary.op == TK_AMPERSAND && Type_Is_Array_Like(left_type)) {

        /* Generate both operands - they return fat pointers */
        uint32_t left_fat = Generate_Expression(cg, node->binary.left);
        uint32_t right_fat = Generate_Expression(cg, node->binary.right);

        /* Extract data pointers and bounds */
        uint32_t left_data = Emit_Fat_Pointer_Data(cg, left_fat);
        uint32_t left_low = Emit_Fat_Pointer_Low(cg, left_fat);
        uint32_t left_high = Emit_Fat_Pointer_High(cg, left_fat);

        uint32_t right_data = Emit_Fat_Pointer_Data(cg, right_fat);
        uint32_t right_low = Emit_Fat_Pointer_Low(cg, right_fat);
        uint32_t right_high = Emit_Fat_Pointer_High(cg, right_fat);

        /* Calculate lengths: high - low + 1 */
        uint32_t left_len = Emit_Temp(cg);
        Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", left_len, left_high, left_low);
        uint32_t left_len1 = Emit_Temp(cg);
        Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", left_len1, left_len);

        uint32_t right_len = Emit_Temp(cg);
        Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", right_len, right_high, right_low);
        uint32_t right_len1 = Emit_Temp(cg);
        Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", right_len1, right_len);

        /* Total length */
        uint32_t total_len = Emit_Temp(cg);
        Emit(cg, "  %%t%u = add i64 %%t%u, %%t%u\n", total_len, left_len1, right_len1);

        /* Allocate space on secondary stack */
        uint32_t result_data = Emit_Temp(cg);
        Emit(cg, "  %%t%u = call ptr @__ada_sec_stack_alloc(i64 %%t%u)\n",
             result_data, total_len);

        /* Copy left string using llvm.memcpy */
        Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %%t%u, i1 false)\n",
             result_data, left_data, left_len1);

        /* Calculate destination for right string */
        uint32_t right_dest = Emit_Temp(cg);
        Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n",
             right_dest, result_data, left_len1);

        /* Copy right string */
        Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %%t%u, i1 false)\n",
             right_dest, right_data, right_len1);

        /* Result bounds: 1..total_len (Ada STRING convention) */
        uint32_t one = Emit_Temp(cg);
        Emit(cg, "  %%t%u = add i64 0, 1\n", one);

        /* Return fat pointer to result */
        return Emit_Fat_Pointer_Dynamic(cg, result_data, one, total_len);
    }

    uint32_t left = Generate_Expression(cg, node->binary.left);
    uint32_t right = Generate_Expression(cg, node->binary.right);
    uint32_t t = Emit_Temp(cg);

    const char *op;
    Type_Info *result_type = node->type;
    Type_Info *lhs_type = node->binary.left ? node->binary.left->type : NULL;
    Type_Info *rhs_type = node->binary.right ? node->binary.right->type : NULL;
    bool is_float = result_type && (result_type->kind == TYPE_FLOAT ||
                                     result_type->kind == TYPE_UNIVERSAL_REAL);
    bool is_fixed = result_type && result_type->kind == TYPE_FIXED;

    /* Mixed-mode arithmetic: when result is float but operands are integer,
     * convert integer operands to float for proper arithmetic (RM 4.5.5) */
    if (is_float) {
        bool lhs_is_float = lhs_type && (lhs_type->kind == TYPE_FLOAT ||
                                          lhs_type->kind == TYPE_UNIVERSAL_REAL);
        bool rhs_is_float = rhs_type && (rhs_type->kind == TYPE_FLOAT ||
                                          rhs_type->kind == TYPE_UNIVERSAL_REAL);
        if (!lhs_is_float) {
            uint32_t conv = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sitofp i64 %%t%u to double\n", conv, left);
            left = conv;
        }
        /* For exponentiation, skip RHS conversion - TK_EXPON handles it */
        if (!rhs_is_float && node->binary.op != TK_EXPON) {
            uint32_t conv = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sitofp i64 %%t%u to double\n", conv, right);
            right = conv;
        }
    }

    /* Mixed fixed-point / universal_real arithmetic (RM 4.5.5, 4.10):
     * When result is fixed-point but an operand is universal_real, convert
     * the universal_real to the fixed-point's scaled integer representation.
     * For fixed type with small S, value V converts to: floor(V / S)
     * Skip for exponentiation which has its own special handling. */
    if (is_fixed && node->binary.op != TK_EXPON) {
        double small = result_type->fixed.small;
        if (small <= 0) small = result_type->fixed.delta > 0 ? result_type->fixed.delta : 1.0;

        if (rhs_type && rhs_type->kind == TYPE_UNIVERSAL_REAL) {
            /* Convert double to scaled integer: fptosi(V / small) */
            uint32_t scaled = Emit_Temp(cg);
            uint64_t small_bits;
            memcpy(&small_bits, &small, sizeof(small_bits));
            uint32_t small_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = fadd double 0.0, 0x%016llX  ; small=%g\n",
                 small_val, (unsigned long long)small_bits, small);
            uint32_t divided = Emit_Temp(cg);
            Emit(cg, "  %%t%u = fdiv double %%t%u, %%t%u\n", divided, right, small_val);
            Emit(cg, "  %%t%u = fptosi double %%t%u to i64\n", scaled, divided);
            right = scaled;
        }
        if (lhs_type && lhs_type->kind == TYPE_UNIVERSAL_REAL) {
            /* Convert double to scaled integer */
            uint32_t scaled = Emit_Temp(cg);
            uint64_t small_bits;
            memcpy(&small_bits, &small, sizeof(small_bits));
            uint32_t small_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = fadd double 0.0, 0x%016llX  ; small=%g\n",
                 small_val, (unsigned long long)small_bits, small);
            uint32_t divided = Emit_Temp(cg);
            Emit(cg, "  %%t%u = fdiv double %%t%u, %%t%u\n", divided, left, small_val);
            Emit(cg, "  %%t%u = fptosi double %%t%u to i64\n", scaled, divided);
            left = scaled;
        }
    }

    /* Fixed-point multiplication/division needs scaling (RM 4.5.5) */
    if (is_fixed && (node->binary.op == TK_STAR || node->binary.op == TK_SLASH)) {
        int scale = result_type->fixed.scale;
        if (node->binary.op == TK_STAR) {
            /* Fixed * Fixed: result = (a * b) >> abs(scale) */
            uint32_t mul = Emit_Temp(cg);
            Emit(cg, "  %%t%u = mul i64 %%t%u, %%t%u\n", mul, left, right);
            if (scale < 0) {
                /* Negative scale = right shift by |scale| */
                Emit(cg, "  %%t%u = ashr i64 %%t%u, %d\n", t, mul, -scale);
            } else if (scale > 0) {
                /* Positive scale = left shift (uncommon) */
                Emit(cg, "  %%t%u = shl i64 %%t%u, %d\n", t, mul, scale);
            } else {
                t = mul;
            }
            return t;
        } else {
            /* Fixed / Fixed: result = (a << abs(scale)) / b */
            uint32_t shifted = Emit_Temp(cg);
            if (scale < 0) {
                Emit(cg, "  %%t%u = shl i64 %%t%u, %d\n", shifted, left, -scale);
            } else if (scale > 0) {
                Emit(cg, "  %%t%u = ashr i64 %%t%u, %d\n", shifted, left, scale);
            } else {
                shifted = left;
            }
            Emit(cg, "  %%t%u = sdiv i64 %%t%u, %%t%u\n", t, shifted, right);
            return t;
        }
    }

    switch (node->binary.op) {
        case TK_PLUS:  op = is_float ? "fadd" : "add"; break;
        case TK_MINUS: op = is_float ? "fsub" : "sub"; break;
        case TK_STAR:  op = is_float ? "fmul" : "mul"; break;
        case TK_SLASH: op = is_float ? "fdiv" : "sdiv"; break;
        case TK_MOD:   op = "srem"; break;
        case TK_REM:   op = "srem"; break;

        case TK_EXPON:
            /* Exponentiation: base ** exponent
             * For floating-point: use llvm.pow intrinsic
             * For integer: use __ada_integer_pow */
            {
                bool left_is_float = left_type && (left_type->kind == TYPE_FLOAT ||
                                                    left_type->kind == TYPE_UNIVERSAL_REAL);
                if (left_is_float) {
                    /* Float ** Integer: use pow intrinsic with converted exponent */
                    uint32_t exp_float = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = sitofp i64 %%t%u to double\n", exp_float, right);
                    Emit(cg, "  %%t%u = call double @llvm.pow.f64(double %%t%u, double %%t%u)\n",
                         t, left, exp_float);
                } else {
                    /* Integer ** Integer: use integer power function */
                    Emit(cg, "  %%t%u = call i64 @__ada_integer_pow(i64 %%t%u, i64 %%t%u)\n",
                         t, left, right);
                }
                return t;
            }

        case TK_AND:
        case TK_AND_THEN:
            /* Boolean AND: convert operands to i1 (may have been widened from load) */
            {
                const char *left_llvm = Expression_Llvm_Type(node->binary.left);
                const char *right_llvm = Expression_Llvm_Type(node->binary.right);
                left = Emit_Convert(cg, left, left_llvm, "i1");
                right = Emit_Convert(cg, right, right_llvm, "i1");
                Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", t, left, right);
            }
            return t;
        case TK_OR:
        case TK_OR_ELSE:
            /* Boolean OR: convert operands to i1 */
            {
                const char *left_llvm = Expression_Llvm_Type(node->binary.left);
                const char *right_llvm = Expression_Llvm_Type(node->binary.right);
                left = Emit_Convert(cg, left, left_llvm, "i1");
                right = Emit_Convert(cg, right, right_llvm, "i1");
                Emit(cg, "  %%t%u = or i1 %%t%u, %%t%u\n", t, left, right);
            }
            return t;
        case TK_XOR:
            /* Boolean XOR: convert operands to i1 */
            {
                const char *left_llvm = Expression_Llvm_Type(node->binary.left);
                const char *right_llvm = Expression_Llvm_Type(node->binary.right);
                left = Emit_Convert(cg, left, left_llvm, "i1");
                right = Emit_Convert(cg, right, right_llvm, "i1");
                Emit(cg, "  %%t%u = xor i1 %%t%u, %%t%u\n", t, left, right);
            }
            return t;

        case TK_EQ:
        case TK_NE:
        case TK_LT:
        case TK_LE:
        case TK_GT:
        case TK_GE:
            {
                /* Check operand types for typed comparisons */
                Type_Info *right_type = node->binary.right ? node->binary.right->type : NULL;
                bool left_is_float = left_type && (left_type->kind == TYPE_FLOAT ||
                                                   left_type->kind == TYPE_UNIVERSAL_REAL);
                bool right_is_float = right_type && (right_type->kind == TYPE_FLOAT ||
                                                     right_type->kind == TYPE_UNIVERSAL_REAL);
                bool left_is_bool = left_type && left_type->kind == TYPE_BOOLEAN;
                bool right_is_bool = right_type && right_type->kind == TYPE_BOOLEAN;
                bool left_is_access = left_type && left_type->kind == TYPE_ACCESS;
                bool right_is_access = right_type && right_type->kind == TYPE_ACCESS;

                /* Access types need to be converted to i64 for comparison
                 * (they are kept as ptr for dereference operations) */
                if (left_is_access) {
                    left = Emit_Convert(cg, left, "ptr", "i64");
                }
                if (right_is_access) {
                    right = Emit_Convert(cg, right, "ptr", "i64");
                }

                /* Determine float type based on left operand */
                const char *float_type = "double";
                if (left_type && (left_type->kind == TYPE_FLOAT ||
                                  left_type->kind == TYPE_UNIVERSAL_REAL)) {
                    float_type = Llvm_Float_Type((uint32_t)To_Bits(left_type->size));
                }

                /* Get the right operand's float type (if it is float) */
                const char *right_float_type = "double";
                if (right_type && right_type->kind == TYPE_FLOAT) {
                    right_float_type = Llvm_Float_Type((uint32_t)To_Bits(right_type->size));
                }
                /* UNIVERSAL_REAL always uses double (Generate_Real_Literal produces double) */

                /* Convert operands to same type if needed */
                if (left_is_float && !right_is_float) {
                    /* Convert right to float. If it's fixed-point, multiply by SMALL */
                    uint32_t conv = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = sitofp i64 %%t%u to %s\n", conv, right, float_type);
                    right = conv;
                    if (right_type && right_type->kind == TYPE_FIXED) {
                        /* Fixed-point: scale by SMALL to get actual value */
                        double small = right_type->fixed.small;
                        if (small <= 0) small = right_type->fixed.delta > 0 ? right_type->fixed.delta : 1.0;
                        uint64_t bits; memcpy(&bits, &small, sizeof(bits));
                        uint32_t small_t = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = fadd %s 0.0, 0x%016llX\n", small_t, float_type, (unsigned long long)bits);
                        uint32_t scaled = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = fmul %s %%t%u, %%t%u\n", scaled, float_type, right, small_t);
                        right = scaled;
                    }
                    right_is_float = true;
                } else if (!left_is_float && right_is_float) {
                    /* Convert right float to integer for fixed-point comparison.
                     * If left is fixed-point, divide by SMALL first */
                    if (left_type && left_type->kind == TYPE_FIXED) {
                        double small = left_type->fixed.small;
                        if (small <= 0) small = left_type->fixed.delta > 0 ? left_type->fixed.delta : 1.0;
                        uint64_t bits; memcpy(&bits, &small, sizeof(bits));
                        uint32_t small_t = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = fadd %s 0.0, 0x%016llX\n", small_t, right_float_type, (unsigned long long)bits);
                        uint32_t div_t = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = fdiv %s %%t%u, %%t%u\n", div_t, right_float_type, right, small_t);
                        right = div_t;
                    }
                    uint32_t conv = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = fptosi %s %%t%u to i64\n", conv, right_float_type, right);
                    right = conv;
                    right_is_float = false;
                } else if (left_is_float && right_is_float &&
                           strcmp(float_type, right_float_type) != 0) {
                    /* Both floats but different sizes - convert right to match left */
                    uint32_t conv = Emit_Temp(cg);
                    if (strcmp(float_type, "float") == 0) {
                        /* double -> float */
                        Emit(cg, "  %%t%u = fptrunc double %%t%u to float\n", conv, right);
                    } else {
                        /* float -> double */
                        Emit(cg, "  %%t%u = fpext float %%t%u to double\n", conv, right);
                    }
                    right = conv;
                }

                const char *cmp_op;
                char cmp_buf[32];
                if (left_is_float && right_is_float) {
                    const char *fcmp_op;
                    switch (node->binary.op) {
                        case TK_EQ: fcmp_op = "oeq"; break;
                        case TK_NE: fcmp_op = "une"; break;
                        case TK_LT: fcmp_op = "olt"; break;
                        case TK_LE: fcmp_op = "ole"; break;
                        case TK_GT: fcmp_op = "ogt"; break;
                        case TK_GE: fcmp_op = "oge"; break;
                        default: fcmp_op = "oeq"; break;
                    }
                    snprintf(cmp_buf, sizeof(cmp_buf), "fcmp %s %s", fcmp_op, float_type);
                    cmp_op = cmp_buf;
                } else if (left_is_bool && right_is_bool) {
                    /* Boolean comparisons use i64 since values may come from
                     * different sources (i1 functions extended to i64, or i64 fat ptrs).
                     * This avoids type mismatches in LLVM IR. */
                    switch (node->binary.op) {
                        case TK_EQ: cmp_op = "icmp eq i64"; break;
                        case TK_NE: cmp_op = "icmp ne i64"; break;
                        default: cmp_op = "icmp eq i64"; break;
                    }
                } else {
                    switch (node->binary.op) {
                        case TK_EQ: cmp_op = "icmp eq i64"; break;
                        case TK_NE: cmp_op = "icmp ne i64"; break;
                        case TK_LT: cmp_op = "icmp slt i64"; break;
                        case TK_LE: cmp_op = "icmp sle i64"; break;
                        case TK_GT: cmp_op = "icmp sgt i64"; break;
                        case TK_GE: cmp_op = "icmp sge i64"; break;
                        default: cmp_op = "icmp eq i64"; break;
                    }
                }
                Emit(cg, "  %%t%u = %s %%t%u, %%t%u\n", t, cmp_op, left, right);
                return t;
            }

        case TK_IN:
        case TK_NOT:  /* NOT IN is encoded as TK_NOT in binary op */
            {
                /* Membership test: X IN T or X NOT IN T
                 * For scalar types, check if X >= T'FIRST and X <= T'LAST
                 * For ranges, check if X >= low and X <= high */
                Type_Info *range_type = node->binary.right ? node->binary.right->type : NULL;

                /* Get the bounds to check against */
                int64_t low_val = 0, high_val = 0;
                bool have_bounds = false;

                if (node->binary.right && node->binary.right->kind == NK_RANGE) {
                    /* X IN low..high - use the range bounds */
                    /* For now, generate comparison with the right side value as both bounds check */
                    /* This will need enhancement for proper range handling */
                } else if (range_type) {
                    /* X IN T - use the type's bounds */
                    low_val = Type_Bound_Value(range_type->low_bound);
                    high_val = Type_Bound_Value(range_type->high_bound);
                    have_bounds = true;
                }

                if (have_bounds) {
                    /* Generate: (left >= low) AND (left <= high) */
                    uint32_t ge_low = Emit_Temp(cg);
                    uint32_t le_high = Emit_Temp(cg);
                    uint32_t in_range = Emit_Temp(cg);

                    Emit(cg, "  %%t%u = icmp sge i64 %%t%u, %lld\n", ge_low, left, (long long)low_val);
                    Emit(cg, "  %%t%u = icmp sle i64 %%t%u, %lld\n", le_high, left, (long long)high_val);
                    Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", in_range, ge_low, le_high);

                    if (node->binary.op == TK_NOT) {
                        /* NOT IN: negate the result */
                        Emit(cg, "  %%t%u = xor i1 %%t%u, 1\n", t, in_range);
                    } else {
                        t = in_range;
                    }
                } else {
                    /* Fallback: compare with right value (simple equality check) */
                    Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n", t, left, right);
                    if (node->binary.op == TK_NOT) {
                        uint32_t neg = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = xor i1 %%t%u, 1\n", neg, t);
                        t = neg;
                    }
                }
                return t;
            }

        default: op = "add"; break;
    }

    Emit(cg, "  %%t%u = %s %s %%t%u, %%t%u\n", t, op,
         is_float ? "double" : "i64", left, right);
    return t;
}

static uint32_t Generate_Unary_Op(Code_Generator *cg, Syntax_Node *node) {
    uint32_t operand = Generate_Expression(cg, node->unary.operand);
    uint32_t t = Emit_Temp(cg);

    switch (node->unary.op) {
        case TK_MINUS:
            Emit(cg, "  %%t%u = sub i64 0, %%t%u\n", t, operand);
            break;
        case TK_PLUS:
            return operand;
        case TK_NOT:
            {
                /* Convert operand to i1 if needed (loaded booleans are widened to i64) */
                const char *op_type = Expression_Llvm_Type(node->unary.operand);
                operand = Emit_Convert(cg, operand, op_type, "i1");
                Emit(cg, "  %%t%u = xor i1 %%t%u, 1\n", t, operand);
            }
            break;
        case TK_ABS:
            {
                uint32_t neg = Emit_Temp(cg);
                uint32_t cmp = Emit_Temp(cg);
                Emit(cg, "  %%t%u = sub i64 0, %%t%u\n", neg, operand);
                Emit(cg, "  %%t%u = icmp slt i64 %%t%u, 0\n", cmp, operand);
                Emit(cg, "  %%t%u = select i1 %%t%u, i64 %%t%u, i64 %%t%u\n",
                     t, cmp, neg, operand);
            }
            break;
        case TK_ALL:
            {
                /* .ALL dereference: operand is pointer, load the value */
                Type_Info *designated = node->type;  /* Set by resolution */
                if (designated && (designated->kind == TYPE_RECORD ||
                                  designated->kind == TYPE_ARRAY)) {
                    /* For composite types, pointer is the value */
                    return operand;
                }
                /* For scalar types, load the value from the pointer */
                const char *type_str = Type_To_Llvm(designated);
                Emit(cg, "  %%t%u = load %s, ptr %%t%u  ; .ALL dereference\n",
                     t, type_str, operand);
                t = Emit_Convert(cg, t, type_str, "i64");
            }
            break;
        default:
            return operand;
    }

    return t;
}

static uint32_t Generate_Apply(Code_Generator *cg, Syntax_Node *node) {
    Symbol *sym = node->apply.prefix->symbol;

    /* Follow rename chain to get actual target symbol for code generation.
     * Renames don't generate their own function body - they call the target. */
    while (sym && sym->renamed_object &&
           (sym->kind == SYMBOL_FUNCTION || sym->kind == SYMBOL_PROCEDURE)) {
        Symbol *target = (Symbol *)sym->renamed_object;
        if (target->kind == SYMBOL_FUNCTION || target->kind == SYMBOL_PROCEDURE) {
            sym = target;
        } else {
            break;
        }
    }

    /* Generic formal subprogram substitution: if calling a formal subprogram
     * inside a generic instantiation, substitute with the actual subprogram
     * or generate inline code for built-in operators.
     * For subprograms exported from generic packages, the actuals are on the
     * parent package instance, not on the subprogram itself. */
    Symbol *actuals_holder = cg->current_instance;
    if (actuals_holder && !actuals_holder->generic_actuals && actuals_holder->parent &&
        actuals_holder->parent->kind == SYMBOL_PACKAGE && actuals_holder->parent->generic_actuals) {
        actuals_holder = actuals_holder->parent;  /* Use package's generic_actuals */
    }
    if (sym && actuals_holder && actuals_holder->generic_actuals) {
        for (uint32_t i = 0; i < actuals_holder->generic_actual_count; i++) {
            if (Slice_Equal_Ignore_Case(sym->name,
                    actuals_holder->generic_actuals[i].formal_name)) {
                if (actuals_holder->generic_actuals[i].actual_subprogram) {
                    sym = actuals_holder->generic_actuals[i].actual_subprogram;
                } else if (actuals_holder->generic_actuals[i].builtin_operator) {
                    /* Built-in operator - generate inline */
                    Token_Kind op = cg->current_instance->generic_actuals[i].builtin_operator;
                    if (op == TK_AMPERSAND && node->apply.arguments.count == 2) {
                        /* String/array concatenation */
                        Syntax_Node *left_arg = node->apply.arguments.items[0];
                        Syntax_Node *right_arg = node->apply.arguments.items[1];
                        if (left_arg->kind == NK_ASSOCIATION)
                            left_arg = left_arg->association.expression;
                        if (right_arg->kind == NK_ASSOCIATION)
                            right_arg = right_arg->association.expression;

                        /* Get parameter types from formal subprogram symbol */
                        Type_Info *left_type = (sym && sym->parameter_count > 0) ?
                            sym->parameters[0].param_type : left_arg->type;
                        Type_Info *right_type = (sym && sym->parameter_count > 1) ?
                            sym->parameters[1].param_type : right_arg->type;

                        /* Substitute generic formal types with actual types */
                        if (actuals_holder && actuals_holder->generic_actuals) {
                            for (uint32_t k = 0; k < actuals_holder->generic_actual_count; k++) {
                                if (left_type && left_type->name.data &&
                                    Slice_Equal_Ignore_Case(left_type->name,
                                        actuals_holder->generic_actuals[k].formal_name) &&
                                    actuals_holder->generic_actuals[k].actual_type) {
                                    left_type = actuals_holder->generic_actuals[k].actual_type;
                                }
                                if (right_type && right_type->name.data &&
                                    Slice_Equal_Ignore_Case(right_type->name,
                                        actuals_holder->generic_actuals[k].formal_name) &&
                                    actuals_holder->generic_actuals[k].actual_type) {
                                    right_type = actuals_holder->generic_actuals[k].actual_type;
                                }
                            }
                        }

                        /* Check if first arg is CHARACTER (single byte) */
                        bool left_is_char = left_type && left_type->kind == TYPE_CHARACTER;
                        bool right_is_string = right_type &&
                            (right_type->kind == TYPE_STRING ||
                             (right_type->kind == TYPE_ARRAY && !right_type->array.is_constrained));

                        uint32_t left_val = Generate_Expression(cg, left_arg);
                        uint32_t right_val = Generate_Expression(cg, right_arg);

                        if (left_is_char && right_is_string) {
                            /* CHARACTER & STRING concatenation */
                            /* Wrap character in single-element fat pointer */
                            uint32_t char_alloc = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = alloca i8\n", char_alloc);
                            uint32_t char_trunc = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = trunc i64 %%t%u to i8\n", char_trunc, left_val);
                            Emit(cg, "  store i8 %%t%u, ptr %%t%u\n", char_trunc, char_alloc);
                            uint32_t one = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 0, 1\n", one);
                            uint32_t left_fat = Emit_Fat_Pointer_Dynamic(cg, char_alloc, one, one);

                            /* Extract right string bounds and data */
                            uint32_t right_data = Emit_Fat_Pointer_Data(cg, right_val);
                            uint32_t right_low = Emit_Fat_Pointer_Low(cg, right_val);
                            uint32_t right_high = Emit_Fat_Pointer_High(cg, right_val);

                            uint32_t right_len = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", right_len, right_high, right_low);
                            uint32_t right_len1 = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", right_len1, right_len);

                            /* Total length = 1 + right_len */
                            uint32_t total_len = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 1, %%t%u\n", total_len, right_len1);

                            /* Allocate result buffer */
                            uint32_t result_data = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = call ptr @__ada_sec_stack_alloc(i64 %%t%u)\n",
                                 result_data, total_len);

                            /* Store character at first position */
                            Emit(cg, "  store i8 %%t%u, ptr %%t%u\n", char_trunc, result_data);

                            /* Copy right string after character */
                            uint32_t dest = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 1\n", dest, result_data);
                            Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %%t%u, i1 false)\n",
                                 dest, right_data, right_len1);

                            /* Return fat pointer */
                            return Emit_Fat_Pointer_Dynamic(cg, result_data, one, total_len);
                        } else {
                            /* STRING & STRING concatenation */
                            uint32_t left_fat = left_val;
                            uint32_t right_fat = right_val;

                            uint32_t left_data = Emit_Fat_Pointer_Data(cg, left_fat);
                            uint32_t left_low = Emit_Fat_Pointer_Low(cg, left_fat);
                            uint32_t left_high = Emit_Fat_Pointer_High(cg, left_fat);

                            uint32_t right_data = Emit_Fat_Pointer_Data(cg, right_fat);
                            uint32_t right_low = Emit_Fat_Pointer_Low(cg, right_fat);
                            uint32_t right_high = Emit_Fat_Pointer_High(cg, right_fat);

                            uint32_t left_len = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", left_len, left_high, left_low);
                            uint32_t left_len1 = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", left_len1, left_len);

                            uint32_t right_len = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", right_len, right_high, right_low);
                            uint32_t right_len1 = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", right_len1, right_len);

                            uint32_t total_len = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 %%t%u, %%t%u\n", total_len, left_len1, right_len1);

                            uint32_t result_data = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = call ptr @__ada_sec_stack_alloc(i64 %%t%u)\n",
                                 result_data, total_len);

                            Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %%t%u, i1 false)\n",
                                 result_data, left_data, left_len1);

                            uint32_t right_dest = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n",
                                 right_dest, result_data, left_len1);

                            Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %%t%u, i1 false)\n",
                                 right_dest, right_data, right_len1);

                            uint32_t one = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 0, 1\n", one);
                            return Emit_Fat_Pointer_Dynamic(cg, result_data, one, total_len);
                        }
                    }
                }
                break;
            }
        }
    }

    if (sym && (sym->kind == SYMBOL_FUNCTION || sym->kind == SYMBOL_PROCEDURE)) {
        /* Function call - generate arguments
         * For OUT/IN OUT parameters, we need to pass the ADDRESS, not the value */
        uint32_t *args = Arena_Allocate(node->apply.arguments.count * sizeof(uint32_t));
        bool *is_byref = Arena_Allocate(node->apply.arguments.count * sizeof(bool));

        for (uint32_t i = 0; i < node->apply.arguments.count; i++) {
            Syntax_Node *arg_node = node->apply.arguments.items[i];
            Syntax_Node *arg = arg_node;  /* Actual expression to evaluate */
            uint32_t param_idx = i;  /* Index into sym->parameters[] */

            /* Handle named association: PARAM_NAME => expression */
            if (arg_node->kind == NK_ASSOCIATION) {
                arg = arg_node->association.expression;
                /* Look up formal parameter by name to get correct index */
                if (arg_node->association.choices.count > 0 && sym->parameters) {
                    Syntax_Node *name_node = arg_node->association.choices.items[0];
                    if (name_node && name_node->kind == NK_IDENTIFIER) {
                        String_Slice param_name = name_node->string_val.text;
                        for (uint32_t p = 0; p < sym->parameter_count; p++) {
                            if (Slice_Equal_Ignore_Case(sym->parameters[p].name, param_name)) {
                                param_idx = p;
                                break;
                            }
                        }
                    }
                }
            }

            /* For ALI-loaded symbols, parameters may be NULL - default to pass by value */
            bool byref = sym->parameters && param_idx < sym->parameter_count &&
                         Param_Is_By_Reference(sym->parameters[param_idx].mode);
            is_byref[i] = byref;

            if (byref) {
                /* OUT/IN OUT: pass address of variable */
                Parameter_Mode pmode = sym->parameters[param_idx].mode;
                Type_Info *formal_type = sym->parameters[param_idx].param_type;
                if (arg->kind == NK_IDENTIFIER && arg->symbol) {
                    args[i] = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr i8, ptr %%", args[i]);
                    Emit_Symbol_Name(cg, arg->symbol);
                    Emit(cg, ", i64 0  ; address for OUT/IN OUT\n");

                    /* IN OUT: check actual value fits formal constraint before call */
                    if (pmode == PARAM_IN_OUT && formal_type) {
                        uint32_t cur_val = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = load i64, ptr %%t%u\n", cur_val, args[i]);
                        Emit_Constraint_Check(cg, cur_val, formal_type);
                    }
                } else {
                    args[i] = Generate_Composite_Address(cg, arg);
                    if (pmode == PARAM_IN_OUT && formal_type) {
                        uint32_t cur_val = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = load i64, ptr %%t%u\n", cur_val, args[i]);
                        Emit_Constraint_Check(cg, cur_val, formal_type);
                    }
                }
            } else {
                args[i] = Generate_Expression(cg, arg);
                /* IN parameter: check constraint before call (RM 4.6) */
                if (sym->parameters && param_idx < sym->parameter_count &&
                    sym->parameters[param_idx].param_type) {
                    args[i] = Emit_Constraint_Check(cg, args[i],
                        sym->parameters[param_idx].param_type);
                    /* Convert to actual parameter type - fat pointers stay fat */
                    const char *param_type = Type_To_Llvm(sym->parameters[param_idx].param_type);
                    const char *arg_type = Expression_Llvm_Type(arg);
                    args[i] = Emit_Convert(cg, args[i], arg_type, param_type);
                }
            }
        }

        /* Check if calling a nested function of current scope */
        bool callee_is_nested = sym->parent &&
            (sym->parent->kind == SYMBOL_FUNCTION ||
             sym->parent->kind == SYMBOL_PROCEDURE);

        uint32_t t = Emit_Temp(cg);

        if (sym->return_type) {
            Emit(cg, "  %%t%u = call %s @", t, Type_To_Llvm(sym->return_type));
        } else {
            Emit(cg, "  call void @");
        }

        Emit_Symbol_Name(cg, sym);
        Emit(cg, "(");

        /* Pass frame pointer to nested functions:
         * - If current function IS the callee's parent: pass our %__frame_base
         * - If current function is a sibling (same parent): pass %__parent_frame
         * - Otherwise no frame pointer needed */
        if (callee_is_nested) {
            if (cg->current_function == sym->parent) {
                /* Calling child: pass our frame */
                Emit(cg, "ptr %%__frame_base");
                if (node->apply.arguments.count > 0) Emit(cg, ", ");
            } else if (cg->is_nested && cg->current_function &&
                       cg->current_function->parent == sym->parent) {
                /* Calling sibling (same parent): pass parent's frame */
                Emit(cg, "ptr %%__parent_frame");
                if (node->apply.arguments.count > 0) Emit(cg, ", ");
            }
        }

        for (uint32_t i = 0; i < node->apply.arguments.count; i++) {
            if (i > 0) Emit(cg, ", ");
            if (is_byref[i]) {
                /* OUT/IN OUT: pass as pointer */
                Emit(cg, "ptr %%t%u", args[i]);
            } else {
                const char *param_type = (sym->parameters && i < sym->parameter_count &&
                                          sym->parameters[i].param_type)
                    ? Type_To_Llvm(sym->parameters[i].param_type) : "i64";
                Emit(cg, "%s %%t%u", param_type, args[i]);
            }
        }

        Emit(cg, ")\n");

        /* OUT/IN OUT: check returned value fits actual's constraint (RM 6.2) */
        for (uint32_t i = 0; i < node->apply.arguments.count; i++) {
            if (!is_byref[i]) continue;
            Syntax_Node *arg_node = node->apply.arguments.items[i];
            Syntax_Node *arg = (arg_node->kind == NK_ASSOCIATION) ?
                arg_node->association.expression : arg_node;
            Type_Info *actual_type = arg->type;  /* Actual variable's subtype */
            if (!actual_type) continue;
            uint32_t ret_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load i64, ptr %%t%u  ; OUT/INOUT result\n", ret_val, args[i]);
            Emit_Constraint_Check(cg, ret_val, actual_type);
        }

        /* Widen return value to i64 for computation */
        if (sym->return_type) {
            t = Emit_Convert(cg, t, Type_To_Llvm(sym->return_type), "i64");
            return t;
        }
        return 0;
    }

    /* Entry call (task rendezvous) */
    if (sym && sym->kind == SYMBOL_ENTRY) {
        /* Entry call: pack parameters, call entry, wait for accept completion */
        Emit(cg, "  ; Entry call: %.*s\n",
             (int)sym->name.length, sym->name.data);

        /* Check if this is an entry family - first argument is family index, not a parameter */
        bool is_entry_family = sym->declaration && sym->declaration->kind == NK_ENTRY_DECL &&
                               sym->declaration->entry_decl.index_constraints.count > 0;
        uint32_t family_idx_temp = 0;
        uint32_t first_param_idx = 0;  /* Index of first actual parameter in arguments */

        if (is_entry_family && node->apply.arguments.count > 0) {
            /* First argument is the family index */
            family_idx_temp = Generate_Expression(cg, node->apply.arguments.items[0]);
            first_param_idx = 1;  /* Skip family index when processing parameters */
        }

        /* Allocate parameter block (excluding family index for entry families) */
        uint32_t param_count = node->apply.arguments.count - first_param_idx;
        uint32_t param_block = Emit_Temp(cg);
        if (param_count > 0) {
            Emit(cg, "  %%t%u = alloca [%u x i64]  ; entry call parameters\n",
                 param_block, param_count);
        } else {
            Emit(cg, "  %%t%u = inttoptr i64 0 to ptr  ; no parameters\n", param_block);
        }

        /* Store arguments into parameter block (skip family index for entry families) */
        for (uint32_t i = first_param_idx; i < node->apply.arguments.count; i++) {
            uint32_t arg_val = Generate_Expression(cg, node->apply.arguments.items[i]);
            uint32_t arg_ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr [%u x i64], ptr %%t%u, i64 0, i64 %u\n",
                 arg_ptr, param_count, param_block, i - first_param_idx);
            Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", arg_val, arg_ptr);
        }

        /* Get task object (from prefix if it's a selected component like Task_Obj.Entry) */
        uint32_t task_ptr = 0;
        Syntax_Node *prefix = node->apply.prefix;
        if (prefix->kind == NK_SELECTED && prefix->selected.prefix->symbol) {
            Symbol *task_sym = prefix->selected.prefix->symbol;
            task_ptr = Emit_Temp(cg);
            /* Check for uplevel access (task variable in outer scope) */
            Symbol *var_owner = task_sym->defining_scope
                               ? task_sym->defining_scope->owner : NULL;
            bool is_uplevel = cg->current_function && var_owner &&
                              var_owner != cg->current_function &&
                              var_owner != cg->current_function->generic_template;
            if (is_uplevel && cg->is_nested) {
                Emit(cg, "  %%t%u = getelementptr i8, ptr %%__frame.", task_ptr);
                Emit_Symbol_Name(cg, task_sym);
                Emit(cg, ", i64 0  ; uplevel task object\n");
            } else {
                Emit(cg, "  %%t%u = getelementptr i8, ptr ", task_ptr);
                Emit_Symbol_Ref(cg, task_sym);
                Emit(cg, ", i64 0  ; task object\n");
            }
        } else {
            task_ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = inttoptr i64 0 to ptr  ; current task\n", task_ptr);
        }

        /* Get entry index - combine base index with family index for entry families.
         * Formula: entry_idx = base * 1000 + family_arg (matching accept side) */
        uint32_t entry_idx = Emit_Temp(cg);
        if (is_entry_family && family_idx_temp) {
            Emit(cg, "  %%t%u = add i64 %u, %%t%u  ; entry index (base + family)\n",
                 entry_idx, sym->entry_index * 1000, family_idx_temp);
        } else {
            Emit(cg, "  %%t%u = add i64 0, %u  ; entry index (simple entry)\n",
                 entry_idx, sym->entry_index * 1000);
        }

        /* Call runtime entry call function - blocks until rendezvous completes */
        Emit(cg, "  call void @__ada_entry_call(ptr %%t%u, i64 %%t%u, ptr %%t%u)\n",
             task_ptr, entry_idx, param_block);

        return 0;
    }

    /* Array indexing (with implicit access dereference per RM 4.1(3)) */
    Type_Info *prefix_type = node->apply.prefix->type;
    Type_Info *array_type = prefix_type;  /* Type to use for indexing */
    bool implicit_deref = false;

    /* Handle implicit dereference: A(I) where A is access-to-array */
    if (prefix_type && prefix_type->kind == TYPE_ACCESS && prefix_type->access.designated_type) {
        array_type = prefix_type->access.designated_type;
        implicit_deref = true;
    }

    if (Type_Is_Array_Like(array_type)) {
        Symbol *array_sym = node->apply.prefix->symbol;
        uint32_t base;
        uint32_t low_bound_val = 0;
        bool has_dynamic_low = false;

        /* Check if this is an uplevel (outer scope) array access */
        Symbol *var_owner = array_sym && array_sym->defining_scope
                           ? array_sym->defining_scope->owner : NULL;
        bool is_uplevel = array_sym && cg->current_function && var_owner &&
                          var_owner != cg->current_function &&
                          var_owner != cg->current_function->generic_template;

        if (implicit_deref) {
            /* Load the access value (pointer to array) then use as base */
            if (array_sym) {
                base = Emit_Temp(cg);
                Emit(cg, "  %%t%u = load ptr, ptr ", base);
                if (is_uplevel && cg->is_nested) {
                    Emit(cg, "%%__frame.");
                    Emit_Symbol_Name(cg, array_sym);
                } else {
                    Emit_Symbol_Ref(cg, array_sym);
                }
                Emit(cg, "  ; implicit dereference of access\n");
            } else {
                base = Generate_Expression(cg, node->apply.prefix);
            }
        }
        /* Check if unconstrained array OR constrained array with dynamic bounds
         * needing fat pointer handling. Both are stored as fat pointers. */
        else if ((Type_Is_Unconstrained_Array(array_type) || Type_Has_Dynamic_Bounds(array_type)) &&
            array_sym && (array_sym->kind == SYMBOL_PARAMETER || array_sym->kind == SYMBOL_VARIABLE ||
                          array_sym->kind == SYMBOL_CONSTANT)) {
            /* Load fat pointer and extract data pointer and low bound */
            Emit(cg, "  ; DEBUG ARRAY INDEX: using fat pointer path (unconstrained=%d, dynamic=%d)\n",
                 Type_Is_Unconstrained_Array(array_type), Type_Has_Dynamic_Bounds(array_type));
            uint32_t fat = Emit_Load_Fat_Pointer(cg, array_sym);
            base = Emit_Fat_Pointer_Data(cg, fat);
            low_bound_val = Emit_Fat_Pointer_Low(cg, fat);
            has_dynamic_low = true;
        } else if (array_sym) {
            /* Constrained array - get direct pointer to data */
            Emit(cg, "  ; DEBUG ARRAY INDEX: using constrained path (sym_kind=%d)\n", array_sym->kind);
            base = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr i8, ptr ", base);
            if (is_uplevel && cg->is_nested) {
                Emit(cg, "%%__frame.");
                Emit_Symbol_Name(cg, array_sym);
            } else {
                Emit_Symbol_Ref(cg, array_sym);
            }
            Emit(cg, ", i64 0\n");
        } else {
            /* Complex prefix (e.g., array field of indexed record) */
            uint32_t prefix_val = Generate_Expression(cg, node->apply.prefix);

            /* If the array is unconstrained or has dynamic bounds, the expression
             * returns a fat pointer struct { ptr, { i64, i64 } }. We need to extract
             * the data pointer and low bound from it. */
            if (Type_Is_Unconstrained_Array(array_type) || Type_Has_Dynamic_Bounds(array_type)) {
                /* Extract data pointer from fat pointer value */
                base = Emit_Fat_Pointer_Data(cg, prefix_val);
                low_bound_val = Emit_Fat_Pointer_Low(cg, prefix_val);
                has_dynamic_low = true;
            } else {
                /* Constrained array - the expression result is the base pointer */
                base = prefix_val;
            }
        }

        /* Check for slice: ARR(low..high) */
        Syntax_Node *arg0 = node->apply.arguments.items[0];
        if (arg0->kind == NK_RANGE) {
            /* Array slice - return fat pointer {ptr, {low, high}}
             * Slice bounds are absolute indices into the source array.
             * The fat pointer stores: {data_ptr_at_slice_start, {slice_low, slice_high}} */
            Type_Info *elem_type = array_type->array.element_type;
            uint32_t elem_size = elem_type ? elem_type->size : 1;
            if (elem_size == 0) elem_size = 1;

            /* Generate slice bounds (these are the logical bounds of the slice) */
            uint32_t slice_low = Generate_Expression(cg, arg0->range.low);
            uint32_t slice_high = Generate_Expression(cg, arg0->range.high);

            /* Compute zero-based offset for slice start
             * offset = (slice_low - array_low_bound) * elem_size */
            uint32_t offset;
            int64_t array_low = Array_Low_Bound(array_type);
            if (has_dynamic_low) {
                offset = Emit_Temp(cg);
                Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", offset, slice_low, low_bound_val);
            } else if (array_low != 0) {
                offset = Emit_Temp(cg);
                Emit(cg, "  %%t%u = sub i64 %%t%u, %lld\n", offset, slice_low, (long long)array_low);
            } else {
                offset = slice_low;
            }

            /* Compute data pointer at slice start */
            uint32_t data_ptr = Emit_Temp(cg);
            if (elem_size == 1) {
                Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n",
                     data_ptr, base, offset);
            } else {
                uint32_t byte_off = Emit_Temp(cg);
                Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_off, offset, elem_size);
                Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n",
                     data_ptr, base, byte_off);
            }

            /* Build fat pointer with slice bounds using helper */
            return Emit_Fat_Pointer_Dynamic(cg, data_ptr, slice_low, slice_high);
        }

        /* Generate index expression */
        uint32_t idx = Generate_Expression(cg, arg0);

        /* Adjust for array low bound (Ada arrays can start at any index) */
        if (has_dynamic_low) {
            /* Dynamic low bound from fat pointer */
            uint32_t adj = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u  ; adjust for dynamic low bound\n",
                 adj, idx, low_bound_val);
            idx = adj;
        } else {
            int64_t low_bound = Array_Low_Bound(array_type);
            if (low_bound != 0) {
                uint32_t adj = Emit_Temp(cg);
                Emit(cg, "  %%t%u = sub i64 %%t%u, %lld\n", adj, idx, (long long)low_bound);
                idx = adj;
            }
        }

        /* Get pointer to element and load */
        Type_Info *elem_type_info = array_type->array.element_type;
        bool elem_is_composite = elem_type_info &&
            (elem_type_info->kind == TYPE_RECORD ||
             (elem_type_info->kind == TYPE_ARRAY && elem_type_info->array.is_constrained));
        uint32_t elem_size = elem_type_info ? elem_type_info->size : 8;
        const char *elem_type = Type_To_Llvm(elem_type_info);
        uint32_t ptr = Emit_Temp(cg);
        uint32_t t;

        if (elem_is_composite && elem_size > 0) {
            /* Composite element - use byte array for getelementptr */
            Emit(cg, "  %%t%u = getelementptr [%u x i8], ptr %%t%u, i64 %%t%u\n",
                 ptr, elem_size, base, idx);
            /* Return pointer to composite element (don't load) */
            return ptr;
        } else {
            t = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i64 %%t%u\n",
                 ptr, elem_type, base, idx);
            Emit(cg, "  %%t%u = load %s, ptr %%t%u\n", t, elem_type, ptr);
            /* Widen to i64 for computation */
            t = Emit_Convert(cg, t, elem_type, "i64");
            return t;
        }
    }

    /* Type conversion: Type_Name(Expression) */
    if (sym && (sym->kind == SYMBOL_TYPE || sym->kind == SYMBOL_SUBTYPE)) {
        /* For scalar types, type conversion evaluates the expression and converts
         * to the target type. This handles INTEGER→FLOAT, FLOAT→INTEGER, etc. */
        if (node->apply.arguments.count == 1) {
            Syntax_Node *arg = node->apply.arguments.items[0];
            uint32_t result = Generate_Expression(cg, arg);

            /* Get source and destination types */
            Type_Info *src_type = arg->type;
            Type_Info *dst_type = sym->type;

            if (src_type && dst_type && src_type != dst_type) {
                /* Types differ - need to convert */
                const char *src_llvm = Expression_Llvm_Type(arg);
                const char *dst_llvm = Type_To_Llvm(dst_type);

                if (strcmp(src_llvm, dst_llvm) != 0) {
                    result = Emit_Convert(cg, result, src_llvm, dst_llvm);
                }
            }
            return result;
        }
    }

    return 0;
}

static uint32_t Generate_Selected(Code_Generator *cg, Syntax_Node *node) {
    /* Generate code for A.B (selected component) */
    Type_Info *prefix_type = node->selected.prefix->type;
    Type_Info *record_type = prefix_type;
    bool implicit_deref = false;

    /* Handle explicit .ALL dereference (RM 4.1) */
    if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
        Slice_Equal_Ignore_Case(node->selected.selector, S("ALL"))) {
        Type_Info *designated = prefix_type->access.designated_type;
        Symbol *access_sym = node->selected.prefix->symbol;

        /* Load the pointer */
        uint32_t ptr;
        if (access_sym) {
            ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load ptr, ptr ", ptr);
            Emit_Symbol_Ref(cg, access_sym);
            Emit(cg, "  ; explicit .ALL dereference\n");
        } else {
            ptr = Generate_Expression(cg, node->selected.prefix);
        }

        /* For composite types (records, arrays), return pointer */
        if (designated && (designated->kind == TYPE_RECORD ||
                          designated->kind == TYPE_ARRAY)) {
            return ptr;
        }

        /* For scalar types, load the value */
        const char *type_str = Type_To_Llvm(designated);
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = load %s, ptr %%t%u  ; load via .ALL\n", t, type_str, ptr);
        t = Emit_Convert(cg, t, type_str, "i64");
        return t;
    }

    /* Handle implicit dereference: R.C where R is access-to-record (RM 4.1(3)) */
    if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
        prefix_type->access.designated_type &&
        prefix_type->access.designated_type->kind == TYPE_RECORD) {
        record_type = prefix_type->access.designated_type;
        implicit_deref = true;
    }

    if (!record_type || record_type->kind != TYPE_RECORD) {
        /* Package-qualified name - use the resolved symbol via Generate_Identifier
         * This handles named numbers, constants, variables, and literals properly */
        Symbol *sym = node->symbol;
        if (sym) {
            /* Create a temporary identifier node to reuse Generate_Identifier logic */
            Syntax_Node tmp_id = {.kind = NK_IDENTIFIER, .symbol = sym, .location = node->location};
            tmp_id.type = sym->type;
            return Generate_Identifier(cg, &tmp_id);
        }
        return 0;
    }

    /* Record field access - find component by name */
    uint32_t byte_offset = 0;
    Type_Info *field_type = NULL;
    for (uint32_t i = 0; i < record_type->record.component_count; i++) {
        if (Slice_Equal_Ignore_Case(
                record_type->record.components[i].name, node->selected.selector)) {
            byte_offset = record_type->record.components[i].byte_offset;
            field_type = record_type->record.components[i].component_type;
            break;
        }
    }

    /* Get base address of record variable */
    Symbol *record_sym = node->selected.prefix->symbol;
    const char *field_llvm_type = Type_To_Llvm(field_type);

    if (implicit_deref) {
        /* Access-to-record: load pointer then compute field offset */
        uint32_t base_ptr;
        if (record_sym) {
            base_ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load ptr, ptr ", base_ptr);
            Emit_Symbol_Ref(cg, record_sym);
            Emit(cg, "  ; implicit dereference of access-to-record\n");
        } else {
            base_ptr = Generate_Expression(cg, node->selected.prefix);
        }
        uint32_t ptr = Emit_Temp(cg);
        Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n",
             ptr, base_ptr, byte_offset);

        /* For composite components, handle based on constrained vs unconstrained */
        if (field_type && (field_type->kind == TYPE_RECORD ||
                           field_type->kind == TYPE_ARRAY)) {
            /* Unconstrained or dynamic-bound arrays are stored as fat pointers */
            if (field_type->kind == TYPE_ARRAY &&
                (!field_type->array.is_constrained || Type_Has_Dynamic_Bounds(field_type))) {
                uint32_t fat = Emit_Temp(cg);
                Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u  ; load array field with dynamic bounds\n", fat, ptr);
                return fat;
            }
            return ptr;
        }
        /* STRING fields (unconstrained or dynamic-bound) - load fat pointer */
        if (field_type && field_type->kind == TYPE_STRING) {
            uint32_t fat = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u  ; load STRING field\n", fat, ptr);
            return fat;
        }
        /* For access-type components, load ptr without converting to i64 */
        if (field_type && field_type->kind == TYPE_ACCESS) {
            uint32_t t = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load ptr, ptr %%t%u\n", t, ptr);
            return t;
        }
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = load %s, ptr %%t%u\n", t, field_llvm_type, ptr);
        t = Emit_Convert(cg, t, field_llvm_type, "i64");
        return t;
    }

    if (!record_sym) {
        /* Handle nested selection (e.g., A.B.C) by generating prefix expression */
        uint32_t base_ptr = Generate_Expression(cg, node->selected.prefix);
        uint32_t ptr = Emit_Temp(cg);
        Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n",
             ptr, base_ptr, byte_offset);

        /* For composite components, handle based on constrained vs unconstrained */
        if (field_type && (field_type->kind == TYPE_RECORD ||
                           field_type->kind == TYPE_ARRAY)) {
            /* Unconstrained or dynamic-bound arrays are stored as fat pointers */
            if (field_type->kind == TYPE_ARRAY &&
                (!field_type->array.is_constrained || Type_Has_Dynamic_Bounds(field_type))) {
                uint32_t fat = Emit_Temp(cg);
                Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u  ; load array field with dynamic bounds\n", fat, ptr);
                return fat;
            }
            return ptr;
        }
        /* STRING fields (unconstrained or dynamic-bound) - load fat pointer */
        if (field_type && field_type->kind == TYPE_STRING) {
            uint32_t fat = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u  ; load STRING field\n", fat, ptr);
            return fat;
        }
        /* For access-type components, load ptr without converting to i64 */
        if (field_type && field_type->kind == TYPE_ACCESS) {
            uint32_t t = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load ptr, ptr %%t%u\n", t, ptr);
            return t;
        }
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = load %s, ptr %%t%u\n", t, field_llvm_type, ptr);
        /* Widen to i64 for computation if narrower type */
        t = Emit_Convert(cg, t, field_llvm_type, "i64");
        return t;
    }

    /* Calculate address of field */
    uint32_t ptr = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr i8, ptr ", ptr);
    Emit_Symbol_Ref(cg, record_sym);
    Emit(cg, ", i64 %u\n", byte_offset);

    /* For composite components, handle based on constrained vs unconstrained */
    if (field_type && (field_type->kind == TYPE_RECORD ||
                       field_type->kind == TYPE_ARRAY)) {
        /* Unconstrained or dynamic-bound arrays are stored as fat pointers */
        if (field_type->kind == TYPE_ARRAY &&
            (!field_type->array.is_constrained || Type_Has_Dynamic_Bounds(field_type))) {
            uint32_t fat = Emit_Temp(cg);
            Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u  ; load array field with dynamic bounds\n", fat, ptr);
            return fat;
        }
        return ptr;
    }
    /* STRING fields (unconstrained or dynamic-bound) - load fat pointer */
    if (field_type && field_type->kind == TYPE_STRING) {
        uint32_t fat = Emit_Temp(cg);
        Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u  ; load STRING field\n", fat, ptr);
        return fat;
    }
    /* For access-type components, load ptr without converting to i64 */
    if (field_type && field_type->kind == TYPE_ACCESS) {
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = load ptr, ptr %%t%u\n", t, ptr);
        return t;
    }
    uint32_t t = Emit_Temp(cg);
    Emit(cg, "  %%t%u = load %s, ptr %%t%u\n", t, field_llvm_type, ptr);
    /* Widen to i64 for computation if narrower type */
    t = Emit_Convert(cg, t, field_llvm_type, "i64");

    return t;
}

/* Check if a type bound can be evaluated at compile time.
 * Returns true if the bound is compile-time known, false otherwise.
 * Per GNAT's sem_eval.ads, compile-time known is broader than static -
 * it includes values that can be determined at compile time even if
 * they technically involve non-static expressions. */
static bool Type_Bound_Is_Compile_Time_Known(Type_Bound b) {
    if (b.kind == BOUND_INTEGER || b.kind == BOUND_FLOAT) return true;
    if (b.kind == BOUND_EXPR && b.expr) {
        double val = Eval_Const_Numeric(b.expr);
        return val == val;  /* Returns true if not NaN */
    }
    return false;
}

static int64_t Type_Bound_Value(Type_Bound b) {
    if (b.kind == BOUND_INTEGER) return b.int_value;
    if (b.kind == BOUND_FLOAT) return (int64_t)b.float_value;
    if (b.kind == BOUND_EXPR && b.expr) {
        /* Try to evaluate expression bound at compile time */
        double val = Eval_Const_Numeric(b.expr);
        if (val == val) return (int64_t)val;  /* Not NaN */
    }
    return 0;  /* Handle other bound kinds as needed */
}

static double Type_Bound_Float_Value(Type_Bound b) {
    if (b.kind == BOUND_FLOAT) return b.float_value;
    if (b.kind == BOUND_INTEGER) return (double)b.int_value;
    if (b.kind == BOUND_EXPR && b.expr) {
        /* Try to evaluate expression bound at compile time */
        double val = Eval_Const_Numeric(b.expr);
        if (val == val) return val;  /* Not NaN */
    }
    return 0.0;
}

/* Get array element count for constrained arrays, 0 for unconstrained */
static int64_t Array_Element_Count(Type_Info *t) {
    if (!t || t->kind != TYPE_ARRAY || !t->array.is_constrained)
        return 0;
    if (t->array.index_count == 0)
        return 0;
    int64_t low = Type_Bound_Value(t->array.indices[0].low_bound);
    int64_t high = Type_Bound_Value(t->array.indices[0].high_bound);
    return high - low + 1;
}

/* Get array low bound for index adjustment */
static int64_t Array_Low_Bound(Type_Info *t) {
    if (!t || t->kind != TYPE_ARRAY || t->array.index_count == 0)
        return 0;
    return Type_Bound_Value(t->array.indices[0].low_bound);
}

/* Get dimension index from attribute argument (1-based, default 1) */
static uint32_t Get_Dimension_Index(Syntax_Node *arg) {
    if (!arg) return 0;  /* Default to first dimension */
    if (arg->kind == NK_INTEGER) return (uint32_t)(arg->integer_lit.value - 1);
    return 0;
}

static uint32_t Generate_Attribute(Code_Generator *cg, Syntax_Node *node) {
    /* Generate code for X'FIRST, X'LAST, X'LENGTH, X'SIZE, X'ADDRESS, etc. */
    Type_Info *prefix_type = node->attribute.prefix->type;
    String_Slice attr = node->attribute.name;
    uint32_t t = Emit_Temp(cg);
    Syntax_Node *first_arg = node->attribute.arguments.count > 0
                           ? node->attribute.arguments.items[0] : NULL;
    uint32_t dim = Get_Dimension_Index(first_arg);

    /* ─────────────────────────────────────────────────────────────────────
     * Resolve generic formal types to their actual types
     * When inside a generic instance, T'ATTR should use the actual type
     * passed for formal type T, not the placeholder formal type.
     * ───────────────────────────────────────────────────────────────────── */

    if (prefix_type && cg->current_instance) {
        /* Only substitute if prefix_type is the formal type itself, not a subtype.
         * Constrained subtypes (like NOCHAR IS CH RANGE 1..0) must keep their
         * own bounds, not be substituted with the actual type's bounds.
         * A type with base_type set is a constrained subtype of the formal. */
        bool is_constrained_subtype = prefix_type->base_type != NULL;
        if (!is_constrained_subtype) {
            Symbol *actuals_holder = cg->current_instance;
            /* If current instance is a subprogram within a package, use the package's actuals */
            if (actuals_holder && !actuals_holder->generic_actuals && actuals_holder->parent &&
                actuals_holder->parent->kind == SYMBOL_PACKAGE && actuals_holder->parent->generic_actuals) {
                actuals_holder = actuals_holder->parent;
            }
            if (actuals_holder && actuals_holder->generic_actuals) {
                /* Look up prefix type name in generic actuals */
                for (uint32_t i = 0; i < actuals_holder->generic_actual_count; i++) {
                    if (actuals_holder->generic_actuals[i].actual_type &&
                        Slice_Equal_Ignore_Case(prefix_type->name,
                            actuals_holder->generic_actuals[i].formal_name)) {
                        prefix_type = actuals_holder->generic_actuals[i].actual_type;
                        break;
                    }
                }
            }
        }
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Implicit dereference for access types (RM 4.1(3))
     * A1'FIRST where A1 is access-to-array is equivalent to A1.ALL'FIRST
     * ───────────────────────────────────────────────────────────────────── */

    if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
        prefix_type->access.designated_type) {
        prefix_type = prefix_type->access.designated_type;
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Check if prefix is an unconstrained array that needs runtime bounds
     * Unconstrained arrays (STRING, unconstrained ARRAY) are passed as
     * fat pointers { ptr, { i64, i64 } } containing data pointer and bounds.
     * ───────────────────────────────────────────────────────────────────── */

    bool needs_runtime_bounds = false;
    Symbol *prefix_sym = node->attribute.prefix->symbol;

    /* If prefix type is NULL but we have a symbol (e.g., package.type'FIRST),
     * get the type from the symbol instead */
    if (!prefix_type && prefix_sym && prefix_sym->type) {
        prefix_type = prefix_sym->type;
    }
    /* Check for unconstrained arrays OR constrained arrays with dynamic bounds.
     * Both are represented as fat pointers { ptr, { i64, i64 } } at runtime.
     * Note: This applies even when prefix_sym is NULL (complex expression prefix). */
    if (prefix_type &&
        (Type_Is_Unconstrained_Array(prefix_type) || Type_Has_Dynamic_Bounds(prefix_type))) {
        /* For variables/parameters/constants with a symbol, or for complex expressions */
        if (!prefix_sym ||
            prefix_sym->kind == SYMBOL_PARAMETER || prefix_sym->kind == SYMBOL_VARIABLE ||
            prefix_sym->kind == SYMBOL_CONSTANT) {
            needs_runtime_bounds = true;
        }
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Array/Scalar Bound Attributes
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("FIRST"))) {
        if (Type_Is_Array_Like(prefix_type)) {
            if (needs_runtime_bounds && dim == 0) {
                uint32_t fat;
                if (prefix_sym) {
                    fat = Emit_Load_Fat_Pointer(cg, prefix_sym);
                } else {
                    /* Complex prefix expression - generate it to get fat pointer value */
                    fat = Generate_Expression(cg, node->attribute.prefix);
                }
                return Emit_Fat_Pointer_Low(cg, fat);
            } else if (dim < prefix_type->array.index_count) {
                Emit(cg, "  %%t%u = add i64 0, %lld  ; %.*s'FIRST(%u)\n", t,
                     (long long)Type_Bound_Value(prefix_type->array.indices[dim].low_bound),
                     (int)attr.length, attr.data, dim + 1);
            }
        } else if (prefix_type && prefix_type->kind != TYPE_FIXED &&
                   (prefix_type->kind == TYPE_FLOAT ||
                    prefix_type->kind == TYPE_UNIVERSAL_REAL ||
                    prefix_type->low_bound.kind == BOUND_FLOAT)) {
            /* Floating-point type - return double (not fixed-point) */
            Emit(cg, "  %%t%u = fadd double 0.0, %e  ; %.*s'FIRST\n", t,
                 Type_Bound_Float_Value(prefix_type->low_bound),
                 (int)attr.length, attr.data);
        } else if (prefix_type) {
            /* Scalar type - check if bound is compile-time known */
            if (Type_Bound_Is_Compile_Time_Known(prefix_type->low_bound)) {
                Emit(cg, "  %%t%u = add i64 0, %lld  ; %.*s'FIRST\n", t,
                     (long long)Type_Bound_Value(prefix_type->low_bound),
                     (int)attr.length, attr.data);
            } else {
                /* Generate runtime evaluation of bound expression */
                return Generate_Bound_Value(cg, prefix_type->low_bound);
            }
        } else {
            /* ??? Fallback: prefix_type is NULL - emit 0 */
            Emit(cg, "  %%t%u = add i64 0, 0  ; %.*s'FIRST (no type)\n", t,
                 (int)attr.length, attr.data);
        }
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("LAST"))) {
        if (Type_Is_Array_Like(prefix_type)) {
            if (needs_runtime_bounds && dim == 0) {
                uint32_t fat;
                if (prefix_sym) {
                    fat = Emit_Load_Fat_Pointer(cg, prefix_sym);
                } else {
                    /* Complex prefix expression - generate it to get fat pointer value */
                    fat = Generate_Expression(cg, node->attribute.prefix);
                }
                return Emit_Fat_Pointer_High(cg, fat);
            } else if (dim < prefix_type->array.index_count) {
                Emit(cg, "  %%t%u = add i64 0, %lld  ; %.*s'LAST(%u)\n", t,
                     (long long)Type_Bound_Value(prefix_type->array.indices[dim].high_bound),
                     (int)attr.length, attr.data, dim + 1);
            }
        } else if (prefix_type && prefix_type->kind != TYPE_FIXED &&
                   (prefix_type->kind == TYPE_FLOAT ||
                    prefix_type->kind == TYPE_UNIVERSAL_REAL ||
                    prefix_type->high_bound.kind == BOUND_FLOAT)) {
            /* Floating-point type - return double (not fixed-point) */
            Emit(cg, "  %%t%u = fadd double 0.0, %e  ; %.*s'LAST\n", t,
                 Type_Bound_Float_Value(prefix_type->high_bound),
                 (int)attr.length, attr.data);
        } else if (prefix_type) {
            /* Scalar type - check if bound is compile-time known */
            if (Type_Bound_Is_Compile_Time_Known(prefix_type->high_bound)) {
                Emit(cg, "  %%t%u = add i64 0, %lld  ; %.*s'LAST\n", t,
                     (long long)Type_Bound_Value(prefix_type->high_bound),
                     (int)attr.length, attr.data);
            } else {
                /* Generate runtime evaluation of bound expression */
                return Generate_Bound_Value(cg, prefix_type->high_bound);
            }
        } else {
            /* ??? Fallback: prefix_type is NULL - emit 0 */
            Emit(cg, "  %%t%u = add i64 0, 0  ; %.*s'LAST (no type)\n", t,
                 (int)attr.length, attr.data);
        }
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("LENGTH"))) {
        if (Type_Is_Array_Like(prefix_type)) {
            if (needs_runtime_bounds && dim == 0) {
                uint32_t fat;
                if (prefix_sym) {
                    fat = Emit_Load_Fat_Pointer(cg, prefix_sym);
                } else {
                    /* Complex prefix expression - generate it to get fat pointer value */
                    fat = Generate_Expression(cg, node->attribute.prefix);
                }
                return Emit_Fat_Pointer_Length(cg, fat);
            } else if (dim < prefix_type->array.index_count) {
                int64_t low = Type_Bound_Value(prefix_type->array.indices[dim].low_bound);
                int64_t high = Type_Bound_Value(prefix_type->array.indices[dim].high_bound);
                Emit(cg, "  %%t%u = add i64 0, %lld  ; 'LENGTH(%u)\n", t,
                     (long long)(high - low + 1), dim + 1);
            }
        }
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("RANGE"))) {
        /* Range attribute - for general expression contexts, return low bound.
         * For loops handle RANGE specially in Generate_For_Loop. */
        if (Type_Is_Array_Like(prefix_type)) {
            if (needs_runtime_bounds && dim == 0) {
                uint32_t fat;
                if (prefix_sym) {
                    fat = Emit_Load_Fat_Pointer(cg, prefix_sym);
                } else {
                    /* Complex prefix expression - generate it to get fat pointer value */
                    fat = Generate_Expression(cg, node->attribute.prefix);
                }
                return Emit_Fat_Pointer_Low(cg, fat);
            } else if (dim < prefix_type->array.index_count) {
                Emit(cg, "  %%t%u = add i64 0, %lld  ; 'RANGE(%u) low\n", t,
                     (long long)Type_Bound_Value(prefix_type->array.indices[dim].low_bound),
                     dim + 1);
            }
        }
        return t;
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Size and Representation Attributes
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("SIZE"))) {
        /* 'SIZE returns size in bits */
        Emit(cg, "  %%t%u = add i64 0, %lld  ; 'SIZE in bits\n", t,
             (long long)(prefix_type ? prefix_type->size * 8 : 0));
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("ALIGNMENT"))) {
        Emit(cg, "  %%t%u = add i64 0, %lld  ; 'ALIGNMENT\n", t,
             (long long)(prefix_type ? prefix_type->alignment : 8));
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("COMPONENT_SIZE"))) {
        if (prefix_type && prefix_type->kind == TYPE_ARRAY && prefix_type->array.element_type) {
            Emit(cg, "  %%t%u = add i64 0, %lld  ; 'COMPONENT_SIZE\n", t,
                 (long long)(prefix_type->array.element_type->size * 8));
        } else {
            Emit(cg, "  %%t%u = add i64 0, 0\n", t);
        }
        return t;
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Address Attribute
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("ADDRESS"))) {
        /* Generate address of prefix object */
        Symbol *sym = node->attribute.prefix->symbol;
        if (sym) {
            if (sym->kind == SYMBOL_LABEL) {
                /* Label address - use blockaddress for code location */
                if (sym->llvm_label_id == 0) {
                    sym->llvm_label_id = cg->label_id++;
                }
                Emit(cg, "  %%t%u = ptrtoint ptr blockaddress(@", t);
                Emit_Symbol_Name(cg, cg->current_function);
                Emit(cg, ", %%L%u) to i64  ; '%.*s'ADDRESS\n",
                     sym->llvm_label_id,
                     (int)sym->name.length, sym->name.data);
            } else if (sym->kind == SYMBOL_FUNCTION || sym->kind == SYMBOL_PROCEDURE) {
                /* Subprogram address - use function pointer directly */
                Emit(cg, "  %%t%u = ptrtoint ptr @", t);
                Emit_Symbol_Name(cg, sym);
                Emit(cg, " to i64  ; '%.*s'ADDRESS (subprogram)\n",
                     (int)sym->name.length, sym->name.data);
            } else if (sym->kind == SYMBOL_PACKAGE || sym->kind == SYMBOL_GENERIC) {
                /* Package/generic address - use a global marker */
                Emit(cg, "  %%t%u = ptrtoint ptr @__addr.", t);
                Emit_Symbol_Name(cg, sym);
                Emit(cg, " to i64  ; '%.*s'ADDRESS (package/generic)\n",
                     (int)sym->name.length, sym->name.data);
                /* Mark that we need to emit this global marker */
                if (!sym->needs_address_marker && cg->address_marker_count < 256) {
                    sym->needs_address_marker = true;
                    cg->address_markers[cg->address_marker_count++] = sym;
                }
            } else if (sym->kind == SYMBOL_TYPE && sym->type && sym->type->kind == TYPE_TASK) {
                /* Task type address - use a global marker */
                Emit(cg, "  %%t%u = ptrtoint ptr @__addr.", t);
                Emit_Symbol_Name(cg, sym);
                Emit(cg, " to i64  ; '%.*s'ADDRESS (task type)\n",
                     (int)sym->name.length, sym->name.data);
                if (!sym->needs_address_marker && cg->address_marker_count < 256) {
                    sym->needs_address_marker = true;
                    cg->address_markers[cg->address_marker_count++] = sym;
                }
            } else if (sym->kind == SYMBOL_VARIABLE && sym->type && sym->type->kind == TYPE_TASK) {
                /* Task variable (single task) address - use task control block.
                 * Must handle uplevel access when task is in enclosing scope. */
                Symbol *var_owner = sym->defining_scope ? sym->defining_scope->owner : NULL;
                bool is_uplevel = cg->current_function && var_owner &&
                                  var_owner != cg->current_function &&
                                  var_owner != cg->current_function->generic_template;
                Emit(cg, "  %%t%u = ptrtoint ptr ", t);
                if (is_uplevel && cg->is_nested) {
                    /* Uplevel access through frame pointer */
                    Emit(cg, "%%__frame.");
                    Emit_Symbol_Name(cg, sym);
                } else {
                    Emit_Symbol_Ref(cg, sym);
                }
                Emit(cg, " to i64  ; '%.*s'ADDRESS (task)\n",
                     (int)sym->name.length, sym->name.data);
            } else {
                /* Regular variable - also handle uplevel access */
                Symbol *var_owner = sym->defining_scope ? sym->defining_scope->owner : NULL;
                bool is_uplevel = cg->current_function && var_owner &&
                                  var_owner != cg->current_function &&
                                  var_owner != cg->current_function->generic_template;
                Emit(cg, "  %%t%u = ptrtoint ptr ", t);
                if (is_uplevel && cg->is_nested) {
                    Emit(cg, "%%__frame.");
                    Emit_Symbol_Name(cg, sym);
                } else {
                    Emit_Symbol_Ref(cg, sym);
                }
                Emit(cg, " to i64  ; 'ADDRESS\n");
            }
        } else {
            Emit(cg, "  %%t%u = add i64 0, 0  ; 'ADDRESS (no symbol)\n", t);
        }
        return t;
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Enumeration Attributes
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("POS"))) {
        /* T'POS(x) - position of enumeration value */
        if (first_arg) {
            return Generate_Expression(cg, first_arg);
        }
        return 0;
    }

    if (Slice_Equal_Ignore_Case(attr, S("VAL"))) {
        /* T'VAL(n) - enumeration value at position n */
        if (first_arg) {
            return Generate_Expression(cg, first_arg);
        }
        return 0;
    }

    if (Slice_Equal_Ignore_Case(attr, S("SUCC"))) {
        if (first_arg) {
            uint32_t val = Generate_Expression(cg, first_arg);
            Emit(cg, "  %%t%u = add i64 %%t%u, 1  ; 'SUCC\n", t, val);
            /* Check against BASE TYPE's high bound - CONSTRAINT_ERROR if exceeded.
             * Per Ada RM 3.5.5: 'SUCC operates on the base type, not the subtype.
             * For generic instantiations, substitute formal types with actuals. */
            Type_Info *base = Type_Base(prefix_type);
            /* Generic formal type substitution: if base type is a formal, use actual */
            if (cg->current_instance && cg->current_instance->generic_actuals && base && base->name.data) {
                for (uint32_t k = 0; k < cg->current_instance->generic_actual_count; k++) {
                    if (Slice_Equal_Ignore_Case(base->name,
                            cg->current_instance->generic_actuals[k].formal_name) &&
                        cg->current_instance->generic_actuals[k].actual_type) {
                        base = Type_Base(cg->current_instance->generic_actuals[k].actual_type);
                        break;
                    }
                }
            }
            if (base && base->high_bound.kind == BOUND_INTEGER) {
                uint32_t ok_label = cg->label_id++;
                uint32_t raise_label = cg->label_id++;
                uint32_t cmp = Emit_Temp(cg);
                Emit(cg, "  %%t%u = icmp sgt i64 %%t%u, %lld\n", cmp, t,
                     (long long)base->high_bound.int_value);
                Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cmp, raise_label, ok_label);
                Emit(cg, "L%u:  ; raise CONSTRAINT_ERROR for 'SUCC\n", raise_label);
                uint32_t exc_id = Emit_Temp(cg);
                Emit(cg, "  %%t%u = ptrtoint ptr @__exc.constraint_error to i64\n", exc_id);
                Emit(cg, "  call void @__ada_raise(i64 %%t%u)\n", exc_id);
                Emit(cg, "  unreachable\n");
                Emit(cg, "L%u:\n", ok_label);
                cg->block_terminated = false;
            }
            return t;
        }
    }

    if (Slice_Equal_Ignore_Case(attr, S("PRED"))) {
        if (first_arg) {
            uint32_t val = Generate_Expression(cg, first_arg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, 1  ; 'PRED\n", t, val);
            /* Check against BASE TYPE's low bound - CONSTRAINT_ERROR if below.
             * Per Ada RM 3.5.5: 'PRED operates on the base type, not the subtype.
             * For generic instantiations, substitute formal types with actuals. */
            Type_Info *base = Type_Base(prefix_type);
            /* Generic formal type substitution: if base type is a formal, use actual */
            if (cg->current_instance && cg->current_instance->generic_actuals && base && base->name.data) {
                for (uint32_t k = 0; k < cg->current_instance->generic_actual_count; k++) {
                    if (Slice_Equal_Ignore_Case(base->name,
                            cg->current_instance->generic_actuals[k].formal_name) &&
                        cg->current_instance->generic_actuals[k].actual_type) {
                        base = Type_Base(cg->current_instance->generic_actuals[k].actual_type);
                        break;
                    }
                }
            }
            if (base && base->low_bound.kind == BOUND_INTEGER) {
                uint32_t ok_label = cg->label_id++;
                uint32_t raise_label = cg->label_id++;
                uint32_t cmp = Emit_Temp(cg);
                Emit(cg, "  %%t%u = icmp slt i64 %%t%u, %lld\n", cmp, t,
                     (long long)base->low_bound.int_value);
                Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cmp, raise_label, ok_label);
                Emit(cg, "L%u:  ; raise CONSTRAINT_ERROR for 'PRED\n", raise_label);
                uint32_t exc_id = Emit_Temp(cg);
                Emit(cg, "  %%t%u = ptrtoint ptr @__exc.constraint_error to i64\n", exc_id);
                Emit(cg, "  call void @__ada_raise(i64 %%t%u)\n", exc_id);
                Emit(cg, "  unreachable\n");
                Emit(cg, "L%u:\n", ok_label);
                cg->block_terminated = false;
            }
            return t;
        }
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Scalar Type Attributes
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("MIN"))) {
        /* T'MIN(a, b) - minimum of two values */
        if (node->attribute.arguments.count >= 2) {
            uint32_t a = Generate_Expression(cg, node->attribute.arguments.items[0]);
            uint32_t b = Generate_Expression(cg, node->attribute.arguments.items[1]);
            /* Select minimum using icmp and select */
            uint32_t cmp = Emit_Temp(cg);
            Emit(cg, "  %%t%u = icmp slt i64 %%t%u, %%t%u\n", cmp, a, b);
            Emit(cg, "  %%t%u = select i1 %%t%u, i64 %%t%u, i64 %%t%u  ; 'MIN\n", t, cmp, a, b);
            return t;
        }
        return 0;
    }

    if (Slice_Equal_Ignore_Case(attr, S("MAX"))) {
        /* T'MAX(a, b) - maximum of two values */
        if (node->attribute.arguments.count >= 2) {
            uint32_t a = Generate_Expression(cg, node->attribute.arguments.items[0]);
            uint32_t b = Generate_Expression(cg, node->attribute.arguments.items[1]);
            /* Select maximum using icmp and select */
            uint32_t cmp = Emit_Temp(cg);
            Emit(cg, "  %%t%u = icmp sgt i64 %%t%u, %%t%u\n", cmp, a, b);
            Emit(cg, "  %%t%u = select i1 %%t%u, i64 %%t%u, i64 %%t%u  ; 'MAX\n", t, cmp, a, b);
            return t;
        }
        return 0;
    }

    if (Slice_Equal_Ignore_Case(attr, S("ABS"))) {
        /* T'ABS(x) or just abs function */
        if (first_arg) {
            uint32_t val = Generate_Expression(cg, first_arg);
            /* Compute abs: (x ^ (x >> 63)) - (x >> 63) for signed */
            uint32_t shift = Emit_Temp(cg);
            uint32_t xored = Emit_Temp(cg);
            Emit(cg, "  %%t%u = ashr i64 %%t%u, 63  ; sign bit\n", shift, val);
            Emit(cg, "  %%t%u = xor i64 %%t%u, %%t%u\n", xored, val, shift);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u  ; 'ABS\n", t, xored, shift);
            return t;
        }
    }

    if (Slice_Equal_Ignore_Case(attr, S("MOD"))) {
        /* Modular arithmetic attribute */
        if (prefix_type && prefix_type->modulus > 0) {
            Emit(cg, "  %%t%u = add i64 0, %lld  ; 'MOD\n", t,
                 (long long)prefix_type->modulus);
            return t;
        }
    }

    /* ─────────────────────────────────────────────────────────────────────
     * String/Image Attributes
     * These call runtime functions for string conversion.
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("IMAGE"))) {
        /* T'IMAGE(x) - string representation (RM 3.5.5) */
        if (first_arg) {
            uint32_t arg_val = Generate_Expression(cg, first_arg);

            if (prefix_type && (prefix_type->kind == TYPE_INTEGER ||
                                prefix_type->kind == TYPE_MODULAR ||
                                prefix_type->kind == TYPE_UNIVERSAL_INTEGER)) {
                /* Integer'IMAGE */
                Emit(cg, "  %%t%u = call { ptr, { i64, i64 } } @__ada_integer_image(i64 %%t%u)\n",
                     t, arg_val);
            } else if (prefix_type && prefix_type->kind == TYPE_CHARACTER) {
                /* Character'IMAGE */
                uint32_t char_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = trunc i64 %%t%u to i8\n", char_val, arg_val);
                Emit(cg, "  %%t%u = call { ptr, { i64, i64 } } @__ada_character_image(i8 %%t%u)\n",
                     t, char_val);
            } else if (prefix_type && (prefix_type->kind == TYPE_FLOAT ||
                                       prefix_type->kind == TYPE_UNIVERSAL_REAL)) {
                /* Float'IMAGE */
                Emit(cg, "  %%t%u = call { ptr, { i64, i64 } } @__ada_float_image(double %%t%u)\n",
                     t, arg_val);
            } else if (prefix_type && prefix_type->kind == TYPE_ENUMERATION) {
                /* Enumeration'IMAGE - return literal name as string */
                /* Find root enumeration type with literals */
                Type_Info *enum_type = prefix_type;
                while (enum_type && !enum_type->enumeration.literals) {
                    if (enum_type->parent_type) enum_type = enum_type->parent_type;
                    else if (enum_type->base_type) enum_type = enum_type->base_type;
                    else break;
                }
                if (enum_type && enum_type->enumeration.literals &&
                    enum_type->enumeration.literal_count > 0) {
                    /* Generate inline switch for literal lookup */
                    uint32_t result_ptr = Emit_Temp(cg);
                    uint32_t result_len = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = alloca ptr\n", result_ptr);
                    Emit(cg, "  %%t%u = alloca i64\n", result_len);
                    uint32_t switch_label = cg->label_id++;
                    uint32_t default_label = cg->label_id++;
                    uint32_t end_label = cg->label_id++;
                    Emit(cg, "  switch i64 %%t%u, label %%Limg_def%u [\n", arg_val, default_label);
                    for (uint32_t i = 0; i < enum_type->enumeration.literal_count; i++) {
                        Emit(cg, "    i64 %u, label %%Limg%u_%u\n", i, switch_label, i);
                    }
                    Emit(cg, "  ]\n");
                    /* Generate case labels */
                    for (uint32_t i = 0; i < enum_type->enumeration.literal_count; i++) {
                        String_Slice lit = enum_type->enumeration.literals[i];
                        /* Generate string constant name */
                        uint32_t str_id = cg->string_id++;
                        Emit(cg, "Limg%u_%u:\n", switch_label, i);
                        /* Store to globals section */
                        Emit_String_Const(cg, "@.img_str%u = private unnamed_addr constant [%u x i8] c\"",
                                   str_id, (unsigned)lit.length + 1);
                        for (uint32_t j = 0; j < lit.length; j++) {
                            Emit_String_Const(cg, "%c", (char)toupper((unsigned char)lit.data[j]));
                        }
                        Emit_String_Const(cg, "\\00\"\n");
                        Emit(cg, "  store ptr @.img_str%u, ptr %%t%u\n", str_id, result_ptr);
                        Emit(cg, "  store i64 %u, ptr %%t%u\n", (unsigned)lit.length, result_len);
                        Emit(cg, "  br label %%Limg_end%u\n", end_label);
                    }
                    /* Default case - return empty string */
                    Emit(cg, "Limg_def%u:\n", default_label);
                    Emit(cg, "  store ptr null, ptr %%t%u\n", result_ptr);
                    Emit(cg, "  store i64 0, ptr %%t%u\n", result_len);
                    Emit(cg, "  br label %%Limg_end%u\n", end_label);
                    Emit(cg, "Limg_end%u:\n", end_label);
                    uint32_t ptr_load = Emit_Temp(cg);
                    uint32_t len_load = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = load ptr, ptr %%t%u\n", ptr_load, result_ptr);
                    Emit(cg, "  %%t%u = load i64, ptr %%t%u\n", len_load, result_len);
                    /* Build fat pointer result */
                    uint32_t t1 = Emit_Temp(cg);
                    uint32_t t2 = Emit_Temp(cg);
                    uint32_t t3 = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = insertvalue { ptr, { i64, i64 } } undef, ptr %%t%u, 0\n", t1, ptr_load);
                    Emit(cg, "  %%t%u = insertvalue { ptr, { i64, i64 } } %%t%u, i64 1, 1, 0\n", t2, t1);
                    Emit(cg, "  %%t%u = insertvalue { ptr, { i64, i64 } } %%t%u, i64 %%t%u, 1, 1\n", t, t2, len_load);
                } else {
                    /* No literals found, fallback to integer image */
                    Emit(cg, "  %%t%u = call { ptr, { i64, i64 } } @__ada_integer_image(i64 %%t%u)\n",
                         t, arg_val);
                }
            } else {
                /* Default: treat as integer */
                Emit(cg, "  %%t%u = call { ptr, { i64, i64 } } @__ada_integer_image(i64 %%t%u)\n",
                     t, arg_val);
            }
            return t;
        }
        Emit(cg, "  %%t%u = insertvalue { ptr, { i64, i64 } } undef, ptr null, 0  ; 'IMAGE no arg\n", t);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("VALUE"))) {
        /* T'VALUE(s) - parse string to type (RM 3.5.5) */
        if (first_arg) {
            uint32_t str_val = Generate_Expression(cg, first_arg);
            if (prefix_type && (prefix_type->kind == TYPE_INTEGER ||
                                prefix_type->kind == TYPE_MODULAR ||
                                prefix_type->kind == TYPE_UNIVERSAL_INTEGER)) {
                /* Integer'VALUE - parse string as integer */
                Emit(cg, "  %%t%u = call i64 @__ada_integer_value({ ptr, { i64, i64 } } %%t%u)\n",
                     t, str_val);
            } else if (prefix_type && (prefix_type->kind == TYPE_FLOAT ||
                                       prefix_type->kind == TYPE_UNIVERSAL_REAL)) {
                /* Float'VALUE - parse string as float */
                Emit(cg, "  %%t%u = call double @__ada_float_value({ ptr, { i64, i64 } } %%t%u)\n",
                     t, str_val);
            } else if (prefix_type && prefix_type->kind == TYPE_ENUMERATION) {
                /* Enumeration'VALUE - find literal by name and return position */
                /* Find root enumeration type with literals */
                Type_Info *enum_type = prefix_type;
                while (enum_type && !enum_type->enumeration.literals) {
                    if (enum_type->parent_type) enum_type = enum_type->parent_type;
                    else if (enum_type->base_type) enum_type = enum_type->base_type;
                    else break;
                }
                if (enum_type && enum_type->enumeration.literals &&
                    enum_type->enumeration.literal_count > 0) {
                    /* Generate string comparison for each literal */
                    /* Extract string pointer and length from fat pointer */
                    uint32_t str_ptr = Emit_Temp(cg);
                    uint32_t str_lo = Emit_Temp(cg);
                    uint32_t str_hi = Emit_Temp(cg);
                    uint32_t str_diff = Emit_Temp(cg);
                    uint32_t str_len = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = extractvalue { ptr, { i64, i64 } } %%t%u, 0\n", str_ptr, str_val);
                    Emit(cg, "  %%t%u = extractvalue { ptr, { i64, i64 } } %%t%u, 1, 0\n", str_lo, str_val);
                    Emit(cg, "  %%t%u = extractvalue { ptr, { i64, i64 } } %%t%u, 1, 1\n", str_hi, str_val);
                    Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", str_diff, str_hi, str_lo);
                    Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", str_len, str_diff);

                    uint32_t result_alloc = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = alloca i64\n", result_alloc);
                    Emit(cg, "  store i64 0, ptr %%t%u\n", result_alloc);

                    uint32_t end_label = cg->label_id++;
                    for (uint32_t i = 0; i < enum_type->enumeration.literal_count; i++) {
                        String_Slice lit = enum_type->enumeration.literals[i];
                        uint32_t check_label = cg->label_id++;
                        uint32_t next_label = cg->label_id++;

                        /* Generate uppercase string constant */
                        uint32_t str_id = cg->string_id++;
                        Emit_String_Const(cg, "@.val_str%u = private unnamed_addr constant [%u x i8] c\"",
                                   str_id, (unsigned)lit.length + 1);
                        for (uint32_t j = 0; j < lit.length; j++) {
                            Emit_String_Const(cg, "%c", (char)toupper((unsigned char)lit.data[j]));
                        }
                        Emit_String_Const(cg, "\\00\"\n");

                        /* Check length first */
                        uint32_t len_cmp = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %u\n", len_cmp, str_len, (unsigned)lit.length);
                        Emit(cg, "  br i1 %%t%u, label %%Lval%u, label %%Lval_next%u\n", len_cmp, check_label, next_label);

                        Emit(cg, "Lval%u:\n", check_label);
                        /* Compare strings (case insensitive using strncasecmp) */
                        uint32_t cmp_result = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = call i32 @strncasecmp(ptr %%t%u, ptr @.val_str%u, i64 %u)\n",
                             cmp_result, str_ptr, str_id, (unsigned)lit.length);
                        uint32_t cmp_eq = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", cmp_eq, cmp_result);
                        uint32_t match_label = cg->label_id++;
                        Emit(cg, "  br i1 %%t%u, label %%Lval_match%u, label %%Lval_next%u\n", cmp_eq, match_label, next_label);

                        Emit(cg, "Lval_match%u:\n", match_label);
                        Emit(cg, "  store i64 %u, ptr %%t%u\n", i, result_alloc);
                        Emit(cg, "  br label %%Lval_end%u\n", end_label);

                        Emit(cg, "Lval_next%u:\n", next_label);
                    }
                    /* No match - leave as 0 (could raise CONSTRAINT_ERROR) */
                    Emit(cg, "  br label %%Lval_end%u\n", end_label);
                    Emit(cg, "Lval_end%u:\n", end_label);
                    Emit(cg, "  %%t%u = load i64, ptr %%t%u\n", t, result_alloc);
                } else {
                    /* No literals found, fallback to integer value */
                    Emit(cg, "  %%t%u = call i64 @__ada_integer_value({ ptr, { i64, i64 } } %%t%u)\n",
                         t, str_val);
                }
            } else {
                /* Default: treat as integer */
                Emit(cg, "  %%t%u = call i64 @__ada_integer_value({ ptr, { i64, i64 } } %%t%u)\n",
                     t, str_val);
            }
            return t;
        }
        return 0;
    }

    if (Slice_Equal_Ignore_Case(attr, S("WIDTH"))) {
        /* T'WIDTH - maximum image width for type (RM 3.5.5)
         * Per GNAT exp_imgv.adb Expand_Width_Attribute:
         * - For null range (FIRST > LAST), WIDTH is 0
         * - For enumeration: max length of literal names in range
         * - For integer: max width of first/last images
         * - For boolean: max("FALSE", "TRUE") = 5
         * - For character: 3 ('X')
         *
         * When bounds are not compile-time known, generate runtime code. */
        if (prefix_type) {
            bool lo_known = Type_Bound_Is_Compile_Time_Known(prefix_type->low_bound);
            bool hi_known = Type_Bound_Is_Compile_Time_Known(prefix_type->high_bound);

            /* Find root enumeration type (traversing base_type and parent_type chains) */
            Type_Info *root_enum = NULL;
            for (Type_Info *ti = prefix_type; ti; ti = ti->base_type ? ti->base_type : ti->parent_type) {
                if (ti->kind == TYPE_ENUMERATION && ti->enumeration.literals) {
                    root_enum = ti;
                    break;
                }
                if (!ti->base_type && !ti->parent_type) break;
            }

            if (lo_known && hi_known) {
                /* Both bounds are compile-time known - compute WIDTH statically */
                int64_t width = 0;
                int64_t lo = Type_Bound_Value(prefix_type->low_bound);
                int64_t hi = Type_Bound_Value(prefix_type->high_bound);

                if (hi < lo) {
                    /* Empty range - width is 0 */
                    width = 0;
                } else if (root_enum) {
                    /* Enumeration: max length of literal names in range */
                    for (int64_t i = lo; i <= hi && i < (int64_t)root_enum->enumeration.literal_count; i++) {
                        if (i >= 0) {
                            uint32_t len = root_enum->enumeration.literals[i].length;
                            if (len > (uint32_t)width) width = (int64_t)len;
                        }
                    }
                } else if (prefix_type->kind == TYPE_BOOLEAN ||
                           (prefix_type->base_type && prefix_type->base_type->kind == TYPE_BOOLEAN)) {
                    /* Boolean: "FALSE" is 5, "TRUE" is 4 */
                    width = (lo <= 0 && hi >= 0) ? 5 : (lo <= 1 && hi >= 1) ? 4 : 0;
                } else if (prefix_type->kind == TYPE_CHARACTER ||
                           (prefix_type->base_type && prefix_type->base_type->kind == TYPE_CHARACTER)) {
                    /* Character: 'X' is 3 chars */
                    width = 3;
                } else {
                    /* Integer types: max width of first/last images */
                    /* Width includes leading space for non-negative */
                    int64_t abs_lo = lo < 0 ? -lo : lo;
                    int64_t abs_hi = hi < 0 ? -hi : hi;
                    int64_t max_abs = abs_lo > abs_hi ? abs_lo : abs_hi;
                    int digits = 1;
                    while (max_abs >= 10) { digits++; max_abs /= 10; }
                    width = digits + 1;  /* +1 for leading space or minus sign */
                }
                Emit(cg, "  %%t%u = add i64 0, %lld  ; 'WIDTH\n", t, (long long)width);
            } else {
                /* Bounds not compile-time known - generate runtime code.
                 * Per GNAT exp_imgv.adb: generate if FIRST > LAST then 0 else <width>
                 * For enumeration types with runtime bounds, we compute the full-range
                 * width at compile time (since literals are known) and use 0 for null range. */
                uint32_t lo_val = Generate_Bound_Value(cg, prefix_type->low_bound);
                uint32_t hi_val = Generate_Bound_Value(cg, prefix_type->high_bound);

                /* Compare: is_null = (lo > hi) */
                uint32_t cmp = cg->temp_id++;
                Emit(cg, "  %%t%u = icmp sgt i64 %%t%u, %%t%u  ; FIRST > LAST?\n", cmp, lo_val, hi_val);

                /* Compute the width for non-null range at compile time */
                int64_t full_width = 0;
                if (root_enum) {
                    /* For enumeration: compute max width over full base type range */
                    for (uint32_t i = 0; i < root_enum->enumeration.literal_count; i++) {
                        uint32_t len = root_enum->enumeration.literals[i].length;
                        if (len > (uint32_t)full_width) full_width = (int64_t)len;
                    }
                } else if (prefix_type->kind == TYPE_BOOLEAN ||
                           (prefix_type->base_type && prefix_type->base_type->kind == TYPE_BOOLEAN)) {
                    /* Boolean: WIDTH depends on which values are in range.
                     * FALSE=0 has width 5, TRUE=1 has width 4.
                     * If lo <= 0 (FALSE is in range): width = 5
                     * Otherwise (only TRUE in range): width = 4
                     * Generate: select (lo <= 0), 5, 4 */
                    uint32_t has_false = cg->temp_id++;
                    Emit(cg, "  %%t%u = icmp sle i64 %%t%u, 0  ; has FALSE?\n", has_false, lo_val);
                    uint32_t bool_width = cg->temp_id++;
                    Emit(cg, "  %%t%u = select i1 %%t%u, i64 5, i64 4  ; FALSE=5, TRUE=4\n", bool_width, has_false);

                    /* Select: if is_null then 0 else bool_width */
                    Emit(cg, "  %%t%u = select i1 %%t%u, i64 0, i64 %%t%u  ; 'WIDTH (runtime bool)\n",
                         t, cmp, bool_width);
                    return t;
                } else if (prefix_type->kind == TYPE_CHARACTER ||
                           (prefix_type->base_type && prefix_type->base_type->kind == TYPE_CHARACTER)) {
                    full_width = 3;  /* 'X' */
                } else {
                    /* Integer: compute WIDTH based on actual runtime bounds.
                     * WIDTH = max(digits(abs(lo)), digits(abs(hi))) + 1
                     * Generate runtime code to compute this. */

                    /* Compute abs(lo): if lo < 0 then -lo else lo */
                    uint32_t neg_lo = cg->temp_id++;
                    Emit(cg, "  %%t%u = sub i64 0, %%t%u\n", neg_lo, lo_val);
                    uint32_t is_neg_lo = cg->temp_id++;
                    Emit(cg, "  %%t%u = icmp slt i64 %%t%u, 0\n", is_neg_lo, lo_val);
                    uint32_t abs_lo = cg->temp_id++;
                    Emit(cg, "  %%t%u = select i1 %%t%u, i64 %%t%u, i64 %%t%u\n", abs_lo, is_neg_lo, neg_lo, lo_val);

                    /* Compute abs(hi): if hi < 0 then -hi else hi */
                    uint32_t neg_hi = cg->temp_id++;
                    Emit(cg, "  %%t%u = sub i64 0, %%t%u\n", neg_hi, hi_val);
                    uint32_t is_neg_hi = cg->temp_id++;
                    Emit(cg, "  %%t%u = icmp slt i64 %%t%u, 0\n", is_neg_hi, hi_val);
                    uint32_t abs_hi = cg->temp_id++;
                    Emit(cg, "  %%t%u = select i1 %%t%u, i64 %%t%u, i64 %%t%u\n", abs_hi, is_neg_hi, neg_hi, hi_val);

                    /* max_abs = max(abs_lo, abs_hi) */
                    uint32_t cmp_abs = cg->temp_id++;
                    Emit(cg, "  %%t%u = icmp ugt i64 %%t%u, %%t%u\n", cmp_abs, abs_lo, abs_hi);
                    uint32_t max_abs = cg->temp_id++;
                    Emit(cg, "  %%t%u = select i1 %%t%u, i64 %%t%u, i64 %%t%u\n", max_abs, cmp_abs, abs_lo, abs_hi);

                    /* Count digits using comparison chain (for i64, max 19 digits) */
                    /* digits = 1 if < 10, 2 if < 100, ..., 19 if < 10^19 */
                    uint32_t prev = max_abs;
                    uint32_t digits_val = cg->temp_id++;
                    Emit(cg, "  %%t%u = add i64 0, 1  ; initial digits\n", digits_val);

                    int64_t thresholds[] = {10, 100, 1000, 10000, 100000, 1000000, 10000000,
                                           100000000, 1000000000, 10000000000LL, 100000000000LL,
                                           1000000000000LL, 10000000000000LL, 100000000000000LL,
                                           1000000000000000LL, 10000000000000000LL,
                                           100000000000000000LL, 1000000000000000000LL};
                    for (int d = 0; d < 18; d++) {
                        uint32_t cmp_d = cg->temp_id++;
                        Emit(cg, "  %%t%u = icmp uge i64 %%t%u, %lld\n", cmp_d, max_abs, (long long)thresholds[d]);
                        uint32_t next_digits = cg->temp_id++;
                        Emit(cg, "  %%t%u = select i1 %%t%u, i64 %d, i64 %%t%u\n",
                             next_digits, cmp_d, d + 2, digits_val);
                        digits_val = next_digits;
                    }

                    /* width = digits + 1 (for leading space or minus sign) */
                    uint32_t width_val = cg->temp_id++;
                    Emit(cg, "  %%t%u = add i64 %%t%u, 1  ; +1 for sign/space\n", width_val, digits_val);

                    full_width = 0;  /* Not used - we have runtime value */

                    /* Select: if is_null then 0 else width_val */
                    Emit(cg, "  %%t%u = select i1 %%t%u, i64 0, i64 %%t%u  ; 'WIDTH (runtime)\n",
                         t, cmp, width_val);
                    return t;
                }

                /* Select: if is_null then 0 else full_width */
                Emit(cg, "  %%t%u = select i1 %%t%u, i64 0, i64 %lld  ; 'WIDTH (runtime)\n",
                     t, cmp, (long long)full_width);
            }
            return t;
        }
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Access Type Attributes
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("ACCESS"))) {
        /* X'ACCESS - access to X (address) */
        Symbol *sym = node->attribute.prefix->symbol;
        if (sym) {
            Emit(cg, "  %%t%u = getelementptr i8, ptr ", t);
            Emit_Symbol_Ref(cg, sym);
            Emit(cg, ", i64 0  ; 'ACCESS\n");
        } else {
            Emit(cg, "  %%t%u = add i64 0, 0\n", t);
        }
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("UNCHECKED_ACCESS"))) {
        /* X'UNCHECKED_ACCESS - unchecked access to X */
        Symbol *sym = node->attribute.prefix->symbol;
        if (sym) {
            Emit(cg, "  %%t%u = getelementptr i8, ptr ", t);
            Emit_Symbol_Ref(cg, sym);
            Emit(cg, ", i64 0  ; 'UNCHECKED_ACCESS\n");
        } else {
            Emit(cg, "  %%t%u = add i64 0, 0\n", t);
        }
        return t;
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Floating-Point Type Attributes (RM 3.5.8)
     * These attributes return compile-time values for floating-point types.
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("DIGITS"))) {
        /* T'DIGITS - number of significant decimal digits (universal integer) */
        int64_t digits = 15;  /* Default for double precision (8 bytes) */
        if (prefix_type && prefix_type->size <= 4) {
            digits = 6;  /* Single precision float */
        }
        Emit(cg, "  %%t%u = add i64 0, %lld  ; 'DIGITS\n", t, (long long)digits);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("MANTISSA"))) {
        /* T'MANTISSA - number of binary digits in fixed-point representation
         * Formula: ceil(log2(bound / small)) where small is actual step (RM 3.5.10) */
        int64_t mantissa = 52;  /* Default for IEEE double precision */
        if (prefix_type && prefix_type->kind == TYPE_FIXED) {
            double small = prefix_type->fixed.small;
            double low_val = Type_Bound_Float_Value(prefix_type->low_bound);
            double high_val = Type_Bound_Float_Value(prefix_type->high_bound);
            if (small <= 0) small = prefix_type->fixed.delta > 0 ? prefix_type->fixed.delta : 1.0;
            double bound = fmax(fabs(low_val), fabs(high_val));
            if (bound > 0 && small > 0) {
                mantissa = (int64_t)ceil(log2(bound / small));
                if (mantissa < 1) mantissa = 1;
            }
        }
        Emit(cg, "  %%t%u = add i64 0, %lld  ; 'MANTISSA\n", t, (long long)mantissa);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("EMAX"))) {
        /* T'EMAX - maximum binary exponent (universal integer) */
        int64_t emax = 1023;  /* IEEE double precision */
        Emit(cg, "  %%t%u = add i64 0, %lld  ; 'EMAX\n", t, (long long)emax);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("SAFE_EMAX"))) {
        /* T'SAFE_EMAX - safe maximum exponent (universal integer) */
        int64_t safe_emax = 1021;  /* Conservative for IEEE double */
        Emit(cg, "  %%t%u = add i64 0, %lld  ; 'SAFE_EMAX\n", t, (long long)safe_emax);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("EPSILON"))) {
        /* T'EPSILON - machine epsilon (universal real) */
        /* For double precision: 2^-52 ≈ 2.220446049250313e-16 */
        Emit(cg, "  %%t%u = fadd double 0.0, 0x3CB0000000000000  ; 'EPSILON (2^-52)\n", t);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("SMALL"))) {
        /* T'SMALL - for fixed-point: implementation-defined power of 2 <= delta
         * For float: smallest positive model number (RM 3.5.8, 3.5.10) */
        if (prefix_type && prefix_type->kind == TYPE_FIXED) {
            double small = prefix_type->fixed.small;
            if (small <= 0) small = prefix_type->fixed.delta;
            if (small <= 0) small = 1.0;
            uint64_t bits;
            memcpy(&bits, &small, sizeof(bits));
            Emit(cg, "  %%t%u = fadd double 0.0, 0x%016llX  ; 'SMALL (%g)\n",
                 t, (unsigned long long)bits, small);
        } else {
            /* Float type: 2^-1022 for double precision */
            Emit(cg, "  %%t%u = fadd double 0.0, 0x0010000000000000  ; 'SMALL (2^-1022)\n", t);
        }
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("LARGE"))) {
        /* T'LARGE - for fixed-point: (2^MANTISSA - 1) * SMALL (RM 3.5.10)
         * For float: largest model number */
        if (prefix_type && prefix_type->kind == TYPE_FIXED) {
            double small = prefix_type->fixed.small;
            if (small <= 0) small = prefix_type->fixed.delta > 0 ? prefix_type->fixed.delta : 1.0;
            double bound = fmax(fabs(Type_Bound_Float_Value(prefix_type->low_bound)),
                               fabs(Type_Bound_Float_Value(prefix_type->high_bound)));
            int64_t mantissa = (bound > 0 && small > 0) ?
                              (int64_t)ceil(log2(bound / small)) : 1;
            if (mantissa < 1) mantissa = 1;
            double large = ((double)((1LL << mantissa) - 1)) * small;
            uint64_t bits;
            memcpy(&bits, &large, sizeof(bits));
            Emit(cg, "  %%t%u = fadd double 0.0, 0x%016llX  ; 'LARGE (%g)\n",
                 t, (unsigned long long)bits, large);
        } else {
            /* Float type: approximately 1.7976931348623157e+308 */
            Emit(cg, "  %%t%u = fadd double 0.0, 0x7FEFFFFFFFFFFFFF  ; 'LARGE\n", t);
        }
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("SAFE_SMALL"))) {
        /* T'SAFE_SMALL - safe minimum value (universal real) */
        Emit(cg, "  %%t%u = fadd double 0.0, 0x0040000000000000  ; 'SAFE_SMALL (2^-1021)\n", t);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("SAFE_LARGE"))) {
        /* T'SAFE_LARGE - safe maximum value (universal real) */
        Emit(cg, "  %%t%u = fadd double 0.0, 0x7FD0000000000000  ; 'SAFE_LARGE (2^1021)\n", t);
        return t;
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Fixed-Point Type Attributes (RM 3.5.9)
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("DELTA"))) {
        /* T'DELTA - delta for fixed-point type (universal real) */
        double delta = 1.0;
        if (prefix_type && prefix_type->kind == TYPE_FIXED) {
            delta = prefix_type->fixed.delta > 0 ? prefix_type->fixed.delta : 1.0;
        }
        Emit(cg, "  %%t%u = fadd double 0.0, %e  ; 'DELTA\n", t, delta);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("FORE"))) {
        /* T'FORE - decimal digits before point in default output (RM 3.5.10)
         * FORE = 1 + floor(log10(max(|T'FIRST|, |T'LAST|))) */
        int64_t fore = 1;
        if (prefix_type && prefix_type->kind == TYPE_FIXED) {
            double bound = fmax(fabs(Type_Bound_Float_Value(prefix_type->low_bound)),
                               fabs(Type_Bound_Float_Value(prefix_type->high_bound)));
            if (bound >= 1.0) {
                fore = 1 + (int64_t)floor(log10(bound));
            }
        }
        Emit(cg, "  %%t%u = add i64 0, %lld  ; 'FORE\n", t, (long long)fore);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("AFT"))) {
        /* T'AFT - decimal digits after point in default output (RM 3.5.10)
         * AFT = smallest N such that 10^(-N) <= T'DELTA */
        int64_t aft = 1;
        if (prefix_type && prefix_type->kind == TYPE_FIXED) {
            double delta = prefix_type->fixed.delta;
            if (delta > 0 && delta < 1.0) {
                aft = (int64_t)ceil(-log10(delta));
            }
        }
        Emit(cg, "  %%t%u = add i64 0, %lld  ; 'AFT\n", t, (long long)aft);
        return t;
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Floating-Point Boolean Attributes (RM 3.5.8)
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("MACHINE_ROUNDS"))) {
        /* T'MACHINE_ROUNDS - does the hardware round? (RM 3.5.8)
         * IEEE 754 hardware rounds, so return TRUE */
        Emit(cg, "  %%t%u = add i1 0, 1  ; 'MACHINE_ROUNDS (IEEE rounds)\n", t);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("MACHINE_OVERFLOWS"))) {
        /* T'MACHINE_OVERFLOWS - does the hardware raise on overflow? (RM 3.5.8)
         * IEEE 754 generates infinity on overflow (doesn't trap), return FALSE */
        Emit(cg, "  %%t%u = add i1 0, 0  ; 'MACHINE_OVERFLOWS (IEEE no trap)\n", t);
        return t;
    }

    /* ─────────────────────────────────────────────────────────────────────
     * Object Attributes (RM 3.7.1, 9.9)
     * ───────────────────────────────────────────────────────────────────── */

    if (Slice_Equal_Ignore_Case(attr, S("CONSTRAINED"))) {
        /* X'CONSTRAINED - is the object constrained? (RM 3.7.1)
         * Returns TRUE if object has discriminant constraints, FALSE otherwise.
         * For now, assume objects without explicit constraints are unconstrained
         * (this is a simplification - full implementation would track constraints) */
        Emit(cg, "  %%t%u = add i1 0, 1  ; 'CONSTRAINED (assume true)\n", t);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("CALLABLE"))) {
        /* T'CALLABLE - is the task callable? (RM 9.9) */
        Emit(cg, "  %%t%u = add i1 0, 1  ; 'CALLABLE (assume true)\n", t);
        return t;
    }

    if (Slice_Equal_Ignore_Case(attr, S("TERMINATED"))) {
        /* T'TERMINATED - has the task terminated? (RM 9.9) */
        Emit(cg, "  %%t%u = add i1 0, 0  ; 'TERMINATED (assume false)\n", t);
        return t;
    }

    /* Unhandled attribute */
    Emit(cg, "  %%t%u = add i64 0, 0  ; unhandled '%.*s\n", t,
         (int)attr.length, attr.data);
    return t;
}

/* Helper: Find component index by name in record type */
static int32_t Find_Record_Component(Type_Info *record_type, String_Slice name) {
    if (!record_type || record_type->kind != TYPE_RECORD) return -1;
    for (uint32_t i = 0; i < record_type->record.component_count; i++) {
        if (Slice_Equal_Ignore_Case(record_type->record.components[i].name, name)) {
            return (int32_t)i;
        }
    }
    return -1;
}

/* Check if a choice is "others" */
static bool Is_Others_Choice(Syntax_Node *choice) {
    return choice && choice->kind == NK_IDENTIFIER &&
           Slice_Equal_Ignore_Case(choice->string_val.text, S("others"));
}

static uint32_t Generate_Aggregate(Code_Generator *cg, Syntax_Node *node) {
    /* Generate code for record/array aggregates
     * Supports: positional, named associations, others clause, ranges */
    Type_Info *agg_type = node->type;

    if (!agg_type) {
        Report_Error(node->location, "untyped aggregate in codegen");
        return 0;
    }

    if (agg_type->kind == TYPE_ARRAY && agg_type->array.index_count > 0) {
        /* Array aggregate - allocate on stack and initialize */
        const char *elem_type = Type_To_Llvm(agg_type->array.element_type);
        uint32_t elem_size = agg_type->array.element_type ?
                             agg_type->array.element_type->size : 8;
        if (elem_size == 0) elem_size = 8;

        /* Check if bounds are dynamic */
        Type_Bound low_bound = agg_type->array.indices[0].low_bound;
        Type_Bound high_bound = agg_type->array.indices[0].high_bound;
        bool dynamic_bounds = (low_bound.kind == BOUND_EXPR) || (high_bound.kind == BOUND_EXPR);

        if (dynamic_bounds) {
            /* Dynamic bounds: generate runtime allocation and loop-based init */
            uint32_t low_val, high_val;

            /* Generate low bound */
            if (low_bound.kind == BOUND_INTEGER) {
                low_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", low_val, (long long)low_bound.int_value);
            } else if (low_bound.kind == BOUND_EXPR && low_bound.expr) {
                low_val = Generate_Expression(cg, low_bound.expr);
                /* Extend to i64 if narrower type (e.g., ENUM bounds return i8) */
                const char *low_llvm = Expression_Llvm_Type(low_bound.expr);
                if (strcmp(low_llvm, "i64") != 0 && strcmp(low_llvm, "ptr") != 0 &&
                    strcmp(low_llvm, "double") != 0 && strcmp(low_llvm, "float") != 0) {
                    low_val = Emit_Convert(cg, low_val, low_llvm, "i64");
                }
            } else {
                low_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 1\n", low_val);
            }

            /* Generate high bound */
            if (high_bound.kind == BOUND_INTEGER) {
                high_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", high_val, (long long)high_bound.int_value);
            } else if (high_bound.kind == BOUND_EXPR && high_bound.expr) {
                high_val = Generate_Expression(cg, high_bound.expr);
                /* Extend to i64 if narrower type (e.g., ENUM bounds return i8) */
                const char *high_llvm = Expression_Llvm_Type(high_bound.expr);
                if (strcmp(high_llvm, "i64") != 0 && strcmp(high_llvm, "ptr") != 0 &&
                    strcmp(high_llvm, "double") != 0 && strcmp(high_llvm, "float") != 0) {
                    high_val = Emit_Convert(cg, high_val, high_llvm, "i64");
                }
            } else {
                high_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 1\n", high_val);
            }

            /* Calculate count and byte size */
            uint32_t count_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", count_val, high_val, low_val);
            uint32_t count_plus1 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", count_plus1, count_val);
            uint32_t byte_size = Emit_Temp(cg);
            Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_size, count_plus1, elem_size);

            /* Dynamic stack allocation */
            uint32_t base = Emit_Temp(cg);
            Emit(cg, "  %%t%u = alloca i8, i64 %%t%u  ; dynamic array aggregate\n", base, byte_size);

            /* Find "others" clause and generate value */
            uint32_t others_val = 0;
            bool has_others = false;
            for (uint32_t i = 0; i < node->aggregate.items.count; i++) {
                Syntax_Node *item = node->aggregate.items.items[i];
                if (item->kind == NK_ASSOCIATION && item->association.choices.count > 0) {
                    if (Is_Others_Choice(item->association.choices.items[0])) {
                        others_val = Generate_Expression(cg, item->association.expression);
                        const char *src_type = Expression_Llvm_Type(item->association.expression);
                        others_val = Emit_Convert(cg, others_val, src_type, elem_type);
                        has_others = true;
                        break;
                    }
                }
            }

            /* For dynamic aggregates with named range association (1..H1 => val),
             * generate a loop to initialize all elements */
            for (uint32_t i = 0; i < node->aggregate.items.count; i++) {
                Syntax_Node *item = node->aggregate.items.items[i];
                if (item->kind == NK_ASSOCIATION && item->association.choices.count > 0) {
                    Syntax_Node *choice = item->association.choices.items[0];
                    if (Is_Others_Choice(choice)) continue;

                    if (choice->kind == NK_RANGE) {
                        /* Generate loop bounds */
                        uint32_t rng_low_val, rng_high_val;
                        if (choice->range.low->kind == NK_INTEGER) {
                            rng_low_val = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 0, %lld\n", rng_low_val,
                                 (long long)choice->range.low->integer_lit.value);
                        } else {
                            rng_low_val = Generate_Expression(cg, choice->range.low);
                        }
                        if (choice->range.high->kind == NK_INTEGER) {
                            rng_high_val = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = add i64 0, %lld\n", rng_high_val,
                                 (long long)choice->range.high->integer_lit.value);
                        } else {
                            rng_high_val = Generate_Expression(cg, choice->range.high);
                        }

                        /* Generate the value expression */
                        uint32_t val = Generate_Expression(cg, item->association.expression);

                        /* Check if element is composite (record or constrained array) */
                        Type_Info *elem_ti = agg_type->array.element_type;
                        bool elem_is_composite = elem_ti &&
                            (elem_ti->kind == TYPE_RECORD ||
                             (elem_ti->kind == TYPE_ARRAY && elem_ti->array.is_constrained));

                        if (!elem_is_composite) {
                            const char *src_type = Expression_Llvm_Type(item->association.expression);
                            val = Emit_Convert(cg, val, src_type, elem_type);
                        }

                        /* Generate initialization loop */
                        uint32_t loop_var = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = alloca i64\n", loop_var);
                        Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", rng_low_val, loop_var);

                        uint32_t loop_start = cg->label_id++;
                        uint32_t loop_body = cg->label_id++;
                        uint32_t loop_end = cg->label_id++;

                        Emit(cg, "  br label %%L%u\n", loop_start);
                        Emit(cg, "L%u:\n", loop_start);

                        uint32_t cur_idx = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = load i64, ptr %%t%u\n", cur_idx, loop_var);
                        uint32_t cmp = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = icmp sle i64 %%t%u, %%t%u\n", cmp, cur_idx, rng_high_val);
                        Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cmp, loop_body, loop_end);

                        Emit(cg, "L%u:\n", loop_body);
                        /* Calculate array index: (cur_idx - low_val) */
                        uint32_t arr_idx = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", arr_idx, cur_idx, low_val);

                        if (elem_is_composite) {
                            /* Composite element: use byte-based indexing and memcpy */
                            uint32_t byte_off = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_off, arr_idx, elem_size);
                            uint32_t ptr = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n",
                                 ptr, base, byte_off);
                            Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %u, i1 false)\n",
                                 ptr, val, elem_size);
                        } else {
                            /* Scalar element: use typed indexing and store */
                            uint32_t ptr = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i64 %%t%u\n",
                                 ptr, elem_type, base, arr_idx);
                            Emit(cg, "  store %s %%t%u, ptr %%t%u\n", elem_type, val, ptr);
                        }

                        /* Increment and loop */
                        uint32_t next_idx = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", next_idx, cur_idx);
                        Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", next_idx, loop_var);
                        Emit(cg, "  br label %%L%u\n", loop_start);

                        Emit(cg, "L%u:\n", loop_end);
                        cg->block_terminated = false;
                    }
                }
            }

            /* If "others" clause, fill remaining with loop (already handled by range above
             * for typical cases like (1..H1 => val), but add fallback if needed) */
            if (has_others) {
                /* Check if element is composite */
                Type_Info *elem_ti = agg_type->array.element_type;
                bool elem_is_composite = elem_ti &&
                    (elem_ti->kind == TYPE_RECORD ||
                     (elem_ti->kind == TYPE_ARRAY && elem_ti->array.is_constrained));

                /* Generate loop from low to high */
                uint32_t loop_var = Emit_Temp(cg);
                Emit(cg, "  %%t%u = alloca i64\n", loop_var);
                Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", low_val, loop_var);

                uint32_t loop_start = cg->label_id++;
                uint32_t loop_body = cg->label_id++;
                uint32_t loop_end = cg->label_id++;

                Emit(cg, "  br label %%L%u\n", loop_start);
                Emit(cg, "L%u:\n", loop_start);

                uint32_t cur_idx = Emit_Temp(cg);
                Emit(cg, "  %%t%u = load i64, ptr %%t%u\n", cur_idx, loop_var);
                uint32_t cmp = Emit_Temp(cg);
                Emit(cg, "  %%t%u = icmp sle i64 %%t%u, %%t%u\n", cmp, cur_idx, high_val);
                Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cmp, loop_body, loop_end);

                Emit(cg, "L%u:\n", loop_body);
                uint32_t arr_idx = Emit_Temp(cg);
                Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", arr_idx, cur_idx, low_val);

                if (elem_is_composite) {
                    /* Composite element: use byte-based indexing and memcpy */
                    uint32_t byte_off = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_off, arr_idx, elem_size);
                    uint32_t ptr = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n",
                         ptr, base, byte_off);
                    Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %u, i1 false)\n",
                         ptr, others_val, elem_size);
                } else {
                    /* Scalar element: use typed indexing and store */
                    uint32_t ptr = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i64 %%t%u\n",
                         ptr, elem_type, base, arr_idx);
                    Emit(cg, "  store %s %%t%u, ptr %%t%u\n", elem_type, others_val, ptr);
                }

                uint32_t next_idx = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", next_idx, cur_idx);
                Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", next_idx, loop_var);
                Emit(cg, "  br label %%L%u\n", loop_start);

                Emit(cg, "L%u:\n", loop_end);
                cg->block_terminated = false;
            }

            /* For dynamic bounds arrays, return a fat pointer { ptr, { i64, i64 } }
             * so the bounds don't need to be re-evaluated (which would be wrong for
             * bound expressions with side effects like function calls). */
            uint32_t fat_ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = alloca { ptr, { i64, i64 } }  ; dynamic array fat ptr\n", fat_ptr);

            /* Store data pointer */
            uint32_t data_slot = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%t%u, i32 0, i32 0\n",
                 data_slot, fat_ptr);
            Emit(cg, "  store ptr %%t%u, ptr %%t%u\n", base, data_slot);

            /* Store low bound */
            uint32_t low_slot = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%t%u, i32 0, i32 1, i32 0\n",
                 low_slot, fat_ptr);
            Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", low_val, low_slot);

            /* Store high bound */
            uint32_t high_slot = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%t%u, i32 0, i32 1, i32 1\n",
                 high_slot, fat_ptr);
            Emit(cg, "  store i64 %%t%u, ptr %%t%u\n", high_val, high_slot);

            return fat_ptr;
        }

        /* Static bounds: use compile-time allocation and unrolled initialization */
        uint32_t base = Emit_Temp(cg);
        int64_t low = Type_Bound_Value(low_bound);
        int64_t high = Type_Bound_Value(high_bound);
        int64_t count = high - low + 1;
        if (count < 1) count = 1;  /* Ensure at least 1 element for safety */

        Emit(cg, "  %%t%u = alloca [%lld x %s]  ; array aggregate\n",
             base, (long long)count, elem_type);

        /* Track which elements are initialized (for others clause) */
        bool *initialized = Arena_Allocate((size_t)count * sizeof(bool));
        for (int64_t i = 0; i < count; i++) initialized[i] = false;

        /* Default value for "others" clause (if any) */
        uint32_t others_val = 0;
        bool has_others = false;

        /* First pass: find "others" clause */
        for (uint32_t i = 0; i < node->aggregate.items.count; i++) {
            Syntax_Node *item = node->aggregate.items.items[i];
            if (item->kind == NK_ASSOCIATION && item->association.choices.count > 0) {
                if (Is_Others_Choice(item->association.choices.items[0])) {
                    others_val = Generate_Expression(cg, item->association.expression);
                    const char *src_type = Expression_Llvm_Type(item->association.expression);
                    others_val = Emit_Convert(cg, others_val, src_type, elem_type);
                    has_others = true;
                    break;
                }
            }
        }

        /* Second pass: initialize elements */
        uint32_t positional_idx = 0;
        for (uint32_t i = 0; i < node->aggregate.items.count; i++) {
            Syntax_Node *item = node->aggregate.items.items[i];

            if (item->kind == NK_ASSOCIATION) {
                /* Named association: handle each choice */
                for (uint32_t c = 0; c < item->association.choices.count; c++) {
                    Syntax_Node *choice = item->association.choices.items[c];

                    if (Is_Others_Choice(choice)) {
                        continue;  /* Handle in third pass */
                    }

                    if (choice->kind == NK_RANGE) {
                        /* Range choice: 1..5 => value */
                        int64_t rng_low = choice->range.low->kind == NK_INTEGER ?
                                          choice->range.low->integer_lit.value : low;
                        int64_t rng_high = choice->range.high->kind == NK_INTEGER ?
                                           choice->range.high->integer_lit.value : high;
                        uint32_t val = Generate_Expression(cg, item->association.expression);
                        const char *src_type = Expression_Llvm_Type(item->association.expression);
                        val = Emit_Convert(cg, val, src_type, elem_type);

                        for (int64_t idx = rng_low; idx <= rng_high; idx++) {
                            int64_t arr_idx = idx - low;
                            if (arr_idx >= 0 && arr_idx < count) {
                                uint32_t ptr = Emit_Temp(cg);
                                Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i64 %lld\n",
                                     ptr, elem_type, base, (long long)arr_idx);
                                Emit(cg, "  store %s %%t%u, ptr %%t%u\n", elem_type, val, ptr);
                                initialized[arr_idx] = true;
                            }
                        }
                    } else if (choice->kind == NK_INTEGER) {
                        /* Single index: 3 => value */
                        int64_t idx = choice->integer_lit.value - low;
                        if (idx >= 0 && idx < count) {
                            uint32_t val = Generate_Expression(cg, item->association.expression);
                            const char *src_type = Expression_Llvm_Type(item->association.expression);
                            val = Emit_Convert(cg, val, src_type, elem_type);
                            uint32_t ptr = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i64 %lld\n",
                                 ptr, elem_type, base, (long long)idx);
                            Emit(cg, "  store %s %%t%u, ptr %%t%u\n", elem_type, val, ptr);
                            initialized[idx] = true;
                        }
                    }
                }
            } else {
                /* Positional association */
                if (positional_idx < (uint32_t)count) {
                    uint32_t val = Generate_Expression(cg, item);
                    const char *src_type = Expression_Llvm_Type(item);
                    val = Emit_Convert(cg, val, src_type, elem_type);
                    uint32_t ptr = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i64 %u\n",
                         ptr, elem_type, base, positional_idx);
                    Emit(cg, "  store %s %%t%u, ptr %%t%u\n", elem_type, val, ptr);
                    initialized[positional_idx] = true;
                    positional_idx++;
                }
            }
        }

        /* Third pass: fill uninitialized with "others" value */
        if (has_others) {
            for (int64_t idx = 0; idx < count; idx++) {
                if (!initialized[idx]) {
                    uint32_t ptr = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i64 %lld\n",
                         ptr, elem_type, base, (long long)idx);
                    Emit(cg, "  store %s %%t%u, ptr %%t%u\n", elem_type, others_val, ptr);
                }
            }
        }

        return base;
    }

    if (agg_type->kind == TYPE_RECORD) {
        /* Record aggregate - allocate [N x i8] and fill fields by offset */
        uint32_t base = Emit_Temp(cg);
        uint32_t record_size = agg_type->size > 0 ? agg_type->size : 8;

        Emit(cg, "  %%t%u = alloca [%u x i8]  ; record aggregate\n", base, record_size);

        /* Track initialized components for others clause */
        uint32_t comp_count = agg_type->record.component_count;
        bool *initialized = Arena_Allocate(comp_count * sizeof(bool));
        for (uint32_t i = 0; i < comp_count; i++) initialized[i] = false;

        /* Default value for "others" clause */
        uint32_t others_val = 0;
        bool has_others = false;

        /* First pass: find "others" clause */
        for (uint32_t i = 0; i < node->aggregate.items.count; i++) {
            Syntax_Node *item = node->aggregate.items.items[i];
            if (item->kind == NK_ASSOCIATION && item->association.choices.count > 0) {
                if (Is_Others_Choice(item->association.choices.items[0])) {
                    others_val = Generate_Expression(cg, item->association.expression);
                    has_others = true;
                    break;
                }
            }
        }

        /* Second pass: initialize fields */
        uint32_t positional_idx = 0;
        for (uint32_t i = 0; i < node->aggregate.items.count; i++) {
            Syntax_Node *item = node->aggregate.items.items[i];

            if (item->kind == NK_ASSOCIATION) {
                /* Named association: field_name => value */
                for (uint32_t c = 0; c < item->association.choices.count; c++) {
                    Syntax_Node *choice = item->association.choices.items[c];

                    if (Is_Others_Choice(choice)) {
                        continue;  /* Handle in third pass */
                    }

                    if (choice->kind == NK_IDENTIFIER) {
                        int32_t comp_idx = Find_Record_Component(agg_type, choice->string_val.text);
                        if (comp_idx >= 0) {
                            Component_Info *comp = &agg_type->record.components[comp_idx];
                            Type_Info *comp_ti = comp->component_type;
                            uint32_t val = Generate_Expression(cg, item->association.expression);

                            uint32_t ptr = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n",
                                 ptr, base, comp->byte_offset);

                            if (comp_ti && comp_ti->kind == TYPE_RECORD) {
                                /* Nested record: use memcpy */
                                uint32_t comp_size = comp_ti->size > 0 ? comp_ti->size : 8;
                                Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %u, i1 false)\n",
                                     ptr, val, comp_size);
                            } else {
                                const char *comp_type = Type_To_Llvm(comp_ti);
                                const char *src_type = Expression_Llvm_Type(item->association.expression);
                                val = Emit_Convert(cg, val, src_type, comp_type);
                                Emit(cg, "  store %s %%t%u, ptr %%t%u\n", comp_type, val, ptr);
                            }
                            initialized[comp_idx] = true;
                        }
                    }
                }
            } else {
                /* Positional: initialize component by position */
                if (positional_idx < comp_count) {
                    Component_Info *comp = &agg_type->record.components[positional_idx];
                    Type_Info *comp_ti = comp->component_type;
                    uint32_t val = Generate_Expression(cg, item);

                    uint32_t ptr = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n",
                         ptr, base, comp->byte_offset);

                    if (comp_ti && comp_ti->kind == TYPE_RECORD) {
                        /* Nested record: use memcpy */
                        uint32_t comp_size = comp_ti->size > 0 ? comp_ti->size : 8;
                        Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %u, i1 false)\n",
                             ptr, val, comp_size);
                    } else {
                        const char *comp_type = Type_To_Llvm(comp_ti);
                        const char *src_type = Expression_Llvm_Type(item);
                        val = Emit_Convert(cg, val, src_type, comp_type);
                        Emit(cg, "  store %s %%t%u, ptr %%t%u\n", comp_type, val, ptr);
                    }
                    initialized[positional_idx] = true;
                    positional_idx++;
                }
            }
        }

        /* Third pass: fill uninitialized with "others" value (uncommon for records) */
        if (has_others) {
            for (uint32_t idx = 0; idx < comp_count; idx++) {
                if (!initialized[idx]) {
                    Component_Info *comp = &agg_type->record.components[idx];
                    const char *comp_type = Type_To_Llvm(comp->component_type);
                    uint32_t converted = Emit_Convert(cg, others_val, "i64", comp_type);

                    uint32_t ptr = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n",
                         ptr, base, comp->byte_offset);
                    Emit(cg, "  store %s %%t%u, ptr %%t%u\n", comp_type, converted, ptr);
                }
            }
        }

        return base;
    }

    return 0;
}

static uint32_t Generate_Qualified(Code_Generator *cg, Syntax_Node *node) {
    /* Type'(expression) - generate expression and convert to target type if needed */
    uint32_t result = Generate_Expression(cg, node->qualified.expression);

    /* Get source and destination types */
    Type_Info *src_type = node->qualified.expression ? node->qualified.expression->type : NULL;
    Type_Info *dst_type = node->qualified.subtype_mark ? node->qualified.subtype_mark->type : NULL;

    if (!src_type || !dst_type || src_type == dst_type) {
        return result;
    }

    /* Check if type conversion is needed (e.g., INTEGER to FLOAT) */
    const char *src_llvm = Expression_Llvm_Type(node->qualified.expression);
    const char *dst_llvm = Type_To_Llvm(dst_type);

    if (strcmp(src_llvm, dst_llvm) != 0) {
        result = Emit_Convert(cg, result, src_llvm, dst_llvm);
    }

    return result;
}

static uint32_t Generate_Allocator(Code_Generator *cg, Syntax_Node *node) {
    /* new T or new T'(value) */
    Type_Info *access_type = node->type;  /* The access type being created */

    if (!access_type) {
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = call ptr @malloc(i64 8)\n", t);
        return t;
    }

    /* Check if this access type needs fat pointer representation.
     * Access to unconstrained arrays/STRING always use fat pointers,
     * but also check if the LLVM type is a fat pointer (for constrained
     * subtypes of unconstrained access types). */
    Type_Info *designated = access_type->kind == TYPE_ACCESS ?
                            access_type->access.designated_type : NULL;
    bool is_fat_ptr = designated &&
                      (designated->kind == TYPE_STRING ||
                       (designated->kind == TYPE_ARRAY && !designated->array.is_constrained));

    /* Also check if the designated array type's base type is unconstrained.
     * This handles cases like NEW ARR(bounds) where bounds makes a constrained
     * subtype of an unconstrained array - we still need a fat pointer. */
    if (!is_fat_ptr && designated && designated->kind == TYPE_ARRAY &&
        designated->array.is_constrained) {
        /* Check if the array's base type is unconstrained */
        Type_Info *arr_base = designated->base_type;
        while (arr_base) {
            if (arr_base->kind == TYPE_ARRAY && !arr_base->array.is_constrained) {
                is_fat_ptr = true;
                break;
            }
            arr_base = arr_base->base_type;
        }
    }

    if (is_fat_ptr && node->allocator.expression) {
        /* Access to unconstrained array with initializer */
        Type_Info *init_type = node->allocator.expression->type;

        /* Check what LLVM type the expression actually returns.
         * Constrained array aggregates return ptr, unconstrained return fat pointer.
         * For qualified expressions, look at the inner expression. */
        Syntax_Node *inner_expr = node->allocator.expression;
        if (inner_expr->kind == NK_QUALIFIED && inner_expr->qualified.expression) {
            inner_expr = inner_expr->qualified.expression;
        }
        const char *expr_llvm_type = Expression_Llvm_Type(inner_expr);
        bool init_returns_ptr = strcmp(expr_llvm_type, "ptr") == 0;

        /* Also check if the aggregate is constrained */
        Type_Info *agg_type = inner_expr->type;
        if (!agg_type && inner_expr->kind == NK_AGGREGATE) {
            agg_type = node->allocator.expression->type;  /* Use outer type */
        }
        bool init_is_constrained = agg_type && agg_type->kind == TYPE_ARRAY &&
                                   agg_type->array.is_constrained;

        uint32_t init_val = Generate_Expression(cg, node->allocator.expression);

        uint32_t src_data, low_t, high_t, len_t;

        if (init_returns_ptr || init_is_constrained) {
            /* Constrained array initializer: returns ptr, not fat pointer.
             * Extract bounds from the type and use the ptr directly. */
            src_data = init_val;  /* Already a pointer to array data */

            /* Get bounds from the constrained type */
            if (init_type->array.index_count > 0 &&
                init_type->array.indices[0].low_bound.kind == BOUND_INTEGER &&
                init_type->array.indices[0].high_bound.kind == BOUND_INTEGER) {
                int64_t lo = init_type->array.indices[0].low_bound.int_value;
                int64_t hi = init_type->array.indices[0].high_bound.int_value;
                low_t = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", low_t, (long long)lo);
                high_t = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", high_t, (long long)hi);
                len_t = Emit_Temp(cg);
                int64_t length = hi - lo + 1;
                uint32_t elem_size = init_type->array.element_type ?
                                     init_type->array.element_type->size : 1;
                if (elem_size == 0) elem_size = 1;
                Emit(cg, "  %%t%u = add i64 0, %lld\n", len_t, (long long)(length * elem_size));
            } else {
                /* Dynamic bounds - use 1-based defaults */
                low_t = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 1\n", low_t);
                high_t = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 1\n", high_t);
                len_t = Emit_Temp(cg);
                uint32_t elem_size = init_type->array.element_type ?
                                     init_type->array.element_type->size : 1;
                if (elem_size == 0) elem_size = 8;
                Emit(cg, "  %%t%u = add i64 0, %u\n", len_t, elem_size);
            }
        } else {
            /* Unconstrained array or string: returns fat pointer VALUE */
            src_data = Emit_Fat_Pointer_Data(cg, init_val);
            low_t = Emit_Fat_Pointer_Low(cg, init_val);
            high_t = Emit_Fat_Pointer_High(cg, init_val);
            len_t = Emit_Fat_Pointer_Length(cg, init_val);
        }

        /* Allocate heap space for array data */
        uint32_t heap_ptr = Emit_Temp(cg);
        Emit(cg, "  %%t%u = call ptr @malloc(i64 %%t%u)\n", heap_ptr, len_t);

        /* Copy data: memcpy(heap_ptr, src_data, length) */
        Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %%t%u, i1 false)\n",
             heap_ptr, src_data, len_t);

        /* Build result fat pointer with allocated data */
        return Emit_Fat_Pointer_Dynamic(cg, heap_ptr, low_t, high_t);
    }

    /* Handle NEW T(bounds) without initializer - allocate unconstrained array */
    if (is_fat_ptr && !node->allocator.expression && node->allocator.subtype_mark) {
        /* Get bounds from the subtype mark's type */
        Type_Info *subtype = node->allocator.subtype_mark->type;
        if (subtype && subtype->kind == TYPE_ARRAY && subtype->array.index_count > 0) {
            /* Generate bound values */
            uint32_t low_t, high_t;

            if (subtype->array.indices[0].low_bound.kind == BOUND_INTEGER) {
                low_t = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", low_t,
                     (long long)subtype->array.indices[0].low_bound.int_value);
            } else if (subtype->array.indices[0].low_bound.kind == BOUND_EXPR &&
                       subtype->array.indices[0].low_bound.expr) {
                Syntax_Node *low_expr = subtype->array.indices[0].low_bound.expr;
                low_t = Generate_Expression(cg, low_expr);
                /* Extend to i64 if narrower type (e.g., ENUM bounds return i8) */
                const char *low_llvm = Expression_Llvm_Type(low_expr);
                if (strcmp(low_llvm, "i64") != 0 && strcmp(low_llvm, "ptr") != 0 &&
                    strcmp(low_llvm, "double") != 0 && strcmp(low_llvm, "float") != 0) {
                    low_t = Emit_Convert(cg, low_t, low_llvm, "i64");
                }
            } else {
                low_t = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 1\n", low_t);
            }

            if (subtype->array.indices[0].high_bound.kind == BOUND_INTEGER) {
                high_t = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", high_t,
                     (long long)subtype->array.indices[0].high_bound.int_value);
            } else if (subtype->array.indices[0].high_bound.kind == BOUND_EXPR &&
                       subtype->array.indices[0].high_bound.expr) {
                Syntax_Node *high_expr = subtype->array.indices[0].high_bound.expr;
                high_t = Generate_Expression(cg, high_expr);
                /* Extend to i64 if narrower type (e.g., ENUM bounds return i8) */
                const char *high_llvm = Expression_Llvm_Type(high_expr);
                if (strcmp(high_llvm, "i64") != 0 && strcmp(high_llvm, "ptr") != 0 &&
                    strcmp(high_llvm, "double") != 0 && strcmp(high_llvm, "float") != 0) {
                    high_t = Emit_Convert(cg, high_t, high_llvm, "i64");
                }
            } else {
                high_t = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 1\n", high_t);
            }

            /* Calculate size: (high - low + 1) * elem_size */
            uint32_t elem_size = subtype->array.element_type ?
                                 subtype->array.element_type->size : 8;
            if (elem_size == 0) elem_size = 8;

            uint32_t len_t = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", len_t, high_t, low_t);
            uint32_t len_plus1 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", len_plus1, len_t);
            uint32_t byte_size = Emit_Temp(cg);
            Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_size, len_plus1, elem_size);

            /* Allocate heap space */
            uint32_t heap_ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = call ptr @malloc(i64 %%t%u)\n", heap_ptr, byte_size);

            /* Return fat pointer with bounds */
            return Emit_Fat_Pointer_Dynamic(cg, heap_ptr, low_t, high_t);
        }
    }

    /* Simple allocation (constrained types or no initializer) */
    uint64_t size = access_type->size > 0 ? access_type->size : 8;
    uint32_t t = Emit_Temp(cg);
    Emit(cg, "  %%t%u = call ptr @malloc(i64 %llu)\n", t, (unsigned long long)size);

    /* If there's an initializer, store it */
    if (node->allocator.expression) {
        uint32_t val = Generate_Expression(cg, node->allocator.expression);
        Emit(cg, "  store %s %%t%u, ptr %%t%u\n", Type_To_Llvm(access_type), val, t);
    }

    return t;
}

static uint32_t Generate_Expression(Code_Generator *cg, Syntax_Node *node) {
    if (!node) return 0;

    switch (node->kind) {
        case NK_INTEGER:    return Generate_Integer_Literal(cg, node);
        case NK_REAL:       return Generate_Real_Literal(cg, node);
        case NK_STRING:     return Generate_String_Literal(cg, node);
        case NK_CHARACTER:  {   /* Character literal - extract char from text "'X'" */
                             uint32_t t = Emit_Temp(cg);
                             int64_t ch = 0;
                             /* Check if resolved as enumeration literal */
                             if (node->symbol && node->symbol->kind == SYMBOL_LITERAL) {
                                 ch = node->symbol->frame_offset;
                             } else if (node->string_val.text.length >= 2) {
                                 ch = (unsigned char)node->string_val.text.data[1];
                             }
                             Emit(cg, "  %%t%u = add i64 0, %lld\n", t, (long long)ch);
                             return t; }
        case NK_NULL:       { uint32_t t = Emit_Temp(cg);
                             Emit(cg, "  %%t%u = inttoptr i64 0 to ptr\n", t);
                             return t; }
        case NK_IDENTIFIER: return Generate_Identifier(cg, node);
        case NK_SELECTED:   return Generate_Selected(cg, node);
        case NK_ATTRIBUTE:  return Generate_Attribute(cg, node);
        case NK_BINARY_OP:  return Generate_Binary_Op(cg, node);
        case NK_UNARY_OP:   return Generate_Unary_Op(cg, node);
        case NK_APPLY:      return Generate_Apply(cg, node);
        case NK_AGGREGATE:  return Generate_Aggregate(cg, node);
        case NK_QUALIFIED:  return Generate_Qualified(cg, node);
        case NK_ALLOCATOR:  return Generate_Allocator(cg, node);

        default:
            Report_Error(node->location, "unsupported expression kind in codegen");
            return 0;
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.4 Statement Code Generation
 *
 * Statements modify state while expressions compute values, a distinction Ada enforces.
 * ───────────────────────────────────────────────────────────────────────── */

static void Generate_Statement(Code_Generator *cg, Syntax_Node *node);

static void Generate_Statement_List(Code_Generator *cg, Node_List *list) {
    for (uint32_t i = 0; i < list->count; i++) {
        Syntax_Node *stmt = list->items[i];
        if (!stmt) continue;

        /* After a terminator (ret/br), we need a new basic block.
         * Labeled statements (NK_LABEL, NK_BLOCK with label, NK_LOOP with label)
         * emit their own labels. For unlabeled statements, emit a fresh label. */
        if (cg->block_terminated) {
            bool will_emit_label = stmt->kind == NK_LABEL ||
                (stmt->kind == NK_BLOCK && stmt->block_stmt.label_symbol) ||
                (stmt->kind == NK_LOOP && stmt->loop_stmt.label_symbol);
            if (!will_emit_label) {
                /* Emit a fresh basic block for unreachable code. The subsequent
                 * statement will generate instructions that fill this block. */
                uint32_t dead_label = cg->label_id++;
                Emit(cg, "L%u:\n", dead_label);
                cg->block_terminated = false;
            } else {
                /* The next statement emits its own label - reset block_terminated
                 * so it adds an instruction to its label block properly */
                cg->block_terminated = false;
            }
        }

        Generate_Statement(cg, stmt);
    }
}

static void Generate_Assignment(Code_Generator *cg, Syntax_Node *node) {
    Syntax_Node *target = node->assignment.target;

    /* For RENAMES: redirect to the renamed object */
    if (target->kind == NK_IDENTIFIER && target->symbol && target->symbol->renamed_object) {
        target = target->symbol->renamed_object;
    }

    /* Handle indexed component target (array element or slice assignment) */
    if (target->kind == NK_APPLY) {
        Type_Info *prefix_type = target->apply.prefix->type;
        if (prefix_type && prefix_type->kind == TYPE_ARRAY) {
            Symbol *array_sym = target->apply.prefix->symbol;
            if (!array_sym) return;

            Syntax_Node *arg = target->apply.arguments.items[0];

            /* Check for slice assignment: ARR(low .. high) := source */
            if (arg->kind == NK_RANGE) {
                /* Array slice assignment using memcpy */
                int64_t low_bound = Array_Low_Bound(prefix_type);
                Type_Info *elem_type = prefix_type->array.element_type;
                uint32_t elem_size = elem_type ? elem_type->size : 1;
                if (elem_size == 0) elem_size = 1;

                /* Get destination base address */
                /* Check for uplevel (outer scope) access */
                Symbol *dest_owner = array_sym->defining_scope ? array_sym->defining_scope->owner : NULL;
                bool dest_is_uplevel = cg->current_function && dest_owner &&
                                       dest_owner != cg->current_function &&
                                       dest_owner != cg->current_function->generic_template;
                uint32_t dest_base = Emit_Temp(cg);
                Emit(cg, "  %%t%u = getelementptr i8, ptr ", dest_base);
                if (dest_is_uplevel && cg->is_nested) {
                    Emit(cg, "%%__frame.");
                    Emit_Symbol_Name(cg, array_sym);
                } else {
                    Emit_Symbol_Ref(cg, array_sym);
                }
                Emit(cg, ", i64 0\n");

                /* Calculate destination start offset from slice low bound */
                uint32_t dest_low = Generate_Expression(cg, arg->range.low);
                if (low_bound != 0) {
                    uint32_t adj = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = sub i64 %%t%u, %lld\n", adj, dest_low, (long long)low_bound);
                    dest_low = adj;
                }
                uint32_t dest_ptr = Emit_Temp(cg);
                Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n",
                     dest_ptr, dest_base, dest_low);

                /* Generate source slice (also NK_APPLY with NK_RANGE) */
                Syntax_Node *src = node->assignment.value;
                if (src->kind == NK_APPLY && src->apply.arguments.count > 0 &&
                    src->apply.arguments.items[0]->kind == NK_RANGE) {
                    Symbol *src_sym = src->apply.prefix->symbol;
                    Type_Info *src_type = src->apply.prefix->type;
                    Syntax_Node *src_range = src->apply.arguments.items[0];

                    if (src_sym && src_type && src_type->kind == TYPE_ARRAY) {
                        int64_t src_low_bound = Array_Low_Bound(src_type);

                        /* Get source base address */
                        /* Check for uplevel (outer scope) access */
                        Symbol *src_owner = src_sym->defining_scope ? src_sym->defining_scope->owner : NULL;
                        bool src_is_uplevel = cg->current_function && src_owner &&
                                              src_owner != cg->current_function &&
                                              src_owner != cg->current_function->generic_template;
                        uint32_t src_base = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = getelementptr i8, ptr ", src_base);
                        if (src_is_uplevel && cg->is_nested) {
                            Emit(cg, "%%__frame.");
                            Emit_Symbol_Name(cg, src_sym);
                        } else {
                            Emit_Symbol_Ref(cg, src_sym);
                        }
                        Emit(cg, ", i64 0\n");

                        /* Calculate source start offset */
                        uint32_t src_start = Generate_Expression(cg, src_range->range.low);
                        if (src_low_bound != 0) {
                            uint32_t adj = Emit_Temp(cg);
                            Emit(cg, "  %%t%u = sub i64 %%t%u, %lld\n", adj, src_start, (long long)src_low_bound);
                            src_start = adj;
                        }
                        uint32_t src_ptr = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %%t%u\n",
                             src_ptr, src_base, src_start);

                        /* Calculate copy length in bytes */
                        uint32_t dest_high = Generate_Expression(cg, arg->range.high);
                        uint32_t length = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", length, dest_high, dest_low);
                        uint32_t len_plus_one = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", len_plus_one, length);
                        uint32_t byte_len = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_len, len_plus_one, elem_size);

                        /* memcpy from source to dest */
                        Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%t%u, ptr %%t%u, i64 %%t%u, i1 false)  ; slice assignment\n",
                             dest_ptr, src_ptr, byte_len);
                        return;
                    }
                }
                return;  /* Unsupported source for slice assignment */
            }

            /* Array element assignment: DATA(I) := value */
            /* Get array base address (not loaded value) */
            /* Check for uplevel (outer scope) access */
            Symbol *elem_owner = array_sym->defining_scope ? array_sym->defining_scope->owner : NULL;
            bool elem_is_uplevel = cg->current_function && elem_owner &&
                                   elem_owner != cg->current_function &&
                                   elem_owner != cg->current_function->generic_template;
            uint32_t base = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr i8, ptr ", base);
            if (elem_is_uplevel && cg->is_nested) {
                Emit(cg, "%%__frame.");
                Emit_Symbol_Name(cg, array_sym);
            } else {
                Emit_Symbol_Ref(cg, array_sym);
            }
            Emit(cg, ", i64 0\n");

            /* Generate index expression */
            uint32_t idx = Generate_Expression(cg, arg);

            /* Adjust for array low bound (Ada arrays can start at any index) */
            int64_t low_bound = Array_Low_Bound(prefix_type);
            if (low_bound != 0) {
                uint32_t adj = Emit_Temp(cg);
                Emit(cg, "  %%t%u = sub i64 %%t%u, %lld\n", adj, idx, (long long)low_bound);
                idx = adj;
            }

            /* Get pointer to element */
            const char *elem_type_str = Type_To_Llvm(prefix_type->array.element_type);
            uint32_t ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr %s, ptr %%t%u, i64 %%t%u\n",
                 ptr, elem_type_str, base, idx);

            /* Generate value and store */
            uint32_t value = Generate_Expression(cg, node->assignment.value);
            const char *value_type = Expression_Llvm_Type(node->assignment.value);
            value = Emit_Convert(cg, value, value_type, elem_type_str);
            Emit(cg, "  store %s %%t%u, ptr %%t%u\n", elem_type_str, value, ptr);
            return;
        }
    }

    /* Handle .ALL dereference assignment (NK_UNARY_OP with TK_ALL) */
    if (target->kind == NK_UNARY_OP && target->unary.op == TK_ALL) {
        Syntax_Node *operand = target->unary.operand;
        Type_Info *operand_type = operand->type;

        if (operand_type && operand_type->kind == TYPE_ACCESS) {
            Type_Info *designated = operand_type->access.designated_type;
            const char *dest_type = Type_To_Llvm(designated);

            /* Get the pointer value */
            uint32_t ptr = Generate_Expression(cg, operand);

            /* Generate value and store through the pointer */
            uint32_t value = Generate_Expression(cg, node->assignment.value);
            const char *value_type = Expression_Llvm_Type(node->assignment.value);
            value = Emit_Convert(cg, value, value_type, dest_type);
            Emit(cg, "  store %s %%t%u, ptr %%t%u  ; .ALL assignment\n",
                 dest_type, value, ptr);
            return;
        }
    }

    /* Handle selected component target (record field assignment or .ALL) */
    if (target->kind == NK_SELECTED) {
        Syntax_Node *prefix = target->selected.prefix;
        Type_Info *prefix_type = prefix->type;

        /* Handle explicit .ALL dereference assignment */
        if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
            Slice_Equal_Ignore_Case(target->selected.selector, S("ALL"))) {
            Type_Info *designated = prefix_type->access.designated_type;
            Symbol *access_sym = prefix->symbol;
            const char *dest_type = Type_To_Llvm(designated);

            /* Load the access pointer value */
            uint32_t ptr;
            if (access_sym) {
                ptr = Emit_Temp(cg);
                Emit(cg, "  %%t%u = load ptr, ptr ", ptr);
                Emit_Symbol_Ref(cg, access_sym);
                Emit(cg, "  ; load access for .ALL assignment\n");
            } else {
                ptr = Generate_Expression(cg, prefix);
            }

            /* Generate value and store through the pointer */
            uint32_t value = Generate_Expression(cg, node->assignment.value);
            const char *value_type = Expression_Llvm_Type(node->assignment.value);
            value = Emit_Convert(cg, value, value_type, dest_type);
            Emit(cg, "  store %s %%t%u, ptr %%t%u  ; store via .ALL\n", dest_type, value, ptr);
            return;
        }

        /* Determine effective record type (handle implicit dereference) */
        Type_Info *record_type = prefix_type;
        bool implicit_deref = false;
        if (prefix_type && prefix_type->kind == TYPE_ACCESS &&
            prefix_type->access.designated_type &&
            prefix_type->access.designated_type->kind == TYPE_RECORD) {
            record_type = prefix_type->access.designated_type;
            implicit_deref = true;
        }

        if (record_type && record_type->kind == TYPE_RECORD) {
            /* Find component offset */
            uint32_t offset = 0;
            Type_Info *comp_type = NULL;
            for (uint32_t i = 0; i < record_type->record.component_count; i++) {
                if (Slice_Equal_Ignore_Case(record_type->record.components[i].name,
                                            target->selected.selector)) {
                    offset = record_type->record.components[i].byte_offset;
                    comp_type = record_type->record.components[i].component_type;
                    break;
                }
            }

            const char *comp_llvm_type = Type_To_Llvm(comp_type);

            /* Get base address of record */
            Symbol *record_sym = prefix->symbol;
            uint32_t base_ptr;

            if (implicit_deref) {
                /* Load access value to get record pointer */
                if (record_sym) {
                    base_ptr = Emit_Temp(cg);
                    /* Check for uplevel access (variable in outer scope) */
                    Symbol *var_owner = record_sym->defining_scope
                                       ? record_sym->defining_scope->owner : NULL;
                    bool is_uplevel = cg->current_function && var_owner &&
                                      var_owner != cg->current_function &&
                                      var_owner != cg->current_function->generic_template;
                    if (is_uplevel && cg->is_nested) {
                        Emit(cg, "  %%t%u = load ptr, ptr %%__frame.", base_ptr);
                        Emit_Symbol_Name(cg, record_sym);
                        Emit(cg, "  ; uplevel implicit deref for field assignment\n");
                    } else {
                        Emit(cg, "  %%t%u = load ptr, ptr ", base_ptr);
                        Emit_Symbol_Ref(cg, record_sym);
                        Emit(cg, "  ; implicit deref for field assignment\n");
                    }
                } else {
                    base_ptr = Generate_Expression(cg, prefix);
                }
            } else {
                if (!record_sym) return;
                base_ptr = Emit_Temp(cg);
                Emit(cg, "  %%t%u = getelementptr i8, ptr ", base_ptr);
                Emit_Symbol_Ref(cg, record_sym);
                Emit(cg, ", i64 0\n");
            }

            /* Calculate address of field */
            uint32_t field_ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr i8, ptr %%t%u, i64 %u\n",
                 field_ptr, base_ptr, offset);

            /* Generate value and store */
            uint32_t value = Generate_Expression(cg, node->assignment.value);
            const char *value_type = Expression_Llvm_Type(node->assignment.value);
            value = Emit_Convert(cg, value, value_type, comp_llvm_type);
            Emit(cg, "  store %s %%t%u, ptr %%t%u\n", comp_llvm_type, value, field_ptr);
            return;
        }
    }

    /* Simple variable target */
    Symbol *target_sym = target->symbol;
    if (!target_sym) return;

    Type_Info *ty = target_sym->type;

    /* Substitute generic formal types with actual types in generic instances */
    if (cg->current_instance && cg->current_instance->generic_actuals && ty && ty->name.data) {
        for (uint32_t k = 0; k < cg->current_instance->generic_actual_count; k++) {
            if (Slice_Equal_Ignore_Case(ty->name,
                    cg->current_instance->generic_actuals[k].formal_name) &&
                cg->current_instance->generic_actuals[k].actual_type) {
                ty = cg->current_instance->generic_actuals[k].actual_type;
                break;
            }
        }
    }

    /* Handle record assignment (use memcpy, not store) */
    if (ty && ty->kind == TYPE_RECORD) {
        uint32_t src_ptr = Generate_Expression(cg, node->assignment.value);
        uint32_t record_size = ty->size > 0 ? ty->size : 8;
        Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr ");
        Emit_Symbol_Ref(cg, target_sym);
        Emit(cg, ", ptr %%t%u, i64 %u, i1 false)  ; record assignment\n",
             src_ptr, record_size);
        return;
    }

    /* Handle constrained array assignment (use memcpy, not store) */
    if (ty && ty->kind == TYPE_ARRAY && ty->array.is_constrained) {
        /* Check if source is unconstrained (fat pointer) or constrained (ptr) */
        Type_Info *src_type = node->assignment.value->type;
        bool src_is_fat_ptr = (src_type && src_type->kind == TYPE_STRING) ||
                              (src_type && src_type->kind == TYPE_ARRAY && !src_type->array.is_constrained) ||
                              (node->assignment.value->kind == NK_STRING);
        /* Also check if source is an identifier of constrained char array (generates fat ptr) */
        if (!src_is_fat_ptr && node->assignment.value->kind == NK_IDENTIFIER &&
            src_type && src_type->kind == TYPE_ARRAY && src_type->array.is_constrained &&
            src_type->array.element_type && src_type->array.element_type->kind == TYPE_CHARACTER) {
            src_is_fat_ptr = true;
        }
        /* Concatenation always returns fat pointer */
        if (!src_is_fat_ptr && node->assignment.value->kind == NK_BINARY_OP &&
            node->assignment.value->binary.op == TK_AMPERSAND) {
            src_is_fat_ptr = true;
        }
        uint32_t src_ptr = Generate_Expression(cg, node->assignment.value);
        if (src_is_fat_ptr) {
            /* Source is unconstrained/string - extract data pointer from fat pointer */
            Emit_Fat_Pointer_Copy_To_Name(cg, src_ptr, target_sym);
        } else {
            /* Source is constrained - memcpy directly */
            uint32_t array_size = ty->size > 0 ? ty->size : 8;
            Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr ");
            Emit_Symbol_Ref(cg, target_sym);
            Emit(cg, ", ptr %%t%u, i64 %u, i1 false)  ; array assignment\n",
                 src_ptr, array_size);
        }
        return;
    }

    uint32_t value = Generate_Expression(cg, node->assignment.value);

    /* Check if this is an uplevel (outer scope) variable access.
     * For generic instances, the variable's owner is the template. */
    Symbol *var_owner = target_sym->defining_scope ? target_sym->defining_scope->owner : NULL;
    bool is_uplevel = cg->current_function && var_owner &&
                      var_owner != cg->current_function &&
                      var_owner != cg->current_function->generic_template;

    const char *type_str = Type_To_Llvm(ty);

    /* Determine source type from the value expression */
    Type_Info *value_type = node->assignment.value->type;
    bool is_src_float = value_type && (value_type->kind == TYPE_FLOAT ||
                                        value_type->kind == TYPE_UNIVERSAL_REAL);
    bool is_dst_float = ty && (ty->kind == TYPE_FLOAT ||
                               ty->kind == TYPE_UNIVERSAL_REAL);

    /* Convert between float and integer if needed */
    if (is_src_float && !is_dst_float) {
        /* Float to integer: use fptosi. For fixed-point targets, divide by
         * SMALL first to get the scaled integer representation (RM 4.5.5) */
        if (ty && ty->kind == TYPE_FIXED) {
            double small = ty->fixed.small;
            if (small <= 0) small = ty->fixed.delta > 0 ? ty->fixed.delta : 1.0;
            uint64_t bits; memcpy(&bits, &small, sizeof(bits));
            uint32_t small_t = Emit_Temp(cg);
            Emit(cg, "  %%t%u = fadd double 0.0, 0x%016llX  ; small=%g\n",
                 small_t, (unsigned long long)bits, small);
            uint32_t div_t = Emit_Temp(cg);
            Emit(cg, "  %%t%u = fdiv double %%t%u, %%t%u\n", div_t, value, small_t);
            value = div_t;
        }
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = fptosi double %%t%u to %s\n", t, value, type_str);
        value = t;
    } else if (!is_src_float && is_dst_float) {
        /* Integer to float: use sitofp */
        uint32_t t = Emit_Temp(cg);
        Emit(cg, "  %%t%u = sitofp i64 %%t%u to double\n", t, value);
        value = t;
    } else if (is_src_float && is_dst_float) {
        /* Float to float: may need conversion if sizes differ
         * Source expressions generate double, target may be float (32-bit) */
        const char *src_ftype = "double";  /* expression result is always double */
        const char *dst_ftype = type_str;  /* actual storage type */
        if (strcmp(src_ftype, dst_ftype) != 0) {
            value = Emit_Convert(cg, value, src_ftype, dst_ftype);
        }
    } else {
        /* Integer/boolean to target type: use actual expression type */
        const char *src_type_str = Expression_Llvm_Type(node->assignment.value);
        value = Emit_Convert(cg, value, src_type_str, type_str);
    }

    if (is_uplevel && cg->is_nested) {
        /* Uplevel store through frame pointer */
        Emit(cg, "  ; UPLEVEL STORE: %.*s via frame pointer\n",
             (int)target_sym->name.length, target_sym->name.data);
        Emit(cg, "  store %s %%t%u, ptr %%__frame.", type_str, value);
        Emit_Symbol_Name(cg, target_sym);
        Emit(cg, "\n");
    } else {
        Emit(cg, "  store %s %%t%u, ptr ", type_str, value);
        Emit_Symbol_Ref(cg, target_sym);
        Emit(cg, "\n");
    }
}

static void Generate_If_Statement(Code_Generator *cg, Syntax_Node *node) {
    uint32_t cond = Generate_Expression(cg, node->if_stmt.condition);
    uint32_t then_label = Emit_Label(cg);
    uint32_t else_label = Emit_Label(cg);
    uint32_t end_label = Emit_Label(cg);

    /* Convert condition to i1 for branch (use actual expression type) */
    const char *cond_type = Expression_Llvm_Type(node->if_stmt.condition);
    cond = Emit_Convert(cg, cond, cond_type, "i1");
    Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cond, then_label, else_label);
    cg->block_terminated = true;

    Emit_Label_Here(cg, then_label);
    Generate_Statement_List(cg, &node->if_stmt.then_stmts);
    Emit_Branch_If_Needed(cg, end_label);

    Emit_Label_Here(cg, else_label);
    if (node->if_stmt.else_stmts.count > 0) {
        Generate_Statement_List(cg, &node->if_stmt.else_stmts);
    }
    Emit_Branch_If_Needed(cg, end_label);

    Emit_Label_Here(cg, end_label);
}

static void Generate_Loop_Statement(Code_Generator *cg, Syntax_Node *node) {
    /* Emit LLVM label for Ada label (enables GOTO targeting this loop) */
    Symbol *label_sym = node->loop_stmt.label_symbol;
    if (label_sym) {
        if (label_sym->llvm_label_id == 0)
            label_sym->llvm_label_id = cg->label_id++;
        if (!cg->block_terminated)
            Emit(cg, "  br label %%L%u\n", label_sym->llvm_label_id);
        Emit(cg, "L%u:  ; %.*s\n", label_sym->llvm_label_id,
             (int)node->loop_stmt.label.length, node->loop_stmt.label.data);
        cg->block_terminated = false;  /* New block started */
    }

    uint32_t loop_start = Emit_Label(cg);
    uint32_t loop_body = Emit_Label(cg);
    uint32_t loop_end = Emit_Label(cg);

    uint32_t saved_exit = cg->loop_exit_label;
    uint32_t saved_cont = cg->loop_continue_label;
    cg->loop_exit_label = loop_end;
    cg->loop_continue_label = loop_start;

    Emit_Branch_If_Needed(cg, loop_start);
    Emit_Label_Here(cg, loop_start);

    /* Condition check for WHILE loops */
    if (node->loop_stmt.iteration_scheme &&
        node->loop_stmt.iteration_scheme->kind != NK_BINARY_OP) {
        /* WHILE loop */
        Syntax_Node *scheme = node->loop_stmt.iteration_scheme;
        uint32_t cond = Generate_Expression(cg, scheme);
        const char *cond_type = Expression_Llvm_Type(scheme);
        cond = Emit_Convert(cg, cond, cond_type, "i1");
        Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cond, loop_body, loop_end);
        cg->block_terminated = true;
    } else {
        Emit_Branch_If_Needed(cg, loop_body);
    }

    Emit_Label_Here(cg, loop_body);
    Generate_Statement_List(cg, &node->loop_stmt.statements);
    Emit_Branch_If_Needed(cg, loop_start);

    Emit_Label_Here(cg, loop_end);

    cg->loop_exit_label = saved_exit;
    cg->loop_continue_label = saved_cont;
}

static void Generate_Return_Statement(Code_Generator *cg, Syntax_Node *node) {
    cg->has_return = true;
    cg->block_terminated = true;  /* ret is a terminator */
    if (node->return_stmt.expression) {
        Syntax_Node *expr = node->return_stmt.expression;
        uint32_t value = Generate_Expression(cg, expr);
        const char *type_str = cg->current_function && cg->current_function->return_type
            ? Type_To_Llvm(cg->current_function->return_type) : "i64";
        /* Convert from expression type to return type */
        const char *expr_type = Expression_Llvm_Type(expr);
        value = Emit_Convert(cg, value, expr_type, type_str);
        Emit(cg, "  ret %s %%t%u\n", type_str, value);
    } else {
        Emit(cg, "  ret void\n");
    }
}

static void Generate_Case_Statement(Code_Generator *cg, Syntax_Node *node) {
    /* CASE expr IS WHEN choice => stmts; ... END CASE; */
    uint32_t selector = Generate_Expression(cg, node->case_stmt.expression);
    uint32_t end_label = Emit_Label(cg);

    /* Generate switch-like structure using branches */
    uint32_t num_alts = node->case_stmt.alternatives.count;
    uint32_t *alt_labels = Arena_Allocate(num_alts * sizeof(uint32_t));

    /* Allocate labels for each alternative */
    for (uint32_t i = 0; i < num_alts; i++) {
        alt_labels[i] = Emit_Label(cg);
    }

    /* Generate branching logic */
    for (uint32_t i = 0; i < num_alts; i++) {
        Syntax_Node *alt = node->case_stmt.alternatives.items[i];
        uint32_t next_check = (i + 1 < num_alts) ? Emit_Label(cg) : end_label;

        /* Check each choice in this alternative */
        for (uint32_t j = 0; j < alt->association.choices.count; j++) {
            Syntax_Node *choice = alt->association.choices.items[j];

            if (choice->kind == NK_OTHERS) {
                /* OTHERS matches everything - jump to alternative */
                Emit(cg, "  br label %%L%u\n", alt_labels[i]);
            } else if (choice->kind == NK_RANGE) {
                /* Range check: low <= selector <= high */
                uint32_t low = Generate_Expression(cg, choice->range.low);
                uint32_t high = Generate_Expression(cg, choice->range.high);
                uint32_t cmp1 = Emit_Temp(cg);
                uint32_t cmp2 = Emit_Temp(cg);
                uint32_t both = Emit_Temp(cg);

                Emit(cg, "  %%t%u = icmp sle i64 %%t%u, %%t%u\n", cmp1, low, selector);
                Emit(cg, "  %%t%u = icmp sle i64 %%t%u, %%t%u\n", cmp2, selector, high);
                Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", both, cmp1, cmp2);

                uint32_t next_choice = (j + 1 < alt->association.choices.count) ?
                                       Emit_Label(cg) : next_check;
                Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
                     both, alt_labels[i], next_choice);

                if (j + 1 < alt->association.choices.count) {
                    Emit(cg, "L%u:\n", next_choice);
                }
            } else {
                /* Single value check */
                uint32_t val = Generate_Expression(cg, choice);
                uint32_t cmp = Emit_Temp(cg);

                Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n", cmp, selector, val);

                uint32_t next_choice = (j + 1 < alt->association.choices.count) ?
                                       Emit_Label(cg) : next_check;
                Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
                     cmp, alt_labels[i], next_choice);

                if (j + 1 < alt->association.choices.count) {
                    Emit(cg, "L%u:\n", next_choice);
                }
            }
        }

        if (i + 1 < num_alts) {
            Emit(cg, "L%u:\n", next_check);
        }
    }

    /* Generate alternative bodies - expression is a block with statements */
    for (uint32_t i = 0; i < num_alts; i++) {
        Syntax_Node *alt = node->case_stmt.alternatives.items[i];
        Emit_Label_Here(cg, alt_labels[i]);
        if (alt->association.expression &&
            alt->association.expression->kind == NK_BLOCK) {
            Generate_Statement_List(cg, &alt->association.expression->block_stmt.statements);
        }
        Emit_Branch_If_Needed(cg, end_label);
    }

    Emit_Label_Here(cg, end_label);
}

static void Generate_For_Loop(Code_Generator *cg, Syntax_Node *node) {
    /* FOR loop with iteration variable - iteration_scheme is NK_BINARY_OP TK_IN */
    Syntax_Node *iter = node->loop_stmt.iteration_scheme;
    if (!iter || iter->kind != NK_BINARY_OP || iter->binary.op != TK_IN) {
        /* Not a FOR loop - fall back to simple loop */
        return;
    }

    Syntax_Node *loop_id = iter->binary.left;
    Syntax_Node *range = iter->binary.right;
    Symbol *loop_var = loop_id->symbol;
    bool is_reverse = node->loop_stmt.is_reverse;

    uint32_t loop_start = Emit_Label(cg);
    uint32_t loop_body = Emit_Label(cg);
    uint32_t loop_end = Emit_Label(cg);

    uint32_t saved_exit = cg->loop_exit_label;
    cg->loop_exit_label = loop_end;

    /* Allocate loop variable if we have a symbol */
    if (loop_var) {
        Emit(cg, "  %%");
        Emit_Symbol_Name(cg, loop_var);
        Emit(cg, " = alloca i64\n");
    }

    /* Get range bounds */
    uint32_t low_val, high_val;
    if (range && range->kind == NK_RANGE) {
        low_val = Generate_Expression(cg, range->range.low);
        high_val = Generate_Expression(cg, range->range.high);
    } else if (range && range->kind == NK_ATTRIBUTE &&
               Slice_Equal_Ignore_Case(range->attribute.name, S("RANGE"))) {
        /* X'RANGE attribute - need to generate both 'FIRST and 'LAST */
        Type_Info *prefix_type = range->attribute.prefix->type;
        Symbol *prefix_sym = range->attribute.prefix->symbol;

        /* Check if this is an unconstrained array needing runtime bounds */
        if (prefix_type && Type_Is_Unconstrained_Array(prefix_type) &&
            prefix_sym && (prefix_sym->kind == SYMBOL_PARAMETER ||
                           prefix_sym->kind == SYMBOL_VARIABLE)) {
            uint32_t fat = Emit_Load_Fat_Pointer(cg, prefix_sym);
            low_val = Emit_Fat_Pointer_Low(cg, fat);
            high_val = Emit_Fat_Pointer_High(cg, fat);
        } else if (prefix_type && (prefix_type->kind == TYPE_ARRAY ||
                                   prefix_type->kind == TYPE_STRING)) {
            /* Constrained array - use compile-time bounds */
            Syntax_Node *range_arg = range->attribute.arguments.count > 0
                                   ? range->attribute.arguments.items[0] : NULL;
            uint32_t dim = Get_Dimension_Index(range_arg);
            if (dim < prefix_type->array.index_count) {
                low_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld  ; 'RANGE low\n", low_val,
                     (long long)Type_Bound_Value(prefix_type->array.indices[dim].low_bound));
                high_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld  ; 'RANGE high\n", high_val,
                     (long long)Type_Bound_Value(prefix_type->array.indices[dim].high_bound));
            } else {
                low_val = high_val = 0;
            }
        } else {
            /* ??? */
            low_val = Generate_Expression(cg, range);
            high_val = low_val;
        }
    } else if (range && range->kind == NK_SUBTYPE_INDICATION) {
        /* Subtype indication with constraint: SUBTYPE_NAME RANGE low..high */
        Syntax_Node *constraint = range->subtype_ind.constraint;
        if (constraint && constraint->kind == NK_RANGE_CONSTRAINT &&
            constraint->range_constraint.range) {
            Syntax_Node *actual_range = constraint->range_constraint.range;
            if (actual_range->kind == NK_RANGE) {
                low_val = Generate_Expression(cg, actual_range->range.low);
                high_val = Generate_Expression(cg, actual_range->range.high);
            } else {
                /* Range might be a name like T'RANGE */
                low_val = Generate_Expression(cg, actual_range);
                high_val = low_val;
            }
        } else {
            /* No range constraint - use the subtype's type bounds */
            Type_Info *subtype = range->type;
            if (subtype && subtype->low_bound.kind == BOUND_INTEGER) {
                low_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld  ; subtype low\n", low_val,
                     (long long)Type_Bound_Value(subtype->low_bound));
                high_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld  ; subtype high\n", high_val,
                     (long long)Type_Bound_Value(subtype->high_bound));
            } else {
                /* ??? Use 0 as fallback if no type info */
                low_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 0  ; no type info\n", low_val);
                high_val = low_val;
            }
        }
    } else if (range && range->kind == NK_IDENTIFIER) {
        /* Just a type name: FOR I IN TYPE_NAME LOOP - iterate over type's range */
        Type_Info *type = range->type;
        if (type && type->low_bound.kind == BOUND_INTEGER) {
            low_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 0, %lld  ; type low\n", low_val,
                 (long long)Type_Bound_Value(type->low_bound));
            high_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 0, %lld  ; type high\n", high_val,
                 (long long)Type_Bound_Value(type->high_bound));
        } else {
            low_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 0, 0  ; no type bounds\n", low_val);
            high_val = low_val;
        }
    } else {
        /* Other expression - evaluate as low bound, assume scalar with same high */
        low_val = Generate_Expression(cg, range);
        high_val = low_val;
    }

    /* Initialize loop variable */
    if (loop_var) {
        Emit(cg, "  store i64 %%t%u, ptr %%", is_reverse ? high_val : low_val);
        Emit_Symbol_Name(cg, loop_var);
        Emit(cg, "\n");
    }

    /* Loop start - check condition */
    Emit(cg, "  br label %%L%u\n", loop_start);
    Emit(cg, "L%u:\n", loop_start);

    uint32_t cur = Emit_Temp(cg);
    if (loop_var) {
        Emit(cg, "  %%t%u = load i64, ptr %%", cur);
        Emit_Symbol_Name(cg, loop_var);
        Emit(cg, "\n");
    }

    uint32_t cond = Emit_Temp(cg);
    if (is_reverse) {
        Emit(cg, "  %%t%u = icmp sge i64 %%t%u, %%t%u\n", cond, cur, low_val);
    } else {
        Emit(cg, "  %%t%u = icmp sle i64 %%t%u, %%t%u\n", cond, cur, high_val);
    }
    Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n", cond, loop_body, loop_end);

    /* Loop body */
    Emit(cg, "L%u:\n", loop_body);
    Generate_Statement_List(cg, &node->loop_stmt.statements);

    /* Increment/decrement loop variable */
    if (loop_var) {
        uint32_t next = Emit_Temp(cg);
        if (is_reverse) {
            Emit(cg, "  %%t%u = sub i64 %%t%u, 1\n", next, cur);
        } else {
            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", next, cur);
        }
        Emit(cg, "  store i64 %%t%u, ptr %%", next);
        Emit_Symbol_Name(cg, loop_var);
        Emit(cg, "\n");
    }

    Emit(cg, "  br label %%L%u\n", loop_start);
    Emit(cg, "L%u:\n", loop_end);

    cg->loop_exit_label = saved_exit;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.4.8 Exception Handling
 *
 * The stack unwinder's memory is what makes exceptions possible.
 * ───────────────────────────────────────────────────────────────────────── */

/* Forward declarations */
static void Generate_Declaration_List(Code_Generator *cg, Node_List *list);
static void Generate_Generic_Instance_Body(Code_Generator *cg, Symbol *inst_sym, Syntax_Node *template_body);
static void Generate_Task_Body(Code_Generator *cg, Syntax_Node *node);

static void Generate_Raise_Statement(Code_Generator *cg, Syntax_Node *node) {
    /* RAISE E; or RAISE; (reraise) */
    if (node->raise_stmt.exception_name) {
        Symbol *exc = node->raise_stmt.exception_name->symbol;
        if (exc) {
            Emit(cg, "  ; RAISE ");
            Emit_Symbol_Name(cg, exc);
            Emit(cg, "\n");

            /* Store exception identity and call __ada_raise */
            uint32_t exc_addr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = ptrtoint ptr @__exc.", exc_addr);
            Emit_Symbol_Name(cg, exc);
            Emit(cg, " to i64\n");
            Emit(cg, "  call void @__ada_raise(i64 %%t%u)\n", exc_addr);
        }
    } else {
        /* Reraise current exception */
        Emit(cg, "  ; RAISE (reraise)\n");
        Emit(cg, "  call void @__ada_reraise()\n");
    }
    Emit(cg, "  unreachable\n");
}

static void Generate_Block_Statement(Code_Generator *cg, Syntax_Node *node) {
    /* Emit LLVM label for Ada label (enables GOTO targeting this block) */
    Symbol *label_sym = node->block_stmt.label_symbol;
    if (label_sym) {
        if (label_sym->llvm_label_id == 0)
            label_sym->llvm_label_id = cg->label_id++;
        if (!cg->block_terminated)
            Emit(cg, "  br label %%L%u\n", label_sym->llvm_label_id);
        Emit(cg, "L%u:  ; %.*s\n", label_sym->llvm_label_id,
             (int)node->block_stmt.label.length, node->block_stmt.label.data);
        cg->block_terminated = false;  /* New block started */
    }

    /* Block with optional declarations and exception handlers */
    bool has_handlers = node->block_stmt.handlers.count > 0;

    if (has_handlers) {
        /* Per Ada RM: Exception handlers only cover the statement part,
         * NOT the declarative part. Exceptions in declarations propagate
         * to the enclosing block's handler. */

        /* Allocate handler frame first (needed for stack allocation order) */
        uint32_t handler_frame = Emit_Temp(cg);
        Emit(cg, "  %%t%u = alloca { ptr, [200 x i8] }, align 16  ; handler frame\n", handler_frame);

        /* Generate declarations BEFORE setting up the exception handler.
         * This ensures exceptions in declarative part propagate outward. */
        Generate_Declaration_List(cg, &node->block_stmt.declarations);

        /* Now setup exception handling for the statement part only */
        uint32_t handler_label = Emit_Label(cg);
        uint32_t normal_label = Emit_Label(cg);
        uint32_t end_label = Emit_Label(cg);

        /* Push exception handler */
        Emit(cg, "  call void @__ada_push_handler(ptr %%t%u)\n", handler_frame);

        /* Call setjmp on the jmp_buf field (field 1) */
        uint32_t jmp_buf = Emit_Temp(cg);
        Emit(cg, "  %%t%u = getelementptr { ptr, [200 x i8] }, ptr %%t%u, i32 0, i32 1\n",
             jmp_buf, handler_frame);
        uint32_t setjmp_result = Emit_Temp(cg);
        Emit(cg, "  %%t%u = call i32 @setjmp(ptr %%t%u)\n", setjmp_result, jmp_buf);

        /* Branch based on setjmp return */
        uint32_t is_normal = Emit_Temp(cg);
        Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", is_normal, setjmp_result);
        Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
             is_normal, normal_label, handler_label);

        /* Normal execution path */
        Emit(cg, "L%u:\n", normal_label);

        /* Save and set exception context */
        uint32_t saved_handler = cg->exception_handler_label;
        uint32_t saved_jmp_buf = cg->exception_jmp_buf;
        bool saved_in_region = cg->in_exception_region;

        cg->exception_handler_label = handler_label;
        cg->exception_jmp_buf = jmp_buf;
        cg->in_exception_region = true;

        /* Generate block statements (handler covers only this part) */
        Generate_Statement_List(cg, &node->block_stmt.statements);

        /* Pop handler on normal exit */
        Emit(cg, "  call void @__ada_pop_handler()\n");
        Emit(cg, "  br label %%L%u\n", end_label);

        /* Exception handler entry */
        Emit(cg, "L%u:\n", handler_label);
        Emit(cg, "  call void @__ada_pop_handler()\n");

        /* Get current exception identity */
        uint32_t exc_id = Emit_Temp(cg);
        Emit(cg, "  %%t%u = call i64 @__ada_current_exception()\n", exc_id);

        /* Generate exception handlers */
        uint32_t next_handler = 0;
        for (uint32_t i = 0; i < node->block_stmt.handlers.count; i++) {
            Syntax_Node *handler = node->block_stmt.handlers.items[i];
            if (!handler) continue;

            if (next_handler != 0) {
                Emit(cg, "L%u:\n", next_handler);
            }
            next_handler = Emit_Label(cg);
            uint32_t handler_body = Emit_Label(cg);

            /* Check each exception name in the handler */
            bool has_others = false;
            for (uint32_t j = 0; j < handler->handler.exceptions.count; j++) {
                Syntax_Node *exc_name = handler->handler.exceptions.items[j];
                if (exc_name->kind == NK_OTHERS) {
                    has_others = true;
                    break;
                }
            }

            if (has_others) {
                /* WHEN OTHERS => catches all */
                Emit(cg, "  br label %%L%u\n", handler_body);
            } else {
                /* Check against specific exceptions */
                for (uint32_t j = 0; j < handler->handler.exceptions.count; j++) {
                    Syntax_Node *exc_name = handler->handler.exceptions.items[j];
                    if (exc_name->symbol) {
                        uint32_t exc_ptr = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = ptrtoint ptr @__exc.", exc_ptr);
                        Emit_Symbol_Name(cg, exc_name->symbol);
                        Emit(cg, " to i64\n");
                        uint32_t match = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n",
                             match, exc_id, exc_ptr);
                        Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
                             match, handler_body, next_handler);
                    }
                }
            }

            /* Handler body */
            Emit(cg, "L%u:\n", handler_body);
            Generate_Statement_List(cg, &handler->handler.statements);
            Emit(cg, "  br label %%L%u\n", end_label);
        }

        /* If no handler matched, reraise */
        if (next_handler != 0) {
            Emit(cg, "L%u:\n", next_handler);
            Emit(cg, "  call void @__ada_reraise()\n");
            Emit(cg, "  unreachable\n");
        }

        /* End of block */
        Emit(cg, "L%u:\n", end_label);

        /* Restore exception context */
        cg->exception_handler_label = saved_handler;
        cg->exception_jmp_buf = saved_jmp_buf;
        cg->in_exception_region = saved_in_region;
    } else {
        /* Simple block without exception handlers */
        Generate_Declaration_List(cg, &node->block_stmt.declarations);
        Generate_Statement_List(cg, &node->block_stmt.statements);
    }
}

static void Generate_Statement(Code_Generator *cg, Syntax_Node *node) {
    if (!node) return;

    switch (node->kind) {
        case NK_ASSIGNMENT:
            Generate_Assignment(cg, node);
            break;

        case NK_CALL_STMT: {
            /* Procedure call - might be NK_APPLY, NK_IDENTIFIER (no args), or
             * NK_SELECTED (for entry calls like Task.Entry without args) */
            Syntax_Node *target = node->assignment.target;
            if (target->kind == NK_APPLY) {
                Generate_Expression(cg, target);
            } else if (target->kind == NK_SELECTED) {
                /* Selected component - might be a parameterless entry call like T.E1 */
                Symbol *entry_sym = target->symbol;
                if (entry_sym && entry_sym->kind == SYMBOL_ENTRY) {
                    /* Entry call without parameters - generate rendezvous */
                    Emit(cg, "  ; Entry call (no params): %.*s\n",
                         (int)entry_sym->name.length, entry_sym->name.data);

                    /* Allocate empty parameter block */
                    uint32_t param_block = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = inttoptr i64 0 to ptr  ; no parameters\n", param_block);

                    /* Get task object from prefix */
                    uint32_t task_ptr = Emit_Temp(cg);
                    Symbol *task_sym = target->selected.prefix->symbol;
                    if (task_sym) {
                        Symbol *var_owner = task_sym->defining_scope
                                           ? task_sym->defining_scope->owner : NULL;
                        bool is_uplevel = cg->current_function && var_owner &&
                                          var_owner != cg->current_function &&
                                          var_owner != cg->current_function->generic_template;
                        if (is_uplevel && cg->is_nested) {
                            Emit(cg, "  %%t%u = getelementptr i8, ptr %%__frame.", task_ptr);
                            Emit_Symbol_Name(cg, task_sym);
                            Emit(cg, ", i64 0  ; uplevel task object\n");
                        } else {
                            Emit(cg, "  %%t%u = getelementptr i8, ptr ", task_ptr);
                            Emit_Symbol_Ref(cg, task_sym);
                            Emit(cg, ", i64 0  ; task object\n");
                        }
                    } else {
                        Emit(cg, "  %%t%u = inttoptr i64 0 to ptr  ; no task\n", task_ptr);
                    }

                    /* Get entry index (simple entry, not family) */
                    uint32_t entry_idx = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = add i64 0, %u  ; entry index (simple entry)\n",
                         entry_idx, entry_sym->entry_index * 1000);

                    /* Call runtime entry call function */
                    Emit(cg, "  call void @__ada_entry_call(ptr %%t%u, i64 %%t%u, ptr %%t%u)\n",
                         task_ptr, entry_idx, param_block);
                } else if (entry_sym && (entry_sym->kind == SYMBOL_PROCEDURE ||
                                         entry_sym->kind == SYMBOL_FUNCTION)) {
                    /* Qualified procedure call like Pkg.Proc */
                    Generate_Expression(cg, target);
                }
            } else if (target->kind == NK_IDENTIFIER) {
                /* Parameterless procedure/function call */
                Symbol *original_sym = target->symbol;  /* Keep for defaults */
                Symbol *proc = original_sym;

                /* Follow rename chain to get actual target for function name */
                while (proc && proc->renamed_object &&
                       (proc->kind == SYMBOL_FUNCTION || proc->kind == SYMBOL_PROCEDURE)) {
                    Symbol *renamed_target = (Symbol *)proc->renamed_object;
                    if (renamed_target->kind == SYMBOL_FUNCTION ||
                        renamed_target->kind == SYMBOL_PROCEDURE) {
                        proc = renamed_target;
                    } else {
                        break;
                    }
                }

                if (proc && (proc->kind == SYMBOL_PROCEDURE || proc->kind == SYMBOL_FUNCTION)) {
                    /* Check if calling a nested function of current scope */
                    bool callee_is_nested = proc->parent &&
                        (proc->parent->kind == SYMBOL_FUNCTION ||
                         proc->parent->kind == SYMBOL_PROCEDURE);

                    if (proc->return_type) {
                        Emit(cg, "  call %s @", Type_To_Llvm(proc->return_type));
                    } else {
                        Emit(cg, "  call void @");
                    }
                    Emit_Symbol_Name(cg, proc);
                    Emit(cg, "(");

                    /* Pass frame pointer to nested functions */
                    bool frame_emitted = false;
                    if (callee_is_nested) {
                        if (cg->current_function == proc->parent) {
                            Emit(cg, "ptr %%__frame_base");
                            frame_emitted = true;
                        } else if (cg->is_nested && cg->current_function &&
                                   cg->current_function->parent == proc->parent) {
                            Emit(cg, "ptr %%__parent_frame");
                            frame_emitted = true;
                        }
                    }

                    /* Generate default arguments from original symbol (for renames) */
                    if (original_sym->parameter_count > 0) {
                        for (uint32_t i = 0; i < original_sym->parameter_count; i++) {
                            if (frame_emitted || i > 0) Emit(cg, ", ");
                            if (original_sym->parameters[i].default_value) {
                                uint32_t val = Generate_Expression(cg,
                                    original_sym->parameters[i].default_value);
                                const char *param_type = original_sym->parameters[i].param_type ?
                                    Type_To_Llvm(original_sym->parameters[i].param_type) : "i64";
                                val = Emit_Convert(cg, val, "i64", param_type);
                                Emit(cg, "%s %%t%u", param_type, val);
                            } else {
                                /* No default - emit zero (shouldn't happen) */
                                Emit(cg, "i64 0");
                            }
                        }
                    }
                    Emit(cg, ")\n");
                }
            }
        } break;

        case NK_RETURN:
            Generate_Return_Statement(cg, node);
            break;

        case NK_IF:
            Generate_If_Statement(cg, node);
            break;

        case NK_LOOP:
            if (node->loop_stmt.iteration_scheme &&
                node->loop_stmt.iteration_scheme->kind == NK_BINARY_OP &&
                node->loop_stmt.iteration_scheme->binary.op == TK_IN) {
                Generate_For_Loop(cg, node);
            } else {
                Generate_Loop_Statement(cg, node);
            }
            break;

        case NK_CASE:
            Generate_Case_Statement(cg, node);
            break;

        case NK_EXIT:
            if (node->exit_stmt.condition) {
                Syntax_Node *exit_cond = node->exit_stmt.condition;
                uint32_t cond = Generate_Expression(cg, exit_cond);
                const char *cond_type = Expression_Llvm_Type(exit_cond);
                cond = Emit_Convert(cg, cond, cond_type, "i1");
                uint32_t cont = Emit_Label(cg);
                Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
                     cond, cg->loop_exit_label, cont);
                Emit(cg, "L%u:\n", cont);
            } else {
                Emit(cg, "  br label %%L%u\n", cg->loop_exit_label);
            }
            break;

        case NK_NULL_STMT:
            /* No code needed */
            break;

        case NK_BLOCK:
            Generate_Block_Statement(cg, node);
            break;

        case NK_RAISE:
            Generate_Raise_Statement(cg, node);
            break;

        case NK_DELAY:
            {
                /* DELAY expression — sleep for specified duration */
                /* Expression should be in seconds, convert to microseconds */
                uint32_t val = Generate_Expression(cg, node->delay_stmt.expression);
                /* Convert to microseconds (assuming Duration in seconds) */
                uint32_t us = Emit_Temp(cg);
                Emit(cg, "  %%t%u = fmul double %%t%u, 1.0e6\n", us, val);
                uint32_t us_int = Emit_Temp(cg);
                Emit(cg, "  %%t%u = fptoui double %%t%u to i64\n", us_int, us);
                Emit(cg, "  call void @__ada_delay(i64 %%t%u)\n", us_int);
            }
            break;

        case NK_ACCEPT:
            {
                /* ACCEPT statement — rendezvous with caller (Ada 83 9.5)
                 * Runtime: wait for entry call, execute body, complete rendezvous */
                Emit(cg, "  ; ACCEPT %.*s\n",
                     (int)node->accept_stmt.entry_name.length,
                     node->accept_stmt.entry_name.data);

                /* Get entry index - combine entry_sym's base index with family offset.
                 * For entry families: entry_idx = base * 1000 + family_arg
                 * For simple entries: entry_idx = base * 1000 */
                uint32_t entry_idx = Emit_Temp(cg);
                uint32_t base_idx = node->accept_stmt.entry_sym ?
                                    node->accept_stmt.entry_sym->entry_index : 0;
                if (node->accept_stmt.index) {
                    uint32_t idx_val = Generate_Expression(cg, node->accept_stmt.index);
                    Emit(cg, "  %%t%u = add i64 %u, %%t%u  ; entry index (base + family)\n",
                         entry_idx, base_idx * 1000, idx_val);
                } else {
                    Emit(cg, "  %%t%u = add i64 0, %u  ; entry index (simple entry)\n",
                         entry_idx, base_idx * 1000);
                }

                /* Wait for entry call - blocks until a caller arrives */
                uint32_t caller_ptr = Emit_Temp(cg);
                Emit(cg, "  %%t%u = call ptr @__ada_accept_wait(i64 %%t%u)\n",
                     caller_ptr, entry_idx);

                /* Generate parameters - allocate space and copy from caller's parameter block */
                uint32_t param_idx = 0;
                for (uint32_t i = 0; i < node->accept_stmt.parameters.count; i++) {
                    Syntax_Node *param = node->accept_stmt.parameters.items[i];
                    if (param && param->kind == NK_PARAM_SPEC) {
                        for (uint32_t j = 0; j < param->param_spec.names.count; j++) {
                            Syntax_Node *name = param->param_spec.names.items[j];
                            if (name && name->symbol) {
                                /* Allocate space for the parameter */
                                Emit(cg, "  %%");
                                Emit_Symbol_Name(cg, name->symbol);
                                Emit(cg, " = alloca i64, align 8\n");

                                /* Load value from caller's parameter block */
                                uint32_t param_ptr = Emit_Temp(cg);
                                Emit(cg, "  %%t%u = getelementptr i64, ptr %%t%u, i64 %u\n",
                                     param_ptr, caller_ptr, param_idx);
                                uint32_t param_val = Emit_Temp(cg);
                                Emit(cg, "  %%t%u = load i64, ptr %%t%u\n", param_val, param_ptr);

                                /* Store to allocated space */
                                Emit(cg, "  store i64 %%t%u, ptr %%", param_val);
                                Emit_Symbol_Name(cg, name->symbol);
                                Emit(cg, "\n");

                                param_idx++;
                            }
                        }
                    }
                }

                /* Execute accept body */
                Generate_Statement_List(cg, &node->accept_stmt.statements);

                /* Complete rendezvous - unblocks the caller */
                Emit(cg, "  call void @__ada_accept_complete(ptr %%t%u)\n", caller_ptr);
            }
            break;

        case NK_SELECT:
            /* SELECT statement — selective wait (Ada 83 9.7)
             * Forms: selective_wait, conditional_entry_call, timed_entry_call
             * Runtime: check open alternatives, wait or execute else */
            {
                uint32_t done_label = cg->label_id++;
                bool has_else = (node->select_stmt.else_part != NULL);
                bool has_delay = false;
                uint32_t delay_label = 0;

                /* Check for delay alternative */
                for (uint32_t i = 0; i < node->select_stmt.alternatives.count; i++) {
                    if (node->select_stmt.alternatives.items[i]->kind == NK_DELAY) {
                        has_delay = true;
                        delay_label = cg->label_id++;
                        break;
                    }
                }
                bool delay_label_emitted = false;
                bool skipped_delay = false;  /* Track if current iteration was a skipped delay */

                /* Generate alternatives */
                for (uint32_t i = 0; i < node->select_stmt.alternatives.count; i++) {
                    Syntax_Node *alt = node->select_stmt.alternatives.items[i];
                    uint32_t next_label = cg->label_id++;
                    skipped_delay = false;

                    switch (alt->kind) {
                        case NK_ASSOCIATION:
                            /* Guarded alternative: WHEN cond => stmt */
                            {
                                Syntax_Node *guard_expr = alt->association.choices.items[0];
                                uint32_t guard = Generate_Expression(cg, guard_expr);
                                const char *guard_type = Expression_Llvm_Type(guard_expr);
                                guard = Emit_Convert(cg, guard, guard_type, "i1");
                                Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
                                     guard, cg->label_id, next_label);
                                Emit(cg, "L%u:\n", cg->label_id++);
                                if (alt->association.expression)
                                    Generate_Statement(cg, alt->association.expression);
                                Emit(cg, "  br label %%L%u\n", done_label);
                            }
                            break;

                        case NK_ACCEPT:
                            /* Accept alternative */
                            {
                                Emit(cg, "  ; accept alternative: %.*s\n",
                                     (int)alt->accept_stmt.entry_name.length,
                                     alt->accept_stmt.entry_name.data);

                                /* Get entry index - combine base index with family index.
                                 * Formula: entry_idx = base * 1000 + family_arg */
                                uint32_t entry_idx = Emit_Temp(cg);
                                uint32_t sel_base_idx = alt->accept_stmt.entry_sym ?
                                                        alt->accept_stmt.entry_sym->entry_index : 0;
                                if (alt->accept_stmt.index) {
                                    uint32_t idx_val = Generate_Expression(cg, alt->accept_stmt.index);
                                    Emit(cg, "  %%t%u = add i64 %u, %%t%u  ; entry index (base + family)\n",
                                         entry_idx, sel_base_idx * 1000, idx_val);
                                } else {
                                    Emit(cg, "  %%t%u = add i64 0, %u  ; entry index (simple entry)\n",
                                         entry_idx, sel_base_idx * 1000);
                                }

                                /* Check if entry call is pending (non-blocking) */
                                uint32_t caller_ptr = Emit_Temp(cg);
                                Emit(cg, "  %%t%u = call ptr @__ada_accept_try(i64 %%t%u)\n",
                                     caller_ptr, entry_idx);
                                uint32_t has_caller = Emit_Temp(cg);
                                Emit(cg, "  %%t%u = icmp ne ptr %%t%u, null\n",
                                     has_caller, caller_ptr);
                                Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
                                     has_caller, cg->label_id, next_label);
                                Emit(cg, "L%u:\n", cg->label_id++);

                                /* Load parameters from caller */
                                uint32_t sel_param_idx = 0;
                                for (uint32_t pi = 0; pi < alt->accept_stmt.parameters.count; pi++) {
                                    Syntax_Node *param = alt->accept_stmt.parameters.items[pi];
                                    if (param && param->kind == NK_PARAM_SPEC) {
                                        for (uint32_t pj = 0; pj < param->param_spec.names.count; pj++) {
                                            Syntax_Node *pname = param->param_spec.names.items[pj];
                                            if (pname && pname->symbol) {
                                                /* Allocate space for the parameter */
                                                Emit(cg, "  %%");
                                                Emit_Symbol_Name(cg, pname->symbol);
                                                Emit(cg, " = alloca i64, align 8\n");

                                                /* Load value from caller's parameter block */
                                                uint32_t param_ptr = Emit_Temp(cg);
                                                Emit(cg, "  %%t%u = getelementptr i64, ptr %%t%u, i64 %u\n",
                                                     param_ptr, caller_ptr, sel_param_idx);
                                                uint32_t param_val = Emit_Temp(cg);
                                                Emit(cg, "  %%t%u = load i64, ptr %%t%u\n", param_val, param_ptr);

                                                /* Store to allocated space */
                                                Emit(cg, "  store i64 %%t%u, ptr %%", param_val);
                                                Emit_Symbol_Name(cg, pname->symbol);
                                                Emit(cg, "\n");

                                                sel_param_idx++;
                                            }
                                        }
                                    }
                                }

                                /* Execute accept body */
                                Generate_Statement_List(cg, &alt->accept_stmt.statements);

                                /* Complete rendezvous */
                                Emit(cg, "  call void @__ada_accept_complete(ptr %%t%u)\n", caller_ptr);
                                Emit(cg, "  br label %%L%u\n", done_label);
                            }
                            break;

                        case NK_DELAY:
                            /* Delay alternative - only emit code once for multiple delays.
                             * In Ada, multiple delays would pick the shortest, but we simplify
                             * by using the first delay's duration for all. */
                            if (!delay_label_emitted) {
                                Emit(cg, "L%u:  ; delay alternative\n", delay_label);
                                delay_label_emitted = true;
                                {
                                    uint32_t dur = Generate_Expression(cg, alt->delay_stmt.expression);
                                    uint32_t us = Emit_Temp(cg);
                                    Emit(cg, "  %%t%u = fmul double %%t%u, 1.0e6\n", us, dur);
                                    uint32_t us_int = Emit_Temp(cg);
                                    Emit(cg, "  %%t%u = fptoui double %%t%u to i64\n", us_int, us);
                                    Emit(cg, "  call void @__ada_delay(i64 %%t%u)\n", us_int);
                                }
                                Emit(cg, "  br label %%L%u\n", done_label);
                            } else {
                                /* Subsequent delays: skip code generation entirely */
                                skipped_delay = true;
                            }
                            break;

                        case NK_NULL_STMT:
                            /* Terminate alternative */
                            Emit(cg, "  ; terminate alternative\n");
                            Emit(cg, "  call void @__ada_task_terminate()\n");
                            Emit(cg, "  br label %%L%u\n", done_label);
                            break;

                        default:
                            break;
                    }
                    /* For skipped delay alternatives, don't emit next_label since
                     * we've already branched to delay_label and this would be unreachable */
                    if (!skipped_delay) {
                        /* Emit the next_label for branches that skip this alternative */
                        Emit(cg, "L%u:\n", next_label);
                        /* If this isn't the last alternative, fall through to next;
                         * otherwise go to delay or done */
                        bool is_last = (i == node->select_stmt.alternatives.count - 1);
                        if (!is_last) {
                            /* Check if next alternative is delay - branch to delay_label instead */
                            Syntax_Node *next_alt = node->select_stmt.alternatives.items[i + 1];
                            if (next_alt && next_alt->kind == NK_DELAY && has_delay) {
                                Emit(cg, "  br label %%L%u\n", delay_label);
                            }
                            /* Otherwise fall through (no br needed, will hit next iteration's code) */
                        }
                    }
                }

                /* Else clause or fall through to delay */
                if (has_else) {
                    Generate_Statement(cg, node->select_stmt.else_part);
                } else if (has_delay) {
                    /* Already branched to delay_label above */
                }
                Emit(cg, "  br label %%L%u\n", done_label);
                Emit(cg, "L%u:\n", done_label);
            }
            break;

        case NK_ABORT:
            /* ABORT statement — abort named tasks (Ada 83 9.10) */
            for (uint32_t i = 0; i < node->abort_stmt.task_names.count; i++) {
                Syntax_Node *task_name = node->abort_stmt.task_names.items[i];
                uint32_t task_ptr = Generate_Expression(cg, task_name);
                Emit(cg, "  call void @__ada_task_abort(ptr %%t%u)\n", task_ptr);
            }
            break;

        case NK_LABEL:
            {
                /* Ada label - allocate LLVM label ID and emit label */
                Symbol *label_sym = node->label_node.symbol;
                if (label_sym) {
                    if (label_sym->llvm_label_id == 0)
                        label_sym->llvm_label_id = cg->label_id++;
                    /* Need a branch to the label to terminate previous block (if not already) */
                    if (!cg->block_terminated)
                        Emit(cg, "  br label %%L%u\n", label_sym->llvm_label_id);
                    Emit(cg, "L%u:  ; %.*s\n", label_sym->llvm_label_id,
                         (int)node->label_node.name.length,
                         node->label_node.name.data);
                    cg->block_terminated = false;  /* New block started */
                }
                /* Generate the labeled statement */
                if (node->label_node.statement) {
                    Generate_Statement(cg, node->label_node.statement);
                }
            }
            break;

        case NK_GOTO:
            {
                /* GOTO statement - use resolved target label and branch */
                Symbol *label_sym = node->goto_stmt.target;
                if (label_sym) {
                    if (label_sym->llvm_label_id == 0) {
                        label_sym->llvm_label_id = cg->label_id++;
                    }
                    Emit(cg, "  br label %%L%u  ; goto %.*s\n",
                         label_sym->llvm_label_id,
                         (int)node->goto_stmt.name.length,
                         node->goto_stmt.name.data);
                    cg->block_terminated = true;  /* br is a terminator */
                } else {
                    Emit(cg, "  ; ERROR: undefined label %.*s\n",
                         (int)node->goto_stmt.name.length,
                         node->goto_stmt.name.data);
                }
            }
            break;

        default:
            break;
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.5 Declaration Code Generation
 *
 * Names get bound to meanings, and those bindings are what we generate.
 * ───────────────────────────────────────────────────────────────────────── */

static void Generate_Declaration(Code_Generator *cg, Syntax_Node *node);
static void Emit_Extern_Subprogram(Code_Generator *cg, Symbol *sym);

static void Generate_Declaration_List(Code_Generator *cg, Node_List *list) {
    for (uint32_t i = 0; i < list->count; i++) {
        Generate_Declaration(cg, list->items[i]);
    }
}

static void Generate_Object_Declaration(Code_Generator *cg, Syntax_Node *node) {
    /* cg->current_nesting_level is repurposed: 1 = has nested functions, use frame */
    bool use_frame = cg->current_nesting_level > 0;
    bool is_package_level = (cg->current_function == NULL);

    for (uint32_t i = 0; i < node->object_decl.names.count; i++) {
        Syntax_Node *name = node->object_decl.names.items[i];
        Symbol *sym = name->symbol;
        if (!sym) continue;

        Type_Info *ty = sym->type;

        /* Substitute generic formal types with actual types in generic instances */
        if (cg->current_instance && cg->current_instance->generic_actuals && ty && ty->name.data) {
            for (uint32_t k = 0; k < cg->current_instance->generic_actual_count; k++) {
                if (Slice_Equal_Ignore_Case(ty->name,
                        cg->current_instance->generic_actuals[k].formal_name) &&
                    cg->current_instance->generic_actuals[k].actual_type) {
                    ty = cg->current_instance->generic_actuals[k].actual_type;
                    break;
                }
            }
        }

        /* Named numbers (constants without explicit type) don't need storage.
         * They are compile-time values that get inlined when referenced.
         * Per RM 3.2.2: Named numbers are not objects and have no storage. */
        if (sym->is_named_number) {
            continue;  /* Skip storage allocation for named numbers */
        }

        const char *type_str = Type_To_Llvm(ty);

        /* Check if this is an array type (constrained or unconstrained).
         * is_any_array: true for any array, used for aggregate initialization
         * is_constrained_array: true only for constrained, used for allocation */
        bool is_any_array = ty && ty->kind == TYPE_ARRAY;
        bool is_constrained_array = is_any_array && ty->array.is_constrained;
        int64_t array_count = is_constrained_array ? Array_Element_Count(ty) : 0;
        const char *elem_type = NULL;
        uint32_t elem_size = 0;
        bool elem_is_composite = false;
        if (is_any_array && ty->array.element_type) {
            Type_Info *et = ty->array.element_type;
            /* Check if element is record or another constrained array */
            if (et->kind == TYPE_RECORD ||
                (et->kind == TYPE_ARRAY && et->array.is_constrained)) {
                elem_is_composite = true;
                elem_size = et->size;
            } else {
                elem_type = Type_To_Llvm(et);
            }
        }

        /* Check if this is a record type */
        bool is_record = ty && ty->kind == TYPE_RECORD;
        uint32_t record_size = is_record ? ty->size : 0;

        /* Package-level variables are globals, local variables use alloca */
        if (is_package_level) {
            /* Global variable at package level */
            Emit(cg, "@");
            Emit_Symbol_Name(cg, sym);
            if (node->object_decl.is_constant && node->object_decl.init) {
                /* Constant with initializer - emit as constant */
                if (node->object_decl.init->kind == NK_INTEGER) {
                    Emit(cg, " = linkonce_odr constant %s %lld\n", type_str,
                         (long long)node->object_decl.init->integer_lit.value);
                    continue;
                }
                /* String constant - emit fat pointer global */
                if (node->object_decl.init->kind == NK_STRING) {
                    String_Slice str = node->object_decl.init->string_val.text;
                    int64_t str_len = (int64_t)str.length;
                    /* Emit string data first: @SYMNAME.data = ... */
                    Emit(cg, ".data = linkonce_odr constant [%lld x i8] c\"",
                         (long long)str_len);
                    /* Emit escaped string contents */
                    for (uint32_t j = 0; j < str.length; j++) {
                        char c = str.data[j];
                        if (c >= 32 && c < 127 && c != '"' && c != '\\') {
                            Emit(cg, "%c", c);
                        } else {
                            Emit(cg, "\\%02X", (unsigned char)c);
                        }
                    }
                    Emit(cg, "\"\n");
                    /* Now emit fat pointer global with data ptr and bounds */
                    Emit(cg, "@");
                    Emit_Symbol_Name(cg, sym);
                    Emit(cg, " = linkonce_odr constant { ptr, { i64, i64 } } "
                         "{ ptr @");
                    Emit_Symbol_Name(cg, sym);
                    Emit(cg, ".data, { i64, i64 } { i64 1, i64 %lld } }\n",
                         (long long)str_len);
                    continue;
                }
            }
            /* Variable - emit as global with default init */
            if (is_constrained_array && array_count > 0) {
                if (elem_is_composite && elem_size > 0) {
                    Emit(cg, " = linkonce_odr global [%lld x [%u x i8]] zeroinitializer\n",
                         (long long)array_count, elem_size);
                } else {
                    Emit(cg, " = linkonce_odr global [%lld x %s] zeroinitializer\n",
                         (long long)array_count, elem_type);
                }
            } else if (is_record && record_size > 0) {
                Emit(cg, " = linkonce_odr global [%u x i8] zeroinitializer\n", record_size);
            } else {
                Emit(cg, " = linkonce_odr global %s 0\n", type_str);
            }
            continue;
        }

        /* Local variable allocation */
        if (use_frame) {
            Emit(cg, "  %%");
            Emit_Symbol_Name(cg, sym);
            Emit(cg, " = getelementptr i8, ptr %%__frame_base, i64 %lld\n",
                 (long long)sym->frame_offset);
        } else if (is_constrained_array && array_count > 0) {
            /* Constrained array with static bounds: allocate [N x element_type] */
            Emit(cg, "  %%");
            Emit_Symbol_Name(cg, sym);
            if (elem_is_composite && elem_size > 0) {
                /* Element is record or constrained array - use byte array */
                Emit(cg, " = alloca [%lld x [%u x i8]]\n", (long long)array_count, elem_size);
            } else {
                Emit(cg, " = alloca [%lld x %s]\n", (long long)array_count, elem_type);
            }
        } else if (is_record && record_size > 0) {
            /* Record type: allocate [N x i8] for the record size */
            Emit(cg, "  %%");
            Emit_Symbol_Name(cg, sym);
            Emit(cg, " = alloca [%u x i8]  ; record type\n", record_size);
        } else {
            Emit(cg, "  %%");
            Emit_Symbol_Name(cg, sym);
            Emit(cg, " = alloca %s\n", type_str);
        }

        /* Start task if this is a task type object */
        if (ty && ty->kind == TYPE_TASK) {
            /* Task objects are started immediately at elaboration.
             * The task body function is named @task_TYPENAME where TYPENAME
             * is the task type name (not the object name).
             * For task types defined outside the generic, no instance prefix.
             * For single tasks inside generics, the body has an instance prefix. */
            String_Slice task_type_name = ty->name;
            uint32_t handle_tmp = Emit_Temp(cg);
            Emit(cg, "  %%t%u = call ptr @__ada_task_start(ptr @task_",
                 handle_tmp);
            /* Don't add instance prefix for task types - they're defined separately.
             * The instance prefix is only for single tasks declared inside the generic. */
            Emit(cg, "%.*s, ", (int)task_type_name.length, task_type_name.data);
            /* Pass parent frame for uplevel access, or null if at package level.
             * use_frame indicates the parent is using frame-based allocation. */
            if (use_frame) {
                Emit(cg, "ptr %%__frame_base)\n");
            } else {
                Emit(cg, "ptr null)\n");
            }
            /* Store thread handle in task object for later join/abort */
            Emit(cg, "  store ptr %%t%u, ptr %%", handle_tmp);
            Emit_Symbol_Name(cg, sym);
            Emit(cg, "\n");
        }

        /* Initialize if provided */
        if (node->object_decl.init) {
            if (is_any_array && ty->array.element_type == cg->sm->type_character) {
                /* String/character array initialization - copy fat pointer data */
                uint32_t fat_ptr = Generate_Expression(cg, node->object_decl.init);
                Emit_Fat_Pointer_Copy_To_Name(cg, fat_ptr, sym);
            } else if (ty && ty->kind == TYPE_FIXED &&
                       node->object_decl.init->kind == NK_REAL) {
                /* Fixed-point initialization from real literal:
                 * Convert real value to scaled integer at compile time
                 * Use Big_Real for precise scaling when available */
                double real_val = node->object_decl.init->real_lit.value;
                double small = ty->fixed.small > 0 ? ty->fixed.small : ty->fixed.delta;
                int64_t scaled_val;
                Big_Real *big_val = node->object_decl.init->real_lit.big_value;
                if (big_val && small != 0) {
                    /* Precise scaling: scaled = significand * 10^exponent / small
                     * For best precision, compute in arbitrary precision then round */
                    Big_Real *small_br = Big_Real_New();
                    small_br->significand = Big_Integer_New(4);
                    small_br->significand->limbs[0] = (uint64_t)(small * 1e15 + 0.5);
                    small_br->significand->count = 1;
                    small_br->exponent = -15;
                    /* Use double for final division - Big_Real provides precise numerator */
                    scaled_val = (int64_t)(Big_Real_To_Double(big_val) / small + 0.5);
                } else {
                    scaled_val = (int64_t)(real_val / small + 0.5);  /* Round */
                }
                uint32_t init = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld  ; fixed-point precise\n",
                     init, (long long)scaled_val);
                Emit(cg, "  store i64 %%t%u, ptr %%", init);
                Emit_Symbol_Name(cg, sym);
                Emit(cg, "\n");
            } else if (is_record && node->object_decl.init->kind == NK_AGGREGATE) {
                /* Record aggregate initialization - copy from aggregate to variable */
                uint32_t agg_ptr = Generate_Expression(cg, node->object_decl.init);
                Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%");
                Emit_Symbol_Name(cg, sym);
                Emit(cg, ", ptr %%t%u, i64 %u, i1 false)\n", agg_ptr, record_size);
            } else if (is_any_array && node->object_decl.init->kind == NK_AGGREGATE) {
                /* Array aggregate initialization - copy from aggregate to variable.
                 * Works for both constrained and unconstrained arrays with aggregate initializers.
                 * For arrays with dynamic bounds, the aggregate already returns a fat pointer. */
                Type_Info *agg_type = node->object_decl.init->type;
                bool dest_needs_fat = Type_Has_Dynamic_Bounds(ty) || Type_Is_Unconstrained_Array(ty);
                bool agg_has_dynamic = agg_type && agg_type->array.index_count > 0 &&
                    ((agg_type->array.indices[0].low_bound.kind == BOUND_EXPR) ||
                     (agg_type->array.indices[0].high_bound.kind == BOUND_EXPR));

                uint32_t agg_ptr = Generate_Expression(cg, node->object_decl.init);

                if (dest_needs_fat && agg_has_dynamic) {
                    /* Aggregate with dynamic bounds already returns a fat pointer.
                     * Just copy the fat pointer structure (24 bytes: ptr + 2*i64).
                     * This avoids re-evaluating bound expressions that may have side effects. */
                    Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%");
                    Emit_Symbol_Name(cg, sym);
                    Emit(cg, ", ptr %%t%u, i64 24, i1 false)  ; copy fat ptr\n", agg_ptr);
                } else if (dest_needs_fat && agg_type && agg_type->array.index_count > 0) {
                    /* Destination needs a fat pointer { ptr, { i64, i64 } }.
                     * agg_ptr is the data pointer (static bounds), construct the fat pointer. */
                    Type_Bound low_b = agg_type->array.indices[0].low_bound;
                    Type_Bound high_b = agg_type->array.indices[0].high_bound;

                    uint32_t low_val, high_val;

                    /* Get low bound (must be static since we checked for dynamic above) */
                    if (low_b.kind == BOUND_INTEGER) {
                        low_val = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = add i64 0, %lld\n", low_val, (long long)low_b.int_value);
                    } else {
                        low_val = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = add i64 0, 1\n", low_val);  /* Default low = 1 */
                    }

                    /* Get high bound (must be static) */
                    if (high_b.kind == BOUND_INTEGER) {
                        high_val = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = add i64 0, %lld\n", high_val, (long long)high_b.int_value);
                    } else {
                        high_val = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = add i64 0, 0\n", high_val);  /* Default high = 0 */
                    }

                    /* Construct fat pointer: store data ptr at offset 0, low at 8, high at 16 */
                    uint32_t data_slot = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%", data_slot);
                    Emit_Symbol_Name(cg, sym);
                    Emit(cg, ", i32 0, i32 0\n");
                    Emit(cg, "  store ptr %%t%u, ptr %%t%u  ; fat ptr data\n", agg_ptr, data_slot);

                    uint32_t low_slot = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%", low_slot);
                    Emit_Symbol_Name(cg, sym);
                    Emit(cg, ", i32 0, i32 1, i32 0\n");
                    Emit(cg, "  store i64 %%t%u, ptr %%t%u  ; fat ptr low\n", low_val, low_slot);

                    uint32_t high_slot = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%", high_slot);
                    Emit_Symbol_Name(cg, sym);
                    Emit(cg, ", i32 0, i32 1, i32 1\n");
                    Emit(cg, "  store i64 %%t%u, ptr %%t%u  ; fat ptr high\n", high_val, high_slot);
                } else if (ty->size > 0) {
                    /* Static size known at compile time */
                    Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%");
                    Emit_Symbol_Name(cg, sym);
                    Emit(cg, ", ptr %%t%u, i64 %u, i1 false)  ; array init\n", agg_ptr, ty->size);
                } else {
                    /* Dynamic size - compute from bounds at runtime */
                    uint32_t elem_sz = elem_size > 0 ? elem_size :
                                       (ty->array.element_type ? ty->array.element_type->size : 8);
                    if (elem_sz == 0) elem_sz = 8;

                    /* Get bounds from aggregate type if available */
                    if (agg_type && agg_type->array.index_count > 0 &&
                        agg_type->array.indices[0].low_bound.kind == BOUND_INTEGER &&
                        agg_type->array.indices[0].high_bound.kind == BOUND_INTEGER) {
                        /* Bounds are static integers in the aggregate */
                        int64_t lo = agg_type->array.indices[0].low_bound.int_value;
                        int64_t hi = agg_type->array.indices[0].high_bound.int_value;
                        int64_t count = hi - lo + 1;
                        if (count > 0) {
                            Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%");
                            Emit_Symbol_Name(cg, sym);
                            Emit(cg, ", ptr %%t%u, i64 %lld, i1 false)  ; array init\n",
                                 agg_ptr, (long long)(count * elem_sz));
                        }
                    } else {
                        /* Fallback: use element size as minimum */
                        Emit(cg, "  call void @llvm.memcpy.p0.p0.i64(ptr %%");
                        Emit_Symbol_Name(cg, sym);
                        Emit(cg, ", ptr %%t%u, i64 %u, i1 false)  ; array init (min)\n",
                             agg_ptr, elem_sz);
                    }
                }
            } else if (!is_any_array && !is_record) {
                uint32_t init = Generate_Expression(cg, node->object_decl.init);
                /* Use Expression_Llvm_Type to get correct type for all expressions
                 * including pointers, floats, and integers */
                const char *src_type_str = Expression_Llvm_Type(node->object_decl.init);

                /* Convert if types differ, then store */
                init = Emit_Convert(cg, init, src_type_str, type_str);
                Emit(cg, "  store %s %%t%u, ptr %%", type_str, init);
                Emit_Symbol_Name(cg, sym);
                Emit(cg, "\n");
            }
        } else if (is_any_array && Type_Has_Dynamic_Bounds(ty) && ty->array.index_count > 0) {
            /* Uninitialized array with dynamic bounds - still need to set up fat pointer.
             * The array contents are uninitialized but bounds are known from the type.
             * This handles cases like: A2 : ARR1 (1 .. F * 1000); */
            Type_Bound low_b = ty->array.indices[0].low_bound;
            Type_Bound high_b = ty->array.indices[0].high_bound;

            uint32_t low_val, high_val;

            /* Get low bound */
            if (low_b.kind == BOUND_INTEGER) {
                low_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", low_val, (long long)low_b.int_value);
            } else if (low_b.kind == BOUND_EXPR && low_b.expr) {
                low_val = Generate_Expression(cg, low_b.expr);
                /* Extend to i64 if narrower type (e.g., ENUM'('B') returns i8) */
                const char *low_llvm = Expression_Llvm_Type(low_b.expr);
                if (strcmp(low_llvm, "i64") != 0 && strcmp(low_llvm, "ptr") != 0 &&
                    strcmp(low_llvm, "double") != 0 && strcmp(low_llvm, "float") != 0) {
                    low_val = Emit_Convert(cg, low_val, low_llvm, "i64");
                }
            } else {
                low_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 1\n", low_val);
            }

            /* Get high bound */
            if (high_b.kind == BOUND_INTEGER) {
                high_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, %lld\n", high_val, (long long)high_b.int_value);
            } else if (high_b.kind == BOUND_EXPR && high_b.expr) {
                high_val = Generate_Expression(cg, high_b.expr);
                /* Extend to i64 if narrower type (e.g., ENUM'('D') returns i8) */
                const char *high_llvm = Expression_Llvm_Type(high_b.expr);
                if (strcmp(high_llvm, "i64") != 0 && strcmp(high_llvm, "ptr") != 0 &&
                    strcmp(high_llvm, "double") != 0 && strcmp(high_llvm, "float") != 0) {
                    high_val = Emit_Convert(cg, high_val, high_llvm, "i64");
                }
            } else {
                high_val = Emit_Temp(cg);
                Emit(cg, "  %%t%u = add i64 0, 0\n", high_val);
            }

            /* Allocate array data with dynamic size */
            uint32_t elem_sz = elem_size > 0 ? elem_size :
                               (ty->array.element_type ? ty->array.element_type->size : 8);
            if (elem_sz == 0) elem_sz = 8;

            uint32_t count_val = Emit_Temp(cg);
            Emit(cg, "  %%t%u = sub i64 %%t%u, %%t%u\n", count_val, high_val, low_val);
            uint32_t count_plus1 = Emit_Temp(cg);
            Emit(cg, "  %%t%u = add i64 %%t%u, 1\n", count_plus1, count_val);
            uint32_t byte_size = Emit_Temp(cg);
            Emit(cg, "  %%t%u = mul i64 %%t%u, %u\n", byte_size, count_plus1, elem_sz);

            uint32_t data_ptr = Emit_Temp(cg);
            Emit(cg, "  %%t%u = alloca i8, i64 %%t%u  ; dynamic uninit array\n", data_ptr, byte_size);

            /* Construct fat pointer: store data ptr, low, high */
            uint32_t data_slot = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%", data_slot);
            Emit_Symbol_Name(cg, sym);
            Emit(cg, ", i32 0, i32 0\n");
            Emit(cg, "  store ptr %%t%u, ptr %%t%u  ; fat ptr data\n", data_ptr, data_slot);

            uint32_t low_slot = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%", low_slot);
            Emit_Symbol_Name(cg, sym);
            Emit(cg, ", i32 0, i32 1, i32 0\n");
            Emit(cg, "  store i64 %%t%u, ptr %%t%u  ; fat ptr low\n", low_val, low_slot);

            uint32_t high_slot = Emit_Temp(cg);
            Emit(cg, "  %%t%u = getelementptr { ptr, { i64, i64 } }, ptr %%", high_slot);
            Emit_Symbol_Name(cg, sym);
            Emit(cg, ", i32 0, i32 1, i32 1\n");
            Emit(cg, "  store i64 %%t%u, ptr %%t%u  ; fat ptr high\n", high_val, high_slot);
        }
    }
}

/* Forward declare for recursive search */
static bool Has_Nested_Subprograms(Node_List *declarations, Node_List *statements);

static bool Has_Nested_In_Statements(Node_List *statements) {
    if (!statements) return false;
    for (uint32_t i = 0; i < statements->count; i++) {
        Syntax_Node *stmt = statements->items[i];
        if (!stmt) continue;
        if (stmt->kind == NK_BLOCK) {
            /* DECLARE block - check its declarations and nested statements */
            if (Has_Nested_Subprograms(&stmt->block_stmt.declarations,
                                        &stmt->block_stmt.statements)) {
                return true;
            }
        } else if (stmt->kind == NK_IF) {
            /* Check all branches of IF */
            if (Has_Nested_In_Statements(&stmt->if_stmt.then_stmts)) return true;
            for (uint32_t j = 0; j < stmt->if_stmt.elsif_parts.count; j++) {
                Syntax_Node *elsif = stmt->if_stmt.elsif_parts.items[j];
                if (elsif && Has_Nested_In_Statements(&elsif->if_stmt.then_stmts)) return true;
            }
            if (Has_Nested_In_Statements(&stmt->if_stmt.else_stmts)) return true;
        } else if (stmt->kind == NK_LOOP) {
            if (Has_Nested_In_Statements(&stmt->loop_stmt.statements)) return true;
        } else if (stmt->kind == NK_CASE) {
            for (uint32_t j = 0; j < stmt->case_stmt.alternatives.count; j++) {
                Syntax_Node *alt = stmt->case_stmt.alternatives.items[j];
                if (alt && alt->kind == NK_ASSOCIATION &&
                    alt->association.expression &&
                    alt->association.expression->kind == NK_BLOCK) {
                    if (Has_Nested_In_Statements(&alt->association.expression->block_stmt.statements)) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

static bool Has_Nested_Subprograms(Node_List *declarations, Node_List *statements) {
    /* Check declarations for procedure/function/task bodies.
     * Task bodies access enclosing scope variables just like nested
     * subprograms (RM 9.1), so the enclosing scope needs frame allocation. */
    if (declarations) {
        for (uint32_t i = 0; i < declarations->count; i++) {
            Syntax_Node *decl = declarations->items[i];
            if (decl && (decl->kind == NK_PROCEDURE_BODY ||
                         decl->kind == NK_FUNCTION_BODY ||
                         decl->kind == NK_TASK_BODY)) {
                return true;
            }
        }
    }
    /* Check statements for DECLARE blocks that might contain nested subprograms */
    return Has_Nested_In_Statements(statements);
}

static void Generate_Subprogram_Body(Code_Generator *cg, Syntax_Node *node) {
    /* Skip stub bodies (PROCEDURE X IS SEPARATE;) - the actual body
     * will be provided by a separate subunit compilation */
    if (node->subprogram_body.is_separate) {
        return;
    }

    /* Skip if code already generated for this body (prevents duplicates) */
    if (node->subprogram_body.code_generated) return;
    node->subprogram_body.code_generated = true;

    Syntax_Node *spec = node->subprogram_body.specification;
    Symbol *sym = spec ? spec->symbol : NULL;
    if (!sym) return;

    /* Mark this symbol as having been defined - prevents duplicate
     * 'declare' statements for functions defined in the same file */
    sym->extern_emitted = true;

    bool is_function = sym->kind == SYMBOL_FUNCTION;
    uint32_t saved_deferred_count = cg->deferred_count;

    /* Check if this is a nested function (has enclosing function) */
    Symbol *saved_enclosing = cg->enclosing_function;
    bool saved_is_nested = cg->is_nested;
    Symbol *parent_owner = sym->parent;

    /* Determine if nested: parent is a function/procedure */
    bool is_nested = parent_owner &&
                     (parent_owner->kind == SYMBOL_FUNCTION ||
                      parent_owner->kind == SYMBOL_PROCEDURE);
    cg->is_nested = is_nested;
    cg->enclosing_function = is_nested ? parent_owner : NULL;

    /* Function header */
    Emit(cg, "define %s @", is_function ? Type_To_Llvm(sym->return_type) : "void");
    Emit_Symbol_Name(cg, sym);
    Emit(cg, "(");

    /* If nested, first parameter is the frame pointer */
    if (is_nested) {
        Emit(cg, "ptr %%__parent_frame");
        if (sym->parameter_count > 0) Emit(cg, ", ");
    }

    /* Parameters */
    for (uint32_t i = 0; i < sym->parameter_count; i++) {
        if (i > 0) Emit(cg, ", ");
        /* OUT and IN OUT parameters are passed by reference */
        if (Param_Is_By_Reference(sym->parameters[i].mode)) {
            Emit(cg, "ptr %%p%u", i);
        } else {
            Emit(cg, "%s %%p%u", Type_To_Llvm(sym->parameters[i].param_type), i);
        }
    }

    Emit(cg, ") {\n");
    Emit(cg, "entry:\n");

    Symbol *saved_current_function = cg->current_function;
    cg->current_function = sym;
    cg->has_return = false;
    cg->block_terminated = false;  /* Reset for new function */

    /* Check if this function has nested subprograms (in declarations or DECLARE blocks) */
    bool has_nested = Has_Nested_Subprograms(&node->subprogram_body.declarations,
                                              &node->subprogram_body.statements);

    /* If this function has nested subprograms, allocate a frame base
     * This is the address that will be passed to nested functions */
    if (has_nested) {
        int64_t frame_size = (sym->scope && sym->scope->frame_size > 0)
            ? sym->scope->frame_size : 8;  /* At least 8 bytes for frame pointer */
        Emit(cg, "  ; Frame for nested function access\n");
        Emit(cg, "  %%__frame_base = alloca i8, i64 %lld\n", (long long)frame_size);
    }

    /* If nested, create aliases for accessing enclosing scope variables via frame */
    if (is_nested && parent_owner && parent_owner->scope) {
        /* Create pointer aliases to parent scope variables */
        Scope *parent_scope = parent_owner->scope;
        for (uint32_t i = 0; i < parent_scope->symbol_count; i++) {
            Symbol *var = parent_scope->symbols[i];
            if (var && (var->kind == SYMBOL_VARIABLE || var->kind == SYMBOL_PARAMETER)) {
                /* Create a GEP alias:  %__frame.VAR = getelementptr i8, ptr %__parent_frame, i64 offset */
                Emit(cg, "  %%__frame.");
                Emit_Symbol_Name(cg, var);
                Emit(cg, " = getelementptr i8, ptr %%__parent_frame, i64 %lld\n",
                     (long long)(var->frame_offset));
            }
        }
    }

    /* Allocate and store parameters to local stack slots
     * For OUT/IN OUT: param is already a pointer, use directly
     * For IN: allocate local slot and copy value */
    for (uint32_t i = 0; i < sym->parameter_count; i++) {
        Symbol *param_sym = sym->parameters[i].param_sym;
        if (param_sym) {
            const char *type_str = Type_To_Llvm(sym->parameters[i].param_type);
            Parameter_Mode mode = sym->parameters[i].mode;

            if (Param_Is_By_Reference(mode)) {
                /* OUT/IN OUT: %p is already a pointer to caller's variable
                 * Create an alias so the parameter name points to caller's storage */
                Emit(cg, "  %%");
                Emit_Symbol_Name(cg, param_sym);
                Emit(cg, " = getelementptr i8, ptr %%p%u, i64 0  ; by-ref param\n", i);
            } else if (has_nested && sym->scope) {
                /* IN param with nested functions: allocate in frame */
                Emit(cg, "  %%");
                Emit_Symbol_Name(cg, param_sym);
                Emit(cg, " = getelementptr i8, ptr %%__frame_base, i64 %lld\n",
                     (long long)param_sym->frame_offset);
                Emit(cg, "  store %s %%p%u, ptr %%", type_str, i);
                Emit_Symbol_Name(cg, param_sym);
                Emit(cg, "\n");
            } else {
                /* IN param: allocate local and copy value */
                Emit(cg, "  %%");
                Emit_Symbol_Name(cg, param_sym);
                Emit(cg, " = alloca %s\n", type_str);
                Emit(cg, "  store %s %%p%u, ptr %%", type_str, i);
                Emit_Symbol_Name(cg, param_sym);
                Emit(cg, "\n");
            }
        }
    }

    /* Generate local declarations, passing has_nested flag via cg for frame allocation.
     * Keep has_nested active for statements too (DECLARE blocks need it). */
    bool saved_has_nested = cg->current_nesting_level > 0;  /* Repurpose field temporarily */
    cg->current_nesting_level = has_nested ? 1 : 0;
    Generate_Declaration_List(cg, &node->subprogram_body.declarations);
    /* Don't reset yet - statements may have DECLARE blocks with tasks needing frame */

    /* Check if subprogram has exception handlers */
    bool has_exc_handlers = node->subprogram_body.handlers.count > 0;

    if (has_exc_handlers) {
        /* Setup exception handling using setjmp/longjmp */
        uint32_t handler_frame = Emit_Temp(cg);
        uint32_t handler_label = Emit_Label(cg);
        uint32_t normal_label = Emit_Label(cg);
        uint32_t end_label = Emit_Label(cg);

        /* Allocate handler frame: { ptr prev, [200 x i8] jmp_buf } */
        Emit(cg, "  %%t%u = alloca { ptr, [200 x i8] }, align 16  ; handler frame\n", handler_frame);

        /* Push exception handler */
        Emit(cg, "  call void @__ada_push_handler(ptr %%t%u)\n", handler_frame);

        /* Call setjmp on the jmp_buf field (field 1) */
        uint32_t jmp_buf = Emit_Temp(cg);
        Emit(cg, "  %%t%u = getelementptr { ptr, [200 x i8] }, ptr %%t%u, i32 0, i32 1\n",
             jmp_buf, handler_frame);
        uint32_t setjmp_result = Emit_Temp(cg);
        Emit(cg, "  %%t%u = call i32 @setjmp(ptr %%t%u)\n", setjmp_result, jmp_buf);

        /* Branch based on setjmp return */
        uint32_t is_normal = Emit_Temp(cg);
        Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", is_normal, setjmp_result);
        Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
             is_normal, normal_label, handler_label);

        /* Normal execution path */
        Emit(cg, "L%u:\n", normal_label);

        /* Generate statements */
        Generate_Statement_List(cg, &node->subprogram_body.statements);

        /* Pop handler on normal exit */
        Emit(cg, "  call void @__ada_pop_handler()\n");
        Emit(cg, "  br label %%L%u\n", end_label);

        /* Exception handler entry */
        Emit(cg, "L%u:\n", handler_label);
        Emit(cg, "  call void @__ada_pop_handler()\n");

        /* Get current exception identity */
        uint32_t exc_id = Emit_Temp(cg);
        Emit(cg, "  %%t%u = call i64 @__ada_current_exception()\n", exc_id);

        /* Generate exception handlers */
        uint32_t next_handler = 0;
        for (uint32_t i = 0; i < node->subprogram_body.handlers.count; i++) {
            Syntax_Node *handler = node->subprogram_body.handlers.items[i];
            if (!handler) continue;

            if (next_handler != 0) {
                Emit(cg, "L%u:\n", next_handler);
            }
            next_handler = Emit_Label(cg);
            uint32_t handler_body = Emit_Label(cg);

            /* Check each exception name in the handler */
            bool has_others = false;
            for (uint32_t j = 0; j < handler->handler.exceptions.count; j++) {
                Syntax_Node *exc_name = handler->handler.exceptions.items[j];
                if (exc_name->kind == NK_OTHERS) {
                    has_others = true;
                    break;
                }
            }

            if (has_others) {
                /* WHEN OTHERS => catches all */
                Emit(cg, "  br label %%L%u\n", handler_body);
            } else {
                /* Check against specific exceptions */
                for (uint32_t j = 0; j < handler->handler.exceptions.count; j++) {
                    Syntax_Node *exc_name = handler->handler.exceptions.items[j];
                    if (exc_name->symbol) {
                        uint32_t exc_ptr = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = ptrtoint ptr @__exc.", exc_ptr);
                        Emit_Symbol_Name(cg, exc_name->symbol);
                        Emit(cg, " to i64\n");
                        uint32_t match = Emit_Temp(cg);
                        Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n",
                             match, exc_id, exc_ptr);
                        Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
                             match, handler_body, next_handler);
                    }
                }
            }

            /* Handler body */
            Emit(cg, "L%u:\n", handler_body);
            Generate_Statement_List(cg, &handler->handler.statements);
            Emit(cg, "  br label %%L%u\n", end_label);
        }

        /* If no handler matched, reraise */
        if (next_handler != 0) {
            Emit(cg, "L%u:\n", next_handler);
            Emit(cg, "  call void @__ada_reraise()\n");
            Emit(cg, "  unreachable\n");
        }

        /* End label - normal return point */
        Emit(cg, "L%u:\n", end_label);
    } else {
        /* Generate statements without exception handling */
        Generate_Statement_List(cg, &node->subprogram_body.statements);
    }

    /* Restore nesting level now that all code for this subprogram is generated */
    cg->current_nesting_level = saved_has_nested ? 1 : 0;

    /* Default return if block is not terminated */
    if (!cg->block_terminated) {
        if (is_function) {
            /* Emit unreachable - control shouldn't reach here in well-formed function */
            Emit(cg, "  unreachable\n");
        } else {
            Emit(cg, "  ret void\n");
        }
    }

    Emit(cg, "}\n\n");
    cg->current_function = saved_current_function;
    cg->is_nested = saved_is_nested;
    cg->enclosing_function = saved_enclosing;

    /* Emit deferred nested subprogram/task bodies */
    while (cg->deferred_count > saved_deferred_count) {
        Syntax_Node *deferred = cg->deferred_bodies[--cg->deferred_count];
        if (deferred->kind == NK_GENERIC_INST) {
            /* Handle deferred generic instance */
            Symbol *inst = deferred->symbol;
            if (inst && inst->generic_template && inst->generic_template->generic_body) {
                Symbol *saved = cg->current_instance;
                cg->current_instance = inst;
                Generate_Generic_Instance_Body(cg, inst, inst->generic_template->generic_body);
                cg->current_instance = saved;
            }
        } else if (deferred->kind == NK_TASK_BODY) {
            Generate_Task_Body(cg, deferred);
        } else {
            Generate_Subprogram_Body(cg, deferred);
        }
    }
}

/* Generate code for a generic instance body */
static void Generate_Generic_Instance_Body(Code_Generator *cg, Symbol *inst_sym,
                                           Syntax_Node *template_body) {
    if (!inst_sym || !template_body) return;

    /* Handle package instantiation specially: generate package body declarations
     * (global variables), then iterate through exported subprograms. */
    if (inst_sym->kind == SYMBOL_PACKAGE && template_body->kind == NK_PACKAGE_BODY) {
        /* Set current instance so names are prefixed with instance name */
        Symbol *saved_instance = cg->current_instance;
        cg->current_instance = inst_sym;

        /* First, emit any global declarations from the package body
         * (e.g., FILES, BUFFERS, NEXT_FD in DIRECT_IO). These need unique names
         * based on the instance to avoid collisions. */
        for (uint32_t i = 0; i < template_body->package_body.declarations.count; i++) {
            Syntax_Node *decl = template_body->package_body.declarations.items[i];
            if (!decl) continue;
            /* Only generate non-subprogram declarations (variables, types) */
            if (decl->kind != NK_PROCEDURE_BODY && decl->kind != NK_FUNCTION_BODY &&
                decl->kind != NK_PROCEDURE_SPEC && decl->kind != NK_FUNCTION_SPEC) {
                Generate_Declaration(cg, decl);
            }
        }

        /* Then generate the subprogram bodies */
        for (uint32_t i = 0; i < inst_sym->exported_count; i++) {
            Symbol *exp = inst_sym->exported[i];
            if (!exp) continue;
            if (exp->kind != SYMBOL_FUNCTION && exp->kind != SYMBOL_PROCEDURE)
                continue;

            /* Count which Nth homograph this is in the export list */
            uint32_t homograph_idx = 0;
            for (uint32_t k = 0; k < i; k++) {
                Symbol *prev = inst_sym->exported[k];
                if (prev && (prev->kind == SYMBOL_FUNCTION || prev->kind == SYMBOL_PROCEDURE) &&
                    Slice_Equal_Ignore_Case(prev->name, exp->name)) {
                    homograph_idx++;
                }
            }

            /* Find the Nth body with this name */
            Syntax_Node *subp_body = NULL;
            uint32_t body_homograph_idx = 0;
            for (uint32_t j = 0; j < template_body->package_body.declarations.count; j++) {
                Syntax_Node *decl = template_body->package_body.declarations.items[j];
                if (!decl) continue;
                if (decl->kind == NK_PROCEDURE_BODY || decl->kind == NK_FUNCTION_BODY) {
                    if (Slice_Equal_Ignore_Case(decl->subprogram_body.specification->subprogram_spec.name, exp->name)) {
                        if (body_homograph_idx == homograph_idx) {
                            subp_body = decl;
                            break;
                        }
                        body_homograph_idx++;
                    }
                }
            }
            if (subp_body) {
                Generate_Generic_Instance_Body(cg, exp, subp_body);
            }
        }
        return;
    }

    bool is_function = inst_sym->kind == SYMBOL_FUNCTION;
    uint32_t saved_deferred_count = cg->deferred_count;

    /* Set current instance for formal subprogram substitution during codegen */
    Symbol *saved_current_instance = cg->current_instance;
    cg->current_instance = inst_sym;

    /* For generic instances, determine nesting from instance parent */
    Symbol *saved_enclosing = cg->enclosing_function;
    bool saved_is_nested = cg->is_nested;
    Symbol *parent_owner = inst_sym->parent;

    bool is_nested = parent_owner &&
                     (parent_owner->kind == SYMBOL_FUNCTION ||
                      parent_owner->kind == SYMBOL_PROCEDURE);
    cg->is_nested = is_nested;
    cg->enclosing_function = is_nested ? parent_owner : NULL;

    /* Function header */
    Emit(cg, "define %s @", is_function ? Type_To_Llvm(inst_sym->return_type) : "void");
    Emit_Symbol_Name(cg, inst_sym);
    Emit(cg, "(");

    /* If nested, first parameter is the frame pointer */
    if (is_nested) {
        Emit(cg, "ptr %%__parent_frame");
        if (inst_sym->parameter_count > 0) Emit(cg, ", ");
    }

    /* Parameters - use instance symbol's types (already substituted)
     * OUT/IN OUT params are passed by reference (ptr) */
    for (uint32_t i = 0; i < inst_sym->parameter_count; i++) {
        if (i > 0) Emit(cg, ", ");
        if (Param_Is_By_Reference(inst_sym->parameters[i].mode)) {
            Emit(cg, "ptr %%p%u", i);
        } else {
            Emit(cg, "%s %%p%u", Type_To_Llvm(inst_sym->parameters[i].param_type), i);
        }
    }

    Emit(cg, ") {\n");
    Emit(cg, "entry:\n");

    Symbol *saved_current_function = cg->current_function;
    cg->current_function = inst_sym;
    cg->has_return = false;
    cg->block_terminated = false;  /* Reset for new function */

    /* Get parameter symbols from template body's specification (they have
     * the unique_ids that match the body's code references) */
    Syntax_Node *body_spec = template_body->subprogram_body.specification;
    uint32_t param_idx = 0;
    if (body_spec) {
        Node_List *params = &body_spec->subprogram_spec.parameters;
        for (uint32_t i = 0; i < params->count && param_idx < inst_sym->parameter_count; i++) {
            Syntax_Node *ps = params->items[i];
            if (ps && ps->kind == NK_PARAM_SPEC) {
                for (uint32_t j = 0; j < ps->param_spec.names.count && param_idx < inst_sym->parameter_count; j++) {
                    Syntax_Node *pname = ps->param_spec.names.items[j];
                    Symbol *param_sym = pname->symbol;
                    if (param_sym) {
                        const char *type_str = Type_To_Llvm(inst_sym->parameters[param_idx].param_type);
                        Parameter_Mode mode = inst_sym->parameters[param_idx].mode;

                        if (Param_Is_By_Reference(mode)) {
                            /* OUT/IN OUT: %p is already a pointer to caller's variable
                             * Create an alias so the parameter name points to caller's storage */
                            Emit(cg, "  %%");
                            Emit_Symbol_Name(cg, param_sym);
                            Emit(cg, " = getelementptr i8, ptr %%p%u, i64 0  ; by-ref param\n", param_idx);
                        } else {
                            /* IN param: allocate local and copy value */
                            Emit(cg, "  %%");
                            Emit_Symbol_Name(cg, param_sym);
                            Emit(cg, " = alloca %s\n", type_str);
                            Emit(cg, "  store %s %%p%u, ptr %%", type_str, param_idx);
                            Emit_Symbol_Name(cg, param_sym);
                            Emit(cg, "\n");
                        }
                    }
                    param_idx++;
                }
            }
        }
    }

    /* Generate the body statements with type substitution */
    Syntax_Node *body = template_body;

    /* Generate local declarations */
    Generate_Declaration_List(cg, &body->subprogram_body.declarations);

    /* Generate statements from template body */
    for (uint32_t i = 0; i < body->subprogram_body.statements.count; i++) {
        Syntax_Node *stmt = body->subprogram_body.statements.items[i];
        if (stmt) {
            Generate_Statement(cg, stmt);
        }
    }

    /* Default return if block is not terminated */
    if (!cg->block_terminated) {
        if (is_function) {
            Emit(cg, "  unreachable\n");
        } else {
            Emit(cg, "  ret void\n");
        }
    }

    Emit(cg, "}\n\n");
    cg->current_function = saved_current_function;
    cg->is_nested = saved_is_nested;
    cg->enclosing_function = saved_enclosing;
    cg->current_instance = saved_current_instance;

    /* Process deferred bodies */
    while (cg->deferred_count > saved_deferred_count) {
        Syntax_Node *deferred = cg->deferred_bodies[--cg->deferred_count];
        if (deferred->kind == NK_GENERIC_INST) {
            Symbol *inst = deferred->symbol;
            if (inst && inst->generic_template && inst->generic_template->generic_body) {
                Symbol *saved = cg->current_instance;
                cg->current_instance = inst;
                Generate_Generic_Instance_Body(cg, inst, inst->generic_template->generic_body);
                cg->current_instance = saved;
            }
        } else if (deferred->kind == NK_TASK_BODY) {
            Generate_Task_Body(cg, deferred);
        } else {
            Generate_Subprogram_Body(cg, deferred);
        }
    }
}

static void Generate_Task_Body(Code_Generator *cg, Syntax_Node *node) {
    /* Skip stub bodies (TASK BODY X IS SEPARATE;) - the actual body
     * will be provided by a separate subunit compilation */
    if (node->task_body.is_separate) {
        Emit(cg, "\n; Task body stub: %.*s (defined in separate subunit)\n",
             (int)node->task_body.name.length, node->task_body.name.data);
        return;
    }

    Emit(cg, "\n; Task body: %.*s\n",
         (int)node->task_body.name.length, node->task_body.name.data);

    /* Generate task entry point function - receives parent frame pointer
     * for uplevel variable access (task bodies access enclosing scope).
     * For task bodies inside generic instances, prefix with instance name
     * to make the function name unique across multiple instantiations. */
    Emit(cg, "define void @task_");
    if (cg->current_instance && cg->current_instance->generic_template) {
        /* Emit instance name prefix for unique task body function */
        String_Slice inst_mangled = Symbol_Mangle_Name(cg->current_instance);
        for (uint32_t i = 0; i < inst_mangled.length; i++) {
            fputc(inst_mangled.data[i], cg->output);
        }
        Emit(cg, "__");
    }
    Emit(cg, "%.*s(ptr %%__parent_frame) {\n",
         (int)node->task_body.name.length, node->task_body.name.data);
    Emit(cg, "entry:\n");

    /* Save and set context - task body is like a nested function */
    Symbol *saved_current_function = cg->current_function;
    bool saved_is_nested = cg->is_nested;
    Symbol *saved_enclosing = cg->enclosing_function;
    cg->current_function = node->symbol;
    cg->is_nested = true;  /* Task bodies are nested in enclosing scope */
    cg->enclosing_function = saved_current_function;  /* Access parent's vars */

    /* Reset temp counter for new function */
    uint32_t saved_temp = cg->temp_id;
    cg->temp_id = 1;

    /* Create frame aliases for accessing enclosing scope variables.
     * Task bodies can reference variables from the enclosing scope
     * (RM 9.1). The parent passed %__parent_frame pointing to its frame.
     * Use the task symbol's defining_scope to get the correct scope
     * (important for tasks in DECLARE blocks which have their own scope). */
    Scope *parent_scope = node->symbol ? node->symbol->defining_scope : NULL;
    if (parent_scope) {
        for (uint32_t i = 0; i < parent_scope->symbol_count; i++) {
            Symbol *var = parent_scope->symbols[i];
            if (var && (var->kind == SYMBOL_VARIABLE || var->kind == SYMBOL_PARAMETER)) {
                /* Create a GEP alias: %__frame.VAR = getelementptr ptr %__parent_frame, offset */
                Emit(cg, "  %%__frame.");
                Emit_Symbol_Name(cg, var);
                Emit(cg, " = getelementptr i8, ptr %%__parent_frame, i64 %lld\n",
                     (long long)(var->frame_offset));
            }
        }
    }

    /* Push exception handler for task: { ptr prev, [200 x i8] jmp_buf } */
    uint32_t handler_frame = Emit_Temp(cg);
    Emit(cg, "  %%t%u = alloca { ptr, [200 x i8] }, align 16  ; handler frame\n", handler_frame);
    Emit(cg, "  call void @__ada_push_handler(ptr %%t%u)\n", handler_frame);
    uint32_t jmp_buf = Emit_Temp(cg);
    Emit(cg, "  %%t%u = getelementptr { ptr, [200 x i8] }, ptr %%t%u, i32 0, i32 1\n",
         jmp_buf, handler_frame);
    uint32_t setjmp_result = Emit_Temp(cg);
    Emit(cg, "  %%t%u = call i32 @setjmp(ptr %%t%u)\n", setjmp_result, jmp_buf);
    uint32_t is_zero = Emit_Temp(cg);
    Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", is_zero, setjmp_result);
    uint32_t body_label = Emit_Label(cg);
    uint32_t exit_label = Emit_Label(cg);
    Emit(cg, "  br i1 %%t%u, label %%L%u, label %%L%u\n",
         is_zero, body_label, exit_label);

    /* Normal execution path */
    Emit(cg, "L%u:\n", body_label);
    cg->block_terminated = false;  /* Reset after br target label */
    Generate_Declaration_List(cg, &node->task_body.declarations);
    Generate_Statement_List(cg, &node->task_body.statements);
    Emit(cg, "  call void @__ada_pop_handler()\n");
    Emit(cg, "  ret void\n");

    /* Exception handler path */
    Emit(cg, "L%u:\n", exit_label);
    Emit(cg, "  call void @__ada_pop_handler()\n");
    /* Task terminates silently on unhandled exception */
    Emit(cg, "  ret void\n");

    Emit(cg, "}\n\n");

    /* Restore context */
    cg->temp_id = saved_temp;
    cg->current_function = saved_current_function;
    cg->is_nested = saved_is_nested;
    cg->enclosing_function = saved_enclosing;
}

static void Generate_Declaration(Code_Generator *cg, Syntax_Node *node) {
    if (!node) return;

    switch (node->kind) {
        case NK_OBJECT_DECL:
            Generate_Object_Declaration(cg, node);
            break;

        case NK_PROCEDURE_SPEC:
        case NK_FUNCTION_SPEC:
            /* Forward declaration - if imported, emit extern declaration */
            if (node->symbol && node->symbol->is_imported) {
                Emit_Extern_Subprogram(cg, node->symbol);
            }
            break;

        case NK_PROCEDURE_BODY:
        case NK_FUNCTION_BODY:
            /* Defer nested subprogram bodies - emit after enclosing function */
            /* Skip if already generated (prevents duplicates from re-processing) */
            if (node->subprogram_body.code_generated) break;
            if (cg->current_function && cg->deferred_count < 64) {
                /* Check for duplicate in deferred list */
                bool already_deferred = false;
                for (uint32_t d = 0; d < cg->deferred_count; d++) {
                    if (cg->deferred_bodies[d] == node) {
                        already_deferred = true;
                        break;
                    }
                }
                if (!already_deferred) {
                    cg->deferred_bodies[cg->deferred_count++] = node;
                }
            } else {
                Generate_Subprogram_Body(cg, node);
            }
            break;

        case NK_PACKAGE_BODY:
            {
                Symbol *pkg_sym = node->symbol;  /* Use symbol from semantic analysis */

                /* Skip generic package bodies - code is generated only for instances */
                if (pkg_sym && pkg_sym->kind == SYMBOL_GENERIC) {
                    break;
                }

                /* First, emit package spec's object declarations (constants, variables) */
                if (pkg_sym && pkg_sym->kind == SYMBOL_PACKAGE && pkg_sym->declaration) {
                    Syntax_Node *spec = pkg_sym->declaration;
                    if (spec->kind == NK_PACKAGE_SPEC) {
                        /* Emit visible object declarations from spec */
                        for (uint32_t i = 0; i < spec->package_spec.visible_decls.count; i++) {
                            Syntax_Node *decl = spec->package_spec.visible_decls.items[i];
                            if (decl && decl->kind == NK_OBJECT_DECL) {
                                Generate_Object_Declaration(cg, decl);
                            }
                        }
                        /* Emit private object declarations from spec */
                        for (uint32_t i = 0; i < spec->package_spec.private_decls.count; i++) {
                            Syntax_Node *decl = spec->package_spec.private_decls.items[i];
                            if (decl && decl->kind == NK_OBJECT_DECL) {
                                Generate_Object_Declaration(cg, decl);
                            }
                        }
                    }
                }

                Generate_Declaration_List(cg, &node->package_body.declarations);
            /* Generate initialization function if initialization statements present */
            if (node->package_body.statements.count > 0) {
                /* Emit init function header */
                Emit(cg, "\n; Package body initialization\n");
                Emit(cg, "define void @");
                /* Use mangled package name + ___init suffix */
                if (pkg_sym) {
                    Emit_Symbol_Name(cg, pkg_sym);
                } else {
                    /* Fallback to package body name */
                    for (uint32_t i = 0; i < node->package_body.name.length; i++) {
                        char c = node->package_body.name.data[i];
                        Emit(cg, "%c", (c >= 'A' && c <= 'Z') ? c + 32 : c);
                    }
                }
                Emit(cg, "___init() {\n");
                Emit(cg, "entry:\n");

                /* Save and set current function context for statement generation */
                Symbol *saved_current_function = cg->current_function;
                cg->current_function = pkg_sym;  /* Use package as context */
                cg->block_terminated = false;

                Generate_Statement_List(cg, &node->package_body.statements);

                /* Emit return and close function */
                if (!cg->block_terminated) {
                    Emit(cg, "  ret void\n");
                }
                Emit(cg, "}\n\n");

                cg->current_function = saved_current_function;
            }
            }
            break;

        case NK_GENERIC_INST:
            /* Generate code for generic instantiation. Per Ada RM 12.3: "The
             * elaboration of a generic instantiation declares an instance" */
            {
                Symbol *inst_sym = node->symbol;
                if (!inst_sym || !inst_sym->generic_template) break;

                Symbol *template = inst_sym->generic_template;
                Symbol *saved_instance = cg->current_instance;
                cg->current_instance = inst_sym;

                /* For library-level package instances, emit global variables for
                 * exported objects REGARDLESS of whether there's a body. Generic
                 * packages may have just a spec with object declarations. */
                if (!cg->current_function && inst_sym->kind == SYMBOL_PACKAGE) {
                    /* Find the generic spec to get initializers */
                    Syntax_Node *gen_spec = template->generic_unit;

                    for (uint32_t i = 0; i < inst_sym->exported_count; i++) {
                        Symbol *exp = inst_sym->exported[i];
                        if (!exp) continue;
                        if (exp->kind != SYMBOL_VARIABLE && exp->kind != SYMBOL_CONSTANT)
                            continue;
                        Type_Info *ty = exp->type;
                        const char *type_str = Type_To_Llvm(ty);
                        bool is_array = ty && ty->kind == TYPE_ARRAY && ty->array.is_constrained;
                        bool is_record = ty && ty->kind == TYPE_RECORD;

                        /* Look for initializer in the generic spec's visible declarations */
                        int64_t init_val = 0;
                        bool has_init = false;
                        if (gen_spec && gen_spec->kind == NK_PACKAGE_SPEC) {
                            for (uint32_t j = 0; j < gen_spec->package_spec.visible_decls.count; j++) {
                                Syntax_Node *decl = gen_spec->package_spec.visible_decls.items[j];
                                if (!decl || decl->kind != NK_OBJECT_DECL) continue;
                                for (uint32_t k = 0; k < decl->object_decl.names.count; k++) {
                                    Syntax_Node *nm = decl->object_decl.names.items[k];
                                    if (nm && Slice_Equal_Ignore_Case(nm->string_val.text, exp->name)) {
                                        if (decl->object_decl.init &&
                                            decl->object_decl.init->kind == NK_INTEGER) {
                                            init_val = decl->object_decl.init->integer_lit.value;
                                            has_init = true;
                                        }
                                        break;
                                    }
                                }
                                if (has_init) break;
                            }
                        }

                        Emit(cg, "@");
                        Emit_Symbol_Name(cg, exp);
                        if (is_array) {
                            int64_t cnt = Array_Element_Count(ty);
                            const char *elem_type = Type_To_Llvm(ty->array.element_type);
                            Emit(cg, " = linkonce_odr global [%lld x %s] zeroinitializer\n",
                                 (long long)cnt, elem_type);
                        } else if (is_record) {
                            Emit(cg, " = linkonce_odr global [%u x i8] zeroinitializer\n", ty->size);
                        } else {
                            Emit(cg, " = linkonce_odr global %s %lld\n", type_str,
                                 (long long)init_val);
                        }
                    }
                }

                /* Prefer expanded_body (with substitutions already applied)
                 * over template->generic_body (requires runtime substitution) */
                Syntax_Node *generic_body = inst_sym->expanded_body;
                if (!generic_body) generic_body = template->generic_body;
                if (!generic_body) {
                    cg->current_instance = saved_instance;
                    break;  /* No body: globals already emitted above */
                }

                /* Generate instantiated body using the instance's symbol */
                if (cg->current_function && inst_sym->kind == SYMBOL_PACKAGE) {
                    /* Local generic package instance: allocate storage for exported
                     * variables/constants NOW (as local allocas), but defer subprogram
                     * bodies for later. Per Ada RM 12.3: "The elaboration of a generic
                     * instantiation declares an instance... and elaborates the instance" */
                    for (uint32_t i = 0; i < inst_sym->exported_count; i++) {
                        Symbol *exp = inst_sym->exported[i];
                        if (!exp) continue;
                        if (exp->kind == SYMBOL_VARIABLE || exp->kind == SYMBOL_CONSTANT) {
                            /* Allocate local storage for package variable */
                            Type_Info *ty = exp->type;
                            const char *type_str = Type_To_Llvm(ty);
                            bool is_array = ty && ty->kind == TYPE_ARRAY && ty->array.is_constrained;
                            bool is_record = ty && ty->kind == TYPE_RECORD;
                            Emit(cg, "  %%");
                            Emit_Symbol_Name(cg, exp);
                            if (is_array) {
                                int64_t cnt = Array_Element_Count(ty);
                                const char *elem_type = Type_To_Llvm(ty->array.element_type);
                                Emit(cg, " = alloca [%lld x %s]  ; local pkg var\n", (long long)cnt, elem_type);
                            } else if (is_record) {
                                Emit(cg, " = alloca [%u x i8]  ; local pkg record\n", ty->size);
                            } else {
                                Emit(cg, " = alloca %s  ; local pkg var\n", type_str);
                            }
                            /* Initialize from package body if present */
                            if (generic_body && generic_body->kind == NK_PACKAGE_BODY) {
                                /* Look for assignment in BEGIN..END section targeting this var.
                                 * Compare by name since body symbol differs from exported symbol. */
                                for (uint32_t j = 0; j < generic_body->package_body.statements.count; j++) {
                                    Syntax_Node *stmt = generic_body->package_body.statements.items[j];
                                    if (!stmt || stmt->kind != NK_ASSIGNMENT) continue;
                                    Syntax_Node *tgt = stmt->assignment.target;
                                    if (!tgt) continue;
                                    String_Slice tgt_name = {0};
                                    if (tgt->kind == NK_IDENTIFIER)
                                        tgt_name = tgt->string_val.text;
                                    else if (tgt->symbol)
                                        tgt_name = tgt->symbol->name;
                                    if (tgt_name.data && Slice_Equal_Ignore_Case(tgt_name, exp->name)) {
                                        /* Redirect target to use local exported symbol */
                                        tgt->symbol = exp;
                                        Generate_Statement(cg, stmt);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    /* Defer subprogram bodies for later */
                    if (cg->deferred_count < 64)
                        cg->deferred_bodies[cg->deferred_count++] = node;
                } else if (cg->current_function && cg->deferred_count < 64) {
                    /* Defer nested generic subprogram instance */
                    cg->deferred_bodies[cg->deferred_count++] = node;
                } else if (inst_sym->kind == SYMBOL_PACKAGE) {
                    /* Global variables already emitted above. Now generate subprogram
                     * bodies, matching by homograph index. */
                    if (generic_body->kind == NK_PACKAGE_BODY) {
                        for (uint32_t i = 0; i < inst_sym->exported_count; i++) {
                            Symbol *exp = inst_sym->exported[i];
                            if (!exp) continue;
                            if (exp->kind != SYMBOL_FUNCTION && exp->kind != SYMBOL_PROCEDURE)
                                continue;

                            /* Count how many times this name appeared before in exports */
                            uint32_t homograph_idx = 0;
                            for (uint32_t k = 0; k < i; k++) {
                                Symbol *prev = inst_sym->exported[k];
                                if (prev && (prev->kind == SYMBOL_FUNCTION || prev->kind == SYMBOL_PROCEDURE) &&
                                    Slice_Equal_Ignore_Case(prev->name, exp->name)) {
                                    homograph_idx++;
                                }
                            }

                            /* Find the Nth body with this name */
                            Syntax_Node *subp_body = NULL;
                            uint32_t body_homograph_idx = 0;
                            for (uint32_t j = 0; j < generic_body->package_body.declarations.count; j++) {
                                Syntax_Node *decl = generic_body->package_body.declarations.items[j];
                                if (!decl) continue;
                                if (decl->kind == NK_PROCEDURE_BODY || decl->kind == NK_FUNCTION_BODY) {
                                    if (Slice_Equal_Ignore_Case(decl->subprogram_body.specification->subprogram_spec.name, exp->name)) {
                                        if (body_homograph_idx == homograph_idx) {
                                            subp_body = decl;
                                            break;
                                        }
                                        body_homograph_idx++;
                                    }
                                }
                            }
                            if (subp_body) {
                                Generate_Generic_Instance_Body(cg, exp, subp_body);
                            }
                        }
                    }
                } else {
                    Generate_Generic_Instance_Body(cg, inst_sym, generic_body);
                }

                cg->current_instance = saved_instance;
            }
            break;

        case NK_GENERIC_DECL:
            /* Generic declarations don't generate code - only instances do */
            break;

        case NK_TASK_SPEC:
            /* Task type/object specification - record entry points */
            Emit(cg, "; Task spec: %.*s (entries registered at runtime)\n",
                 (int)node->task_spec.name.length, node->task_spec.name.data);
            /* For single tasks (not task types), allocate task control block storage
             * and start the task body in a separate thread */
            if (!node->task_spec.is_type && node->symbol) {
                /* Find the variable symbol in the type symbol's defining scope.
                 * The type and variable were both added to the same scope during
                 * semantic analysis. Use defining_scope instead of sm->current_scope
                 * since current_scope may have changed during code generation. */
                Symbol *obj_sym = NULL;
                Scope *scope = node->symbol->defining_scope;
                if (scope) {
                    for (uint32_t i = 0; i < scope->symbol_count; i++) {
                        Symbol *s = scope->symbols[i];
                        if (s && s->kind == SYMBOL_VARIABLE &&
                            s->type && s->type->kind == TYPE_TASK &&
                            Slice_Equal_Ignore_Case(s->name, node->task_spec.name)) {
                            obj_sym = s;
                            break;
                        }
                    }
                }
                if (obj_sym) {
                    if (obj_sym->unique_id == 0) {
                        obj_sym->unique_id = cg->sm->next_unique_id++;
                    }
                    /* Allocate task object - use frame if nested, else stack */
                    bool use_frame = cg->current_nesting_level > 0;
                    if (use_frame) {
                        Emit(cg, "  %%");
                        Emit_Symbol_Name(cg, obj_sym);
                        Emit(cg, " = getelementptr i8, ptr %%__frame_base, i64 %lld  ; task in frame\n",
                             (long long)obj_sym->frame_offset);
                    } else {
                        Emit(cg, "  %%");
                        Emit_Symbol_Name(cg, obj_sym);
                        Emit(cg, " = alloca ptr  ; task control block\n");
                    }

                    /* Start the task body in a separate thread.
                     * Pass frame_base if nested, or null if at module level. */
                    uint32_t handle_tmp = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = call ptr @__ada_task_start(ptr @task_",
                         handle_tmp);
                    if (cg->current_instance && cg->current_instance->generic_template) {
                        /* Emit instance name prefix for unique task body function */
                        String_Slice inst_mangled = Symbol_Mangle_Name(cg->current_instance);
                        for (uint32_t i = 0; i < inst_mangled.length; i++) {
                            fputc(inst_mangled.data[i], cg->output);
                        }
                        Emit(cg, "__");
                    }
                    Emit(cg, "%.*s, ", (int)node->task_spec.name.length,
                         node->task_spec.name.data);
                    /* Pass parent frame for uplevel access, or null if at module level.
                     * Use frame_base only if the current function has nested subprograms. */
                    if (cg->current_nesting_level > 0) {
                        Emit(cg, "ptr %%__frame_base)\n");
                    } else {
                        Emit(cg, "ptr null)\n");
                    }
                    /* Store thread handle in task control block */
                    Emit(cg, "  store ptr %%t%u, ptr %%", handle_tmp);
                    Emit_Symbol_Name(cg, obj_sym);
                    Emit(cg, "\n");
                }
            }
            break;

        case NK_TASK_BODY:
            /* Defer task body generation when inside another function */
            if (cg->current_function && cg->deferred_count < 64) {
                cg->deferred_bodies[cg->deferred_count++] = node;
            } else {
                Generate_Task_Body(cg, node);
            }
            break;

        default:
            break;
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.6 Implicit Equality Function Generation
 *
 * Generate equality functions for composite types at freeze points.
 * Per RM 4.5.2, equality is predefined for all non-limited types.
 * The RM specifies the semantics and the compiler provides the implementation.
 * ───────────────────────────────────────────────────────────────────────── */

static void Generate_Type_Equality_Function(Code_Generator *cg, Type_Info *t) {
    if (!t || !t->equality_func_name) return;

    const char *func_name = t->equality_func_name;

    /* Determine parameter type based on array constrained-ness */
    bool is_unconstrained = Type_Is_Unconstrained_Array(t);
    const char *param_type = is_unconstrained ? FAT_PTR_TYPE : "ptr";

    /* Emit function definition with linkonce_odr for linker deduplication */
    Emit(cg, "\n; Implicit equality for type %.*s\n",
         (int)t->name.length, t->name.data);
    Emit(cg, "define linkonce_odr i1 @%s(%s %%0, %s %%1) {\n", func_name, param_type, param_type);
    Emit(cg, "entry:\n");

    /* Save and reset temp counter for this function */
    uint32_t saved_temp = cg->temp_id;
    cg->temp_id = 2;  /* Start after %0 and %1 */

    if (t->kind == TYPE_RECORD) {
        if (t->record.component_count == 0) {
            /* Empty record - always equal */
            Emit(cg, "  ret i1 1\n");
        } else {
            uint32_t result = 0;
            for (uint32_t i = 0; i < t->record.component_count; i++) {
                Component_Info *comp = &t->record.components[i];
                const char *comp_llvm_type = Type_To_Llvm(comp->component_type);

                /* Get pointers to components */
                uint32_t left_gep = Emit_Temp(cg);
                uint32_t right_gep = Emit_Temp(cg);
                Emit(cg, "  %%t%u = getelementptr i8, ptr %%0, i64 %u\n",
                     left_gep, comp->byte_offset);
                Emit(cg, "  %%t%u = getelementptr i8, ptr %%1, i64 %u\n",
                     right_gep, comp->byte_offset);

                /* Compare component - handle arrays/strings specially */
                uint32_t cmp;
                Type_Info *ct = comp->component_type;
                bool is_fat_ptr_access = ct && ct->kind == TYPE_ACCESS &&
                    ct->access.designated_type &&
                    (ct->access.designated_type->kind == TYPE_STRING ||
                     (ct->access.designated_type->kind == TYPE_ARRAY &&
                      !ct->access.designated_type->array.is_constrained));

                if (ct && (ct->kind == TYPE_STRING ||
                           (ct->kind == TYPE_ARRAY && !ct->array.is_constrained))) {
                    /* Unconstrained array/string - use array equality */
                    cmp = Generate_Array_Equality(cg, left_gep, right_gep, ct);
                } else if (ct && ct->kind == TYPE_ARRAY && ct->array.is_constrained) {
                    /* Constrained array - use array equality */
                    cmp = Generate_Array_Equality(cg, left_gep, right_gep, ct);
                } else if (ct && ct->kind == TYPE_RECORD) {
                    /* Nested record - recurse */
                    cmp = Generate_Record_Equality(cg, left_gep, right_gep, ct);
                } else if (is_fat_ptr_access) {
                    /* ACCESS to unconstrained array - compare fat pointer components */
                    uint32_t left_val = Emit_Temp(cg);
                    uint32_t right_val = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u\n", left_val, left_gep);
                    Emit(cg, "  %%t%u = load " FAT_PTR_TYPE ", ptr %%t%u\n", right_val, right_gep);
                    uint32_t lp = Emit_Temp(cg), rp = Emit_Temp(cg);
                    uint32_t ll = Emit_Temp(cg), rl = Emit_Temp(cg);
                    uint32_t lh = Emit_Temp(cg), rh = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 0\n", lp, left_val);
                    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 0\n", rp, right_val);
                    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 0\n", ll, left_val);
                    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 0\n", rl, right_val);
                    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 1\n", lh, left_val);
                    Emit(cg, "  %%t%u = extractvalue " FAT_PTR_TYPE " %%t%u, 1, 1\n", rh, right_val);
                    uint32_t cmp_p = Emit_Temp(cg), cmp_l = Emit_Temp(cg), cmp_h = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = icmp eq ptr %%t%u, %%t%u\n", cmp_p, lp, rp);
                    Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n", cmp_l, ll, rl);
                    Emit(cg, "  %%t%u = icmp eq i64 %%t%u, %%t%u\n", cmp_h, lh, rh);
                    uint32_t and1 = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", and1, cmp_p, cmp_l);
                    cmp = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n", cmp, and1, cmp_h);
                } else {
                    /* Scalar type - load and compare */
                    uint32_t left_val = Emit_Temp(cg);
                    uint32_t right_val = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = load %s, ptr %%t%u\n",
                         left_val, comp_llvm_type, left_gep);
                    Emit(cg, "  %%t%u = load %s, ptr %%t%u\n",
                         right_val, comp_llvm_type, right_gep);

                    cmp = Emit_Temp(cg);
                    if (Type_Is_Float_Representation(ct)) {
                        Emit(cg, "  %%t%u = fcmp oeq %s %%t%u, %%t%u\n",
                             cmp, comp_llvm_type, left_val, right_val);
                    } else {
                        Emit(cg, "  %%t%u = icmp eq %s %%t%u, %%t%u\n",
                             cmp, comp_llvm_type, left_val, right_val);
                    }
                }

                /* AND with previous results */
                if (i == 0) {
                    result = cmp;
                } else {
                    uint32_t and_result = Emit_Temp(cg);
                    Emit(cg, "  %%t%u = and i1 %%t%u, %%t%u\n",
                         and_result, result, cmp);
                    result = and_result;
                }
            }
            Emit(cg, "  ret i1 %%t%u\n", result);
        }
    } else if (Type_Is_Array_Like(t)) {
        if (t->array.is_constrained) {
            /* Constrained array - use memcmp */
            int64_t count = Array_Element_Count(t);
            uint32_t elem_size = t->array.element_type ?
                                 t->array.element_type->size : 4;
            int64_t total_size = count * elem_size;

            uint32_t result = Emit_Temp(cg);
            uint32_t cmp = Emit_Temp(cg);
            Emit(cg, "  %%t%u = call i32 @memcmp(ptr %%0, ptr %%1, i64 %lld)\n",
                 result, (long long)total_size);
            Emit(cg, "  %%t%u = icmp eq i32 %%t%u, 0\n", cmp, result);
            Emit(cg, "  ret i1 %%t%u\n", cmp);
        } else {
            /*
             * Unconstrained array equality (per RM 4.5.2):
             * Fat pointer layout: { ptr data, { i64 low, i64 high } }
             * Compare lengths first, then data if lengths match.
             */
            uint32_t elem_size = t->array.element_type ?
                                 t->array.element_type->size : 1;

            /* Extract bounds from first fat pointer (%0) */
            Emit(cg, "  %%left_low = extractvalue " FAT_PTR_TYPE " %%0, 1, 0\n");
            Emit(cg, "  %%left_high = extractvalue " FAT_PTR_TYPE " %%0, 1, 1\n");
            Emit(cg, "  %%left_len = sub i64 %%left_high, %%left_low\n");
            Emit(cg, "  %%left_len1 = add i64 %%left_len, 1\n");

            /* Extract bounds from second fat pointer (%1) */
            Emit(cg, "  %%right_low = extractvalue " FAT_PTR_TYPE " %%1, 1, 0\n");
            Emit(cg, "  %%right_high = extractvalue " FAT_PTR_TYPE " %%1, 1, 1\n");
            Emit(cg, "  %%right_len = sub i64 %%right_high, %%right_low\n");
            Emit(cg, "  %%right_len1 = add i64 %%right_len, 1\n");

            /* Compare lengths */
            Emit(cg, "  %%len_eq = icmp eq i64 %%left_len1, %%right_len1\n");

            /* Extract data pointers */
            Emit(cg, "  %%left_data = extractvalue " FAT_PTR_TYPE " %%0, 0\n");
            Emit(cg, "  %%right_data = extractvalue " FAT_PTR_TYPE " %%1, 0\n");

            /* Compute byte size and call memcmp */
            Emit(cg, "  %%byte_size = mul i64 %%left_len1, %u\n", elem_size);
            Emit(cg, "  %%memcmp_res = call i32 @memcmp(ptr %%left_data, ptr %%right_data, i64 %%byte_size)\n");
            Emit(cg, "  %%data_eq = icmp eq i32 %%memcmp_res, 0\n");

            /* Result: lengths match AND data matches */
            Emit(cg, "  %%result = and i1 %%len_eq, %%data_eq\n");
            Emit(cg, "  ret i1 %%result\n");
        }
    } else {
        /* Unknown composite type - return true */
        Emit(cg, "  ret i1 1\n");
    }

    Emit(cg, "}\n");
    cg->temp_id = saved_temp;  /* Restore temp counter */
}

static void Generate_Implicit_Operators(Code_Generator *cg) {
    /* Generate equality functions for all frozen composite types */
    for (uint32_t i = 0; i < Frozen_Composite_Count; i++) {
        Generate_Type_Equality_Function(cg, Frozen_Composite_Types[i]);
    }
}

/* Generate global constants for exception identities */
static void Generate_Exception_Globals(Code_Generator *cg) {
    /* Generate globals for all registered exceptions */
    if (Exception_Symbol_Count > 0) {
        Emit(cg, "; Exception identity globals\n");
        for (uint32_t i = 0; i < Exception_Symbol_Count; i++) {
            Symbol *sym = Exception_Symbols[i];
            Emit(cg, "@__exc.");
            Emit_Symbol_Name(cg, sym);
            Emit(cg, " = private constant i8 0\n");
        }
        Emit(cg, "\n");
    }
}

/* Check if external name is a builtin/runtime function (already defined) */
static bool Is_Builtin_Function(String_Slice name) {
    /* Strip quotes if present */
    if (name.length >= 2 && name.data[0] == '"' && name.data[name.length-1] == '"') {
        name.data++;
        name.length -= 2;
    }
    const char *builtins[] = {
        /* Custom text_io helpers */
        "__text_io_new_line", "__text_io_put_char", "__text_io_put",
        "__text_io_put_line", "__text_io_put_int", "__text_io_put_float",
        "__text_io_get_char", "__text_io_get_line",
        /* Standard C library functions (declared in runtime preamble) */
        "memcmp", "setjmp", "longjmp", "exit", "malloc", "realloc", "free",
        "usleep", "printf", "putchar", "strtod", "snprintf", "strlen",
        "fputc", "fputs", "fgetc", "fgets", "fprintf",
        "fopen", "fclose", "fflush", "feof", "ftell", "fseek",
        "ungetc", "remove", "getchar",
        NULL
    };
    for (int i = 0; builtins[i]; i++) {
        if (name.length == strlen(builtins[i]) &&
            memcmp(name.data, builtins[i], name.length) == 0) {
            return true;
        }
    }
    return false;
}

/* Emit function signature for extern declaration */
static void Emit_Extern_Subprogram(Code_Generator *cg, Symbol *sym) {
    if (!sym) return;
    if (sym->kind != SYMBOL_FUNCTION && sym->kind != SYMBOL_PROCEDURE) return;

    /* Skip if already emitted */
    if (sym->extern_emitted) return;
    sym->extern_emitted = true;

    /* Skip if this is a builtin function that we've already defined */
    if (sym->is_imported && sym->external_name.length > 0) {
        if (Is_Builtin_Function(sym->external_name)) {
            return;
        }
    }

    /* Get return type */
    const char *ret_type = sym->return_type ? Type_To_Llvm(sym->return_type) : "void";

    Emit(cg, "declare %s @", ret_type);
    Emit_Symbol_Name(cg, sym);
    Emit(cg, "(");

    /* Emit parameter types */
    for (uint32_t i = 0; i < sym->parameter_count; i++) {
        if (i > 0) Emit(cg, ", ");
        /* Handle ALI-loaded symbols without full parameter info */
        Type_Info *ty = (sym->parameters && i < sym->parameter_count)
                        ? sym->parameters[i].param_type : NULL;
        if (ty) {
            /* Unconstrained arrays pass as fat pointers */
            if ((ty->kind == TYPE_ARRAY && !ty->array.is_constrained) ||
                ty->kind == TYPE_STRING) {
                Emit(cg, FAT_PTR_TYPE);
            } else {
                Emit(cg, "%s", Type_To_Llvm(ty));
            }
        } else {
            Emit(cg, "i64");  /* Default to i64 for unknown/missing parameter types */
        }
    }
    Emit(cg, ")\n");
}

/* Generate extern declarations for all loaded package specs */
static void Generate_Extern_Declarations(Code_Generator *cg, Syntax_Node *node) {
    if (!node || !node->compilation_unit.context) return;

    Syntax_Node *ctx = node->compilation_unit.context;
    bool emitted_header = false;

    /* Iterate through WITH'd packages */
    for (uint32_t i = 0; i < ctx->context.with_clauses.count; i++) {
        Syntax_Node *with_node = ctx->context.with_clauses.items[i];
        for (uint32_t j = 0; j < with_node->use_clause.names.count; j++) {
            Syntax_Node *pkg_name = with_node->use_clause.names.items[j];
            if (pkg_name->kind != NK_IDENTIFIER) continue;

            Symbol *pkg_sym = pkg_name->symbol;
            if (!pkg_sym || pkg_sym->kind != SYMBOL_PACKAGE) continue;

            /* Skip extern declarations for packages whose bodies will be code-generated.
             * Those symbols will be defined, not external. */
            if (Body_Already_Loaded(pkg_sym->name)) continue;

            /* For ALI-loaded packages without declaration, use exported[] array */
            if (!pkg_sym->declaration && pkg_sym->exported_count > 0) {
                for (uint32_t k = 0; k < pkg_sym->exported_count; k++) {
                    Symbol *sym = pkg_sym->exported[k];
                    if (!sym) continue;
                    if (sym->kind == SYMBOL_FUNCTION || sym->kind == SYMBOL_PROCEDURE) {
                        if (!emitted_header) {
                            Emit(cg, "\n; External Ada subprogram declarations\n");
                            emitted_header = true;
                        }
                        Emit_Extern_Subprogram(cg, sym);
                    } else if (sym->kind == SYMBOL_VARIABLE || sym->kind == SYMBOL_CONSTANT) {
                        if (!sym->is_named_number && !sym->extern_emitted) {
                            sym->extern_emitted = true;
                            Type_Info *ty = sym->type;
                            const char *type_str = Type_To_Llvm(ty);
                            bool is_string = ty && (ty->kind == TYPE_STRING ||
                                (ty->kind == TYPE_ARRAY && !ty->array.is_constrained &&
                                 ty->array.element_type &&
                                 ty->array.element_type->kind == TYPE_CHARACTER));
                            if (is_string) type_str = "{ ptr, { i64, i64 } }";
                            Emit(cg, "@");
                            Emit_Symbol_Name(cg, sym);
                            Emit(cg, " = external global %s\n", type_str);
                        }
                    }
                }
                continue;  /* Done with this package */
            }

            if (!pkg_sym->declaration) continue;

            Syntax_Node *pkg_decl = pkg_sym->declaration;
            if (pkg_decl->kind != NK_PACKAGE_SPEC) continue;

            /* Emit extern for each subprogram and object in the package */
            for (uint32_t k = 0; k < pkg_decl->package_spec.visible_decls.count; k++) {
                Syntax_Node *decl = pkg_decl->package_spec.visible_decls.items[k];
                if (!decl) continue;

                if (decl->kind == NK_PROCEDURE_SPEC || decl->kind == NK_FUNCTION_SPEC) {
                    if (!emitted_header) {
                        Emit(cg, "\n; External Ada subprogram declarations\n");
                        emitted_header = true;
                    }
                    Emit_Extern_Subprogram(cg, decl->symbol);
                }
                /* Emit extern for object declarations (constants/variables) */
                if (decl->kind == NK_OBJECT_DECL) {
                    for (uint32_t m = 0; m < decl->object_decl.names.count; m++) {
                        Syntax_Node *name = decl->object_decl.names.items[m];
                        Symbol *sym = name ? name->symbol : NULL;
                        if (!sym || sym->is_named_number) continue;
                        if (sym->extern_emitted) continue;
                        sym->extern_emitted = true;
                        Type_Info *ty = sym->type;
                        const char *type_str = Type_To_Llvm(ty);
                        /* String constants use fat pointer type */
                        bool is_string = ty && (ty->kind == TYPE_STRING ||
                            (ty->kind == TYPE_ARRAY && !ty->array.is_constrained &&
                             ty->array.element_type &&
                             ty->array.element_type->kind == TYPE_CHARACTER));
                        if (is_string) type_str = "{ ptr, { i64, i64 } }";
                        Emit(cg, "@");
                        Emit_Symbol_Name(cg, sym);
                        Emit(cg, " = external global %s\n", type_str);
                    }
                }
            }
        }
    }
    if (emitted_header) Emit(cg, "\n");
}

/* ─────────────────────────────────────────────────────────────────────────
 * §13.7 Compilation Unit Code Generation
 *
 * A compilation unit is the quantum of separate compilation.
 * ───────────────────────────────────────────────────────────────────────── */

static void Generate_Compilation_Unit(Code_Generator *cg, Syntax_Node *node) {
    if (!node) return;

    /* Generate LLVM module header (only once per file) */
    if (!cg->header_emitted) {
    Emit(cg, "; Ada83 Compiler Output\n");
    Emit(cg, "target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n");
    Emit(cg, "target triple = \"x86_64-pc-linux-gnu\"\n\n");

    /* External C library and LLVM intrinsic declarations */
    Emit(cg, "; External declarations\n");
    Emit(cg, "declare i32 @memcmp(ptr, ptr, i64)\n");
    Emit(cg, "declare i32 @strncasecmp(ptr, ptr, i64)\n");
    Emit(cg, "declare i32 @setjmp(ptr)\n");
    Emit(cg, "declare void @longjmp(ptr, i32)\n");
    Emit(cg, "declare void @exit(i32)\n");
    Emit(cg, "declare ptr @malloc(i64)\n");
    Emit(cg, "declare ptr @realloc(ptr, i64)\n");
    Emit(cg, "declare void @free(ptr)\n");
    Emit(cg, "declare i32 @usleep(i32)\n");
    Emit(cg, "declare i32 @pthread_create(ptr, ptr, ptr, ptr)\n");
    Emit(cg, "declare i32 @pthread_join(ptr, ptr)\n");
    Emit(cg, "declare i32 @printf(ptr, ...)\n");
    Emit(cg, "declare i32 @putchar(i32)\n");
    Emit(cg, "declare i32 @getchar()\n");
    /* C file I/O (for TEXT_IO pragma Import) */
    Emit(cg, "declare ptr @fopen(ptr, ptr)\n");
    Emit(cg, "declare i32 @fclose(ptr)\n");
    Emit(cg, "declare i32 @fputc(i32, ptr)\n");
    Emit(cg, "declare i32 @fgetc(ptr)\n");
    Emit(cg, "declare i32 @ungetc(i32, ptr)\n");
    Emit(cg, "declare i32 @feof(ptr)\n");
    Emit(cg, "declare i32 @fflush(ptr)\n");
    Emit(cg, "declare i32 @remove(ptr)\n");
    Emit(cg, "declare i64 @ftell(ptr)\n");
    Emit(cg, "declare i32 @fseek(ptr, i64, i32)\n");
    Emit(cg, "declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)\n");
    Emit(cg, "declare double @llvm.pow.f64(double, double)\n\n");

    /* Integer'VALUE - parse string to integer */
    Emit(cg, "; Integer'VALUE helper\n");
    Emit(cg, "define linkonce_odr i64 @__ada_integer_value({ ptr, { i64, i64 } } %%str) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%data = extractvalue { ptr, { i64, i64 } } %%str, 0\n");
    Emit(cg, "  %%low = extractvalue { ptr, { i64, i64 } } %%str, 1, 0\n");
    Emit(cg, "  %%high = extractvalue { ptr, { i64, i64 } } %%str, 1, 1\n");
    Emit(cg, "  br label %%loop\n");
    Emit(cg, "loop:\n");
    Emit(cg, "  %%result = phi i64 [ 0, %%entry ], [ %%next_result, %%cont ]\n");
    Emit(cg, "  %%idx = phi i64 [ %%low, %%entry ], [ %%next_idx, %%cont ]\n");
    Emit(cg, "  %%neg = phi i1 [ false, %%entry ], [ %%next_neg, %%cont ]\n");
    Emit(cg, "  %%done = icmp sgt i64 %%idx, %%high\n");
    Emit(cg, "  br i1 %%done, label %%finish, label %%body\n");
    Emit(cg, "body:\n");
    Emit(cg, "  %%adj_idx = sub i64 %%idx, %%low\n");
    Emit(cg, "  %%ptr = getelementptr i8, ptr %%data, i64 %%adj_idx\n");
    Emit(cg, "  %%ch = load i8, ptr %%ptr\n");
    Emit(cg, "  %%is_minus = icmp eq i8 %%ch, 45  ; '-'\n");
    Emit(cg, "  br i1 %%is_minus, label %%set_neg, label %%check_digit\n");
    Emit(cg, "set_neg:\n");
    Emit(cg, "  br label %%cont_neg\n");
    Emit(cg, "check_digit:\n");
    Emit(cg, "  %%is_digit = icmp uge i8 %%ch, 48  ; '0'\n");
    Emit(cg, "  %%is_digit2 = icmp ule i8 %%ch, 57  ; '9'\n");
    Emit(cg, "  %%is_dig_both = and i1 %%is_digit, %%is_digit2\n");
    Emit(cg, "  br i1 %%is_dig_both, label %%add_digit, label %%cont\n");
    Emit(cg, "add_digit:\n");
    Emit(cg, "  %%digit = sub i8 %%ch, 48\n");
    Emit(cg, "  %%digit64 = zext i8 %%digit to i64\n");
    Emit(cg, "  %%mul = mul i64 %%result, 10\n");
    Emit(cg, "  %%new_val = add i64 %%mul, %%digit64\n");
    Emit(cg, "  br label %%cont\n");
    Emit(cg, "cont_neg:\n");
    Emit(cg, "  %%next_neg_v = phi i1 [ true, %%set_neg ]\n");
    Emit(cg, "  br label %%cont\n");
    Emit(cg, "cont:\n");
    Emit(cg, "  %%next_result = phi i64 [ %%result, %%check_digit ], [ %%new_val, %%add_digit ], [ %%result, %%cont_neg ]\n");
    Emit(cg, "  %%next_neg = phi i1 [ %%neg, %%check_digit ], [ %%neg, %%add_digit ], [ %%next_neg_v, %%cont_neg ]\n");
    Emit(cg, "  %%next_idx = add i64 %%idx, 1\n");
    Emit(cg, "  br label %%loop\n");
    Emit(cg, "finish:\n");
    Emit(cg, "  %%final = select i1 %%neg, i64 0, i64 %%result\n");
    Emit(cg, "  %%neg_result = sub i64 0, %%result\n");
    Emit(cg, "  %%ret = select i1 %%neg, i64 %%neg_result, i64 %%result\n");
    Emit(cg, "  ret i64 %%ret\n");
    Emit(cg, "}\n\n");

    /* Float'VALUE - declare as external for now (can be implemented similarly) */
    Emit(cg, "; Float'VALUE declaration (to be implemented)\n");
    Emit(cg, "declare double @strtod(ptr, ptr)\n");
    Emit(cg, "define linkonce_odr double @__ada_float_value({ ptr, { i64, i64 } } %%str) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%data = extractvalue { ptr, { i64, i64 } } %%str, 0\n");
    Emit(cg, "  %%result = call double @strtod(ptr %%data, ptr null)\n");
    Emit(cg, "  ret double %%result\n");
    Emit(cg, "}\n\n");

    /* Integer power function (base ** exponent for integer operands) */
    Emit(cg, "; Integer exponentiation helper\n");
    Emit(cg, "define linkonce_odr i64 @__ada_integer_pow(i64 %%base, i64 %%exp) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%is_neg = icmp slt i64 %%exp, 0\n");
    Emit(cg, "  br i1 %%is_neg, label %%neg_exp, label %%pos_exp\n");
    Emit(cg, "neg_exp:\n");
    Emit(cg, "  ret i64 0  ; negative exponent for integer = 0\n");
    Emit(cg, "pos_exp:\n");
    Emit(cg, "  %%is_zero = icmp eq i64 %%exp, 0\n");
    Emit(cg, "  br i1 %%is_zero, label %%ret_one, label %%loop\n");
    Emit(cg, "ret_one:\n");
    Emit(cg, "  ret i64 1\n");
    Emit(cg, "loop:\n");
    Emit(cg, "  %%result = phi i64 [ 1, %%pos_exp ], [ %%new_result, %%loop ]\n");
    Emit(cg, "  %%i = phi i64 [ 0, %%pos_exp ], [ %%next_i, %%loop ]\n");
    Emit(cg, "  %%new_result = mul i64 %%result, %%base\n");
    Emit(cg, "  %%next_i = add i64 %%i, 1\n");
    Emit(cg, "  %%done = icmp eq i64 %%next_i, %%exp\n");
    Emit(cg, "  br i1 %%done, label %%exit, label %%loop\n");
    Emit(cg, "exit:\n");
    Emit(cg, "  ret i64 %%new_result\n");
    Emit(cg, "}\n\n");

    /* Runtime globals */
    Emit(cg, "; Runtime globals\n");
    Emit(cg, "@__ss_base = linkonce_odr global ptr null\n");
    Emit(cg, "@__ss_ptr = linkonce_odr global i64 0\n");
    Emit(cg, "@__ss_size = linkonce_odr global i64 0\n");
    Emit(cg, "@__eh_cur = linkonce_odr global ptr null\n");
    Emit(cg, "@__ex_cur = linkonce_odr global i64 0\n");
    Emit(cg, "@__fin_list = linkonce_odr global ptr null\n");
    Emit(cg, "@__entry_queue = linkonce_odr global ptr null\n");
    Emit(cg, "@.fmt_ue = linkonce_odr constant [27 x i8] c\"Unhandled exception: %%lld\\0A\\00\"\n\n");

    /* Standard exceptions (RM 11.1) — names lowercase to match mangled symbols */
    Emit(cg, "; Standard exception identities\n");
    Emit(cg, "@__exc.constraint_error = linkonce_odr constant i64 1\n");
    Emit(cg, "@__exc.numeric_error = linkonce_odr constant i64 2\n");
    Emit(cg, "@__exc.program_error = linkonce_odr constant i64 3\n");
    Emit(cg, "@__exc.storage_error = linkonce_odr constant i64 4\n");
    Emit(cg, "@__exc.tasking_error = linkonce_odr constant i64 5\n\n");

    /* Secondary stack initialization */
    Emit(cg, "; Secondary stack runtime\n");
    Emit(cg, "define linkonce_odr void @__ada_ss_init() {\n");
    Emit(cg, "  %%p = call ptr @malloc(i64 1048576)\n");
    Emit(cg, "  store ptr %%p, ptr @__ss_base\n");
    Emit(cg, "  store i64 1048576, ptr @__ss_size\n");
    Emit(cg, "  store i64 0, ptr @__ss_ptr\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* Secondary stack mark */
    Emit(cg, "define linkonce_odr i64 @__ada_sec_stack_mark() {\n");
    Emit(cg, "  %%m = load i64, ptr @__ss_ptr\n");
    Emit(cg, "  ret i64 %%m\n");
    Emit(cg, "}\n\n");

    /* Secondary stack release */
    Emit(cg, "define linkonce_odr void @__ada_sec_stack_release(i64 %%m) {\n");
    Emit(cg, "  store i64 %%m, ptr @__ss_ptr\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* Secondary stack allocate */
    Emit(cg, "define linkonce_odr ptr @__ada_sec_stack_alloc(i64 %%sz) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%1 = load ptr, ptr @__ss_base\n");
    Emit(cg, "  %%2 = icmp eq ptr %%1, null\n");
    Emit(cg, "  br i1 %%2, label %%init, label %%alloc\n");
    Emit(cg, "init:\n");
    Emit(cg, "  call void @__ada_ss_init()\n");
    Emit(cg, "  %%3 = load ptr, ptr @__ss_base\n");
    Emit(cg, "  br label %%alloc\n");
    Emit(cg, "alloc:\n");
    Emit(cg, "  %%p = phi ptr [%%1, %%entry], [%%3, %%init]\n");
    Emit(cg, "  %%4 = load i64, ptr @__ss_ptr\n");
    Emit(cg, "  %%5 = add i64 %%sz, 7\n");
    Emit(cg, "  %%6 = and i64 %%5, -8\n");
    Emit(cg, "  %%7 = add i64 %%4, %%6\n");
    Emit(cg, "  %%8 = load i64, ptr @__ss_size\n");
    Emit(cg, "  %%9 = icmp ult i64 %%7, %%8\n");
    Emit(cg, "  br i1 %%9, label %%ok, label %%grow\n");
    Emit(cg, "grow:\n");
    Emit(cg, "  %%10 = mul i64 %%8, 2\n");
    Emit(cg, "  store i64 %%10, ptr @__ss_size\n");
    Emit(cg, "  %%11 = call ptr @realloc(ptr %%p, i64 %%10)\n");
    Emit(cg, "  store ptr %%11, ptr @__ss_base\n");
    Emit(cg, "  br label %%ok\n");
    Emit(cg, "ok:\n");
    Emit(cg, "  %%12 = phi ptr [%%p, %%alloc], [%%11, %%grow]\n");
    Emit(cg, "  %%13 = getelementptr i8, ptr %%12, i64 %%4\n");
    Emit(cg, "  store i64 %%7, ptr @__ss_ptr\n");
    Emit(cg, "  ret ptr %%13\n");
    Emit(cg, "}\n\n");

    /* Exception handling: push handler
     * Handler frame structure: { ptr prev, [200 x i8] jmp_buf }
     * Field 0 = link to previous handler
     * Field 1 = jmp_buf for setjmp/longjmp */
    Emit(cg, "; Exception handling runtime\n");
    Emit(cg, "define linkonce_odr void @__ada_push_handler(ptr %%h) {\n");
    Emit(cg, "  %%old = load ptr, ptr @__eh_cur\n");
    Emit(cg, "  %%link = getelementptr { ptr, [200 x i8] }, ptr %%h, i32 0, i32 0\n");
    Emit(cg, "  store ptr %%old, ptr %%link\n");
    Emit(cg, "  store ptr %%h, ptr @__eh_cur\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* Exception handling: pop handler */
    Emit(cg, "define linkonce_odr void @__ada_pop_handler() {\n");
    Emit(cg, "  %%cur = load ptr, ptr @__eh_cur\n");
    Emit(cg, "  %%is_null = icmp eq ptr %%cur, null\n");
    Emit(cg, "  br i1 %%is_null, label %%done, label %%pop\n");
    Emit(cg, "pop:\n");
    Emit(cg, "  %%link = getelementptr { ptr, [200 x i8] }, ptr %%cur, i32 0, i32 0\n");
    Emit(cg, "  %%prev = load ptr, ptr %%link\n");
    Emit(cg, "  store ptr %%prev, ptr @__eh_cur\n");
    Emit(cg, "  br label %%done\n");
    Emit(cg, "done:\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* Exception handling: raise */
    Emit(cg, "define linkonce_odr void @__ada_raise(i64 %%exc_id) {\n");
    Emit(cg, "  store i64 %%exc_id, ptr @__ex_cur\n");
    Emit(cg, "  %%frame = load ptr, ptr @__eh_cur\n");
    Emit(cg, "  %%is_null = icmp eq ptr %%frame, null\n");
    Emit(cg, "  br i1 %%is_null, label %%unhandled, label %%jump\n");
    Emit(cg, "jump:\n");
    Emit(cg, "  %%jb = getelementptr { ptr, [200 x i8] }, ptr %%frame, i32 0, i32 1\n");
    Emit(cg, "  call void @longjmp(ptr %%jb, i32 1)\n");
    Emit(cg, "  unreachable\n");
    Emit(cg, "unhandled:\n");
    Emit(cg, "  call i32 (ptr, ...) @printf(ptr @.fmt_ue, i64 %%exc_id)\n");
    Emit(cg, "  call void @exit(i32 1)\n");
    Emit(cg, "  unreachable\n");
    Emit(cg, "}\n\n");

    /* Exception handling: reraise */
    Emit(cg, "define linkonce_odr void @__ada_reraise() {\n");
    Emit(cg, "  %%exc = load i64, ptr @__ex_cur\n");
    Emit(cg, "  call void @__ada_raise(i64 %%exc)\n");
    Emit(cg, "  unreachable\n");
    Emit(cg, "}\n\n");

    /* Exception handling: get current exception */
    Emit(cg, "define linkonce_odr i64 @__ada_current_exception() {\n");
    Emit(cg, "  %%exc = load i64, ptr @__ex_cur\n");
    Emit(cg, "  ret i64 %%exc\n");
    Emit(cg, "}\n\n");

    /* Integer power function */
    Emit(cg, "; Arithmetic runtime\n");
    Emit(cg, "define linkonce_odr i64 @__ada_powi(i64 %%base, i64 %%exp) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%result = alloca i64\n");
    Emit(cg, "  store i64 1, ptr %%result\n");
    Emit(cg, "  %%e = alloca i64\n");
    Emit(cg, "  store i64 %%exp, ptr %%e\n");
    Emit(cg, "  br label %%loop\n");
    Emit(cg, "loop:\n");
    Emit(cg, "  %%ev = load i64, ptr %%e\n");
    Emit(cg, "  %%cmp = icmp sgt i64 %%ev, 0\n");
    Emit(cg, "  br i1 %%cmp, label %%body, label %%done\n");
    Emit(cg, "body:\n");
    Emit(cg, "  %%rv = load i64, ptr %%result\n");
    Emit(cg, "  %%nv = mul i64 %%rv, %%base\n");
    Emit(cg, "  store i64 %%nv, ptr %%result\n");
    Emit(cg, "  %%ev2 = load i64, ptr %%e\n");
    Emit(cg, "  %%ev3 = sub i64 %%ev2, 1\n");
    Emit(cg, "  store i64 %%ev3, ptr %%e\n");
    Emit(cg, "  br label %%loop\n");
    Emit(cg, "done:\n");
    Emit(cg, "  %%final = load i64, ptr %%result\n");
    Emit(cg, "  ret i64 %%final\n");
    Emit(cg, "}\n\n");

    /* Delay statement support */
    Emit(cg, "; Tasking runtime\n");
    Emit(cg, "define linkonce_odr void @__ada_delay(i64 %%us) {\n");
    Emit(cg, "  %%t = trunc i64 %%us to i32\n");
    Emit(cg, "  call i32 @usleep(i32 %%t)\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* Task abort: signal task to terminate (simplified: just sets flag) - is this right ??? */
    Emit(cg, "define linkonce_odr void @__ada_task_abort(ptr %%task) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%1 = icmp eq ptr %%task, null\n");
    Emit(cg, "  br i1 %%1, label %%done, label %%abort\n");
    Emit(cg, "abort:\n");
    Emit(cg, "  ; In full impl: set abort flag, signal condition\n");
    Emit(cg, "  store i8 1, ptr %%task  ; Mark abort pending\n");
    Emit(cg, "  br label %%done\n");
    Emit(cg, "done:\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* Task terminate: graceful task termination (for terminate alternative) */
    Emit(cg, "define linkonce_odr void @__ada_task_terminate() {\n");
    Emit(cg, "  ; Check if master task is complete, if so exit\n");
    Emit(cg, "  call void @exit(i32 0)\n");
    Emit(cg, "  unreachable\n");
    Emit(cg, "}\n\n");

    /* Task start: spawn a thread to run the task body.
     * Returns thread handle that can be used for join/abort.
     * The task_func is a pointer to void(ptr) which is close enough
     * to pthread's void*(void*) signature to work via bitcast. */
    Emit(cg, "define linkonce_odr ptr @__ada_task_start(ptr %%task_func, ptr %%parent_frame) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%tid = alloca ptr\n");
    Emit(cg, "  %%_rc = call i32 @pthread_create(ptr %%tid, ptr null, ptr %%task_func, ptr %%parent_frame)\n");
    Emit(cg, "  %%handle = load ptr, ptr %%tid\n");
    Emit(cg, "  ret ptr %%handle\n");
    Emit(cg, "}\n\n");

    /* Entry call: caller side of rendezvous (blocks until accept completes) */
    Emit(cg, "define linkonce_odr void @__ada_entry_call(ptr %%task, i64 %%entry_idx, ptr %%params) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  ; Allocate rendezvous record: { task_ptr, entry_idx, params, complete_flag, next }\n");
    Emit(cg, "  %%rv = call ptr @malloc(i64 40)\n");
    Emit(cg, "  store ptr %%task, ptr %%rv\n");
    Emit(cg, "  %%1 = getelementptr i64, ptr %%rv, i64 1\n");
    Emit(cg, "  store i64 %%entry_idx, ptr %%1\n");
    Emit(cg, "  %%2 = getelementptr ptr, ptr %%rv, i64 2\n");
    Emit(cg, "  store ptr %%params, ptr %%2\n");
    Emit(cg, "  %%3 = getelementptr i8, ptr %%rv, i64 32\n");
    Emit(cg, "  store i8 0, ptr %%3  ; complete = false\n");
    Emit(cg, "  ; Enqueue to task's entry queue (append to @__entry_queue)\n");
    Emit(cg, "  %%4 = load ptr, ptr @__entry_queue\n");
    Emit(cg, "  %%5 = getelementptr ptr, ptr %%rv, i64 4\n");
    Emit(cg, "  store ptr %%4, ptr %%5\n");
    Emit(cg, "  store ptr %%rv, ptr @__entry_queue\n");
    Emit(cg, "  br label %%wait\n");
    Emit(cg, "wait:\n");
    Emit(cg, "  ; Spin-wait for complete flag (yield to scheduler)\n");
    Emit(cg, "  %%_u1 = call i32 @usleep(i32 100)\n");
    Emit(cg, "  %%6 = load i8, ptr %%3\n");
    Emit(cg, "  %%7 = icmp eq i8 %%6, 0\n");
    Emit(cg, "  br i1 %%7, label %%wait, label %%done\n");
    Emit(cg, "done:\n");
    Emit(cg, "  call void @free(ptr %%rv)\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* Accept wait: acceptor blocks until entry call arrives */
    Emit(cg, "define linkonce_odr ptr @__ada_accept_wait(i64 %%entry_idx) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  br label %%wait\n");
    Emit(cg, "wait:\n");
    Emit(cg, "  ; Scan entry queue for matching entry index\n");
    Emit(cg, "  %%q = load ptr, ptr @__entry_queue\n");
    Emit(cg, "  %%is_empty = icmp eq ptr %%q, null\n");
    Emit(cg, "  br i1 %%is_empty, label %%spin, label %%check\n");
    Emit(cg, "spin:\n");
    Emit(cg, "  %%_u2 = call i32 @usleep(i32 100)\n");
    Emit(cg, "  br label %%wait\n");
    Emit(cg, "check:\n");
    Emit(cg, "  ; Check if first entry matches\n");
    Emit(cg, "  %%1 = getelementptr i64, ptr %%q, i64 1\n");
    Emit(cg, "  %%2 = load i64, ptr %%1\n");
    Emit(cg, "  %%3 = icmp eq i64 %%2, %%entry_idx\n");
    Emit(cg, "  br i1 %%3, label %%found, label %%spin\n");
    Emit(cg, "found:\n");
    Emit(cg, "  ; Dequeue and return caller's parameter block\n");
    Emit(cg, "  %%4 = getelementptr ptr, ptr %%q, i64 4\n");
    Emit(cg, "  %%5 = load ptr, ptr %%4\n");
    Emit(cg, "  store ptr %%5, ptr @__entry_queue\n");
    Emit(cg, "  %%6 = getelementptr ptr, ptr %%q, i64 2\n");
    Emit(cg, "  %%params = load ptr, ptr %%6\n");
    Emit(cg, "  ret ptr %%q\n");
    Emit(cg, "}\n\n");

    /* Accept try: non-blocking check for pending entry call (for SELECT) */
    Emit(cg, "define linkonce_odr ptr @__ada_accept_try(i64 %%entry_idx) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%q = load ptr, ptr @__entry_queue\n");
    Emit(cg, "  %%is_empty = icmp eq ptr %%q, null\n");
    Emit(cg, "  br i1 %%is_empty, label %%none, label %%check\n");
    Emit(cg, "check:\n");
    Emit(cg, "  %%1 = getelementptr i64, ptr %%q, i64 1\n");
    Emit(cg, "  %%2 = load i64, ptr %%1\n");
    Emit(cg, "  %%3 = icmp eq i64 %%2, %%entry_idx\n");
    Emit(cg, "  br i1 %%3, label %%found, label %%none\n");
    Emit(cg, "found:\n");
    Emit(cg, "  ; Dequeue and return caller's parameter block\n");
    Emit(cg, "  %%4 = getelementptr ptr, ptr %%q, i64 4\n");
    Emit(cg, "  %%5 = load ptr, ptr %%4\n");
    Emit(cg, "  store ptr %%5, ptr @__entry_queue\n");
    Emit(cg, "  ret ptr %%q\n");
    Emit(cg, "none:\n");
    Emit(cg, "  ret ptr null\n");
    Emit(cg, "}\n\n");

    /* Accept complete: signal rendezvous completion to caller */
    Emit(cg, "define linkonce_odr void @__ada_accept_complete(ptr %%rv) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%1 = getelementptr i8, ptr %%rv, i64 32\n");
    Emit(cg, "  store i8 1, ptr %%1  ; complete = true\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* Finalization support */
    Emit(cg, "; Finalization runtime\n");
    Emit(cg, "define linkonce_odr void @__ada_finalize(ptr %%obj, ptr %%fn) {\n");
    Emit(cg, "  %%1 = call ptr @malloc(i64 24)\n");
    Emit(cg, "  %%2 = getelementptr ptr, ptr %%1, i64 0\n");
    Emit(cg, "  store ptr %%obj, ptr %%2\n");
    Emit(cg, "  %%3 = getelementptr ptr, ptr %%1, i64 1\n");
    Emit(cg, "  store ptr %%fn, ptr %%3\n");
    Emit(cg, "  %%4 = load ptr, ptr @__fin_list\n");
    Emit(cg, "  %%5 = getelementptr ptr, ptr %%1, i64 2\n");
    Emit(cg, "  store ptr %%4, ptr %%5\n");
    Emit(cg, "  store ptr %%1, ptr @__fin_list\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    Emit(cg, "define linkonce_odr void @__ada_finalize_all() {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%1 = load ptr, ptr @__fin_list\n");
    Emit(cg, "  br label %%loop\n");
    Emit(cg, "loop:\n");
    Emit(cg, "  %%p = phi ptr [%%1, %%entry], [%%9, %%fin]\n");
    Emit(cg, "  %%2 = icmp eq ptr %%p, null\n");
    Emit(cg, "  br i1 %%2, label %%done, label %%fin\n");
    Emit(cg, "fin:\n");
    Emit(cg, "  %%3 = getelementptr ptr, ptr %%p, i64 0\n");
    Emit(cg, "  %%4 = load ptr, ptr %%3\n");
    Emit(cg, "  %%5 = getelementptr ptr, ptr %%p, i64 1\n");
    Emit(cg, "  %%6 = load ptr, ptr %%5\n");
    Emit(cg, "  call void %%6(ptr %%4)\n");
    Emit(cg, "  %%8 = getelementptr ptr, ptr %%p, i64 2\n");
    Emit(cg, "  %%9 = load ptr, ptr %%8\n");
    Emit(cg, "  call void @free(ptr %%p)\n");
    Emit(cg, "  br label %%loop\n");
    Emit(cg, "done:\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* TEXT_IO inline implementation (Ada 83 Chapter 14) */
    Emit(cg, "; TEXT_IO runtime\n");
    Emit(cg, "@stdin = external global ptr\n");
    Emit(cg, "@stdout = external global ptr\n");
    Emit(cg, "@stderr = external global ptr\n");
    /* Note: fputc, fgetc declared in main preamble; add remaining here */
    Emit(cg, "declare i32 @fputs(ptr, ptr)\n");
    Emit(cg, "declare ptr @fgets(ptr, i32, ptr)\n");
    Emit(cg, "declare i32 @fprintf(ptr, ptr, ...)\n");
    Emit(cg, "@.fmt_d = linkonce_odr constant [5 x i8] c\"%%lld\\00\"\n");
    Emit(cg, "@.fmt_s = linkonce_odr constant [3 x i8] c\"%%s\\00\"\n");
    Emit(cg, "@.fmt_f = linkonce_odr constant [3 x i8] c\"%%g\\00\"\n");
    Emit(cg, "@.fmt_c = linkonce_odr constant [3 x i8] c\"%%c\\00\"\n\n");

    /* NEW_LINE: output line terminator */
    Emit(cg, "define linkonce_odr void @__text_io_new_line() {\n");
    Emit(cg, "  %%out = load ptr, ptr @stdout\n");
    Emit(cg, "  call i32 @fputc(i32 10, ptr %%out)\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* PUT_CHAR: output single character */
    Emit(cg, "define linkonce_odr void @__text_io_put_char(i8 %%c) {\n");
    Emit(cg, "  %%out = load ptr, ptr @stdout\n");
    Emit(cg, "  %%ci = zext i8 %%c to i32\n");
    Emit(cg, "  call i32 @fputc(i32 %%ci, ptr %%out)\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* PUT: output string (ptr + bounds) */
    Emit(cg, "define linkonce_odr void @__text_io_put(ptr %%data, i64 %%lo, i64 %%hi) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%out = load ptr, ptr @stdout\n");
    Emit(cg, "  %%i.init = sub i64 %%lo, 1\n");
    Emit(cg, "  br label %%loop\n");
    Emit(cg, "loop:\n");
    Emit(cg, "  %%i = phi i64 [ %%i.init, %%entry ], [ %%i.next, %%body ]\n");
    Emit(cg, "  %%i.next = add i64 %%i, 1\n");
    Emit(cg, "  %%done = icmp sgt i64 %%i.next, %%hi\n");
    Emit(cg, "  br i1 %%done, label %%exit, label %%body\n");
    Emit(cg, "body:\n");
    Emit(cg, "  %%idx = sub i64 %%i.next, %%lo\n");
    Emit(cg, "  %%ptr = getelementptr i8, ptr %%data, i64 %%idx\n");
    Emit(cg, "  %%ch = load i8, ptr %%ptr\n");
    Emit(cg, "  %%chi = zext i8 %%ch to i32\n");
    Emit(cg, "  call i32 @fputc(i32 %%chi, ptr %%out)\n");
    Emit(cg, "  br label %%loop\n");
    Emit(cg, "exit:\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* PUT_LINE: output string followed by newline */
    Emit(cg, "define linkonce_odr void @__text_io_put_line(ptr %%data, i64 %%lo, i64 %%hi) {\n");
    Emit(cg, "  call void @__text_io_put(ptr %%data, i64 %%lo, i64 %%hi)\n");
    Emit(cg, "  call void @__text_io_new_line()\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* PUT_INTEGER: output integer with optional width */
    Emit(cg, "define linkonce_odr void @__text_io_put_int(i64 %%val, i32 %%width) {\n");
    Emit(cg, "  %%out = load ptr, ptr @stdout\n");
    Emit(cg, "  call i32 (ptr, ptr, ...) @fprintf(ptr %%out, ptr @.fmt_d, i64 %%val)\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* PUT_FLOAT: output float value */
    Emit(cg, "define linkonce_odr void @__text_io_put_float(double %%val) {\n");
    Emit(cg, "  %%out = load ptr, ptr @stdout\n");
    Emit(cg, "  call i32 (ptr, ptr, ...) @fprintf(ptr %%out, ptr @.fmt_f, double %%val)\n");
    Emit(cg, "  ret void\n");
    Emit(cg, "}\n\n");

    /* GET_CHAR: read single character */
    Emit(cg, "define linkonce_odr i8 @__text_io_get_char() {\n");
    Emit(cg, "  %%inp = load ptr, ptr @stdin\n");
    Emit(cg, "  %%c = call i32 @fgetc(ptr %%inp)\n");
    Emit(cg, "  %%c8 = trunc i32 %%c to i8\n");
    Emit(cg, "  ret i8 %%c8\n");
    Emit(cg, "}\n\n");

    /* GET_LINE: read line into buffer, return fat pointer */
    Emit(cg, "define linkonce_odr { ptr, { i64, i64 } } @__text_io_get_line() {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%buf = call ptr @__ada_sec_stack_alloc(i64 256)\n");
    Emit(cg, "  %%inp = load ptr, ptr @stdin\n");
    Emit(cg, "  %%res = call ptr @fgets(ptr %%buf, i32 255, ptr %%inp)\n");
    Emit(cg, "  %%iseof = icmp eq ptr %%res, null\n");
    Emit(cg, "  br i1 %%iseof, label %%empty, label %%gotline\n");
    Emit(cg, "empty:\n");
    Emit(cg, "  %%e1 = insertvalue { ptr, { i64, i64 } } undef, ptr %%buf, 0\n");
    Emit(cg, "  %%e2 = insertvalue { ptr, { i64, i64 } } %%e1, i64 1, 1, 0\n");
    Emit(cg, "  %%e3 = insertvalue { ptr, { i64, i64 } } %%e2, i64 0, 1, 1\n");
    Emit(cg, "  ret { ptr, { i64, i64 } } %%e3\n");
    Emit(cg, "gotline:\n");
    Emit(cg, "  %%len = call i64 @strlen(ptr %%buf)\n");
    Emit(cg, "  ; Strip trailing newline if present\n");
    Emit(cg, "  %%lastidx = sub i64 %%len, 1\n");
    Emit(cg, "  %%lastptr = getelementptr i8, ptr %%buf, i64 %%lastidx\n");
    Emit(cg, "  %%lastch = load i8, ptr %%lastptr\n");
    Emit(cg, "  %%isnl = icmp eq i8 %%lastch, 10\n");
    Emit(cg, "  %%adjlen = select i1 %%isnl, i64 %%lastidx, i64 %%len\n");
    Emit(cg, "  %%f1 = insertvalue { ptr, { i64, i64 } } undef, ptr %%buf, 0\n");
    Emit(cg, "  %%f2 = insertvalue { ptr, { i64, i64 } } %%f1, i64 1, 1, 0\n");
    Emit(cg, "  %%f3 = insertvalue { ptr, { i64, i64 } } %%f2, i64 %%adjlen, 1, 1\n");
    Emit(cg, "  ret { ptr, { i64, i64 } } %%f3\n");
    Emit(cg, "}\n\n");

    /* 'IMAGE runtime: Integer'IMAGE(x) returns string representation */
    Emit(cg, "; Attribute runtime support\n");
    Emit(cg, "declare i32 @snprintf(ptr, i64, ptr, ...)\n");
    Emit(cg, "declare i64 @strlen(ptr)\n");
    Emit(cg, "@.img_fmt_d = linkonce_odr constant [5 x i8] c\"%%lld\\00\"\n");
    Emit(cg, "@.img_fmt_c = linkonce_odr constant [3 x i8] c\"%%c\\00\"\n");
    Emit(cg, "@.img_fmt_f = linkonce_odr constant [5 x i8] c\"%%.6g\\00\"\n\n");

    /* Integer'IMAGE - convert integer to string fat pointer */
    Emit(cg, "define linkonce_odr { ptr, { i64, i64 } } @__ada_integer_image(i64 %%val) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%buf = call ptr @__ada_sec_stack_alloc(i64 24)\n");
    Emit(cg, "  %%len = call i32 (ptr, i64, ptr, ...) @snprintf(ptr %%buf, i64 24, ptr @.img_fmt_d, i64 %%val)\n");
    Emit(cg, "  %%len64 = sext i32 %%len to i64\n");
    Emit(cg, "  %%high = sub i64 %%len64, 1\n");
    Emit(cg, "  %%fat1 = insertvalue { ptr, { i64, i64 } } undef, ptr %%buf, 0\n");
    Emit(cg, "  %%fat2 = insertvalue { ptr, { i64, i64 } } %%fat1, i64 1, 1, 0\n");
    Emit(cg, "  %%fat3 = insertvalue { ptr, { i64, i64 } } %%fat2, i64 %%len64, 1, 1\n");
    Emit(cg, "  ret { ptr, { i64, i64 } } %%fat3\n");
    Emit(cg, "}\n\n");

    /* Character'IMAGE - single char to string (3 chars: 'x') */
    Emit(cg, "define linkonce_odr { ptr, { i64, i64 } } @__ada_character_image(i8 %%val) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%buf = call ptr @__ada_sec_stack_alloc(i64 4)\n");
    Emit(cg, "  %%p0 = getelementptr i8, ptr %%buf, i64 0\n");
    Emit(cg, "  store i8 39, ptr %%p0  ; single quote\n");
    Emit(cg, "  %%p1 = getelementptr i8, ptr %%buf, i64 1\n");
    Emit(cg, "  store i8 %%val, ptr %%p1\n");
    Emit(cg, "  %%p2 = getelementptr i8, ptr %%buf, i64 2\n");
    Emit(cg, "  store i8 39, ptr %%p2  ; single quote\n");
    Emit(cg, "  %%fat1 = insertvalue { ptr, { i64, i64 } } undef, ptr %%buf, 0\n");
    Emit(cg, "  %%fat2 = insertvalue { ptr, { i64, i64 } } %%fat1, i64 1, 1, 0\n");
    Emit(cg, "  %%fat3 = insertvalue { ptr, { i64, i64 } } %%fat2, i64 3, 1, 1\n");
    Emit(cg, "  ret { ptr, { i64, i64 } } %%fat3\n");
    Emit(cg, "}\n\n");

    /* Float'IMAGE - convert float to string */
    Emit(cg, "define linkonce_odr { ptr, { i64, i64 } } @__ada_float_image(double %%val) {\n");
    Emit(cg, "entry:\n");
    Emit(cg, "  %%buf = call ptr @__ada_sec_stack_alloc(i64 32)\n");
    Emit(cg, "  %%len = call i32 (ptr, i64, ptr, ...) @snprintf(ptr %%buf, i64 32, ptr @.img_fmt_f, double %%val)\n");
    Emit(cg, "  %%len64 = sext i32 %%len to i64\n");
    Emit(cg, "  %%fat1 = insertvalue { ptr, { i64, i64 } } undef, ptr %%buf, 0\n");
    Emit(cg, "  %%fat2 = insertvalue { ptr, { i64, i64 } } %%fat1, i64 1, 1, 0\n");
    Emit(cg, "  %%fat3 = insertvalue { ptr, { i64, i64 } } %%fat2, i64 %%len64, 1, 1\n");
    Emit(cg, "  ret { ptr, { i64, i64 } } %%fat3\n");
    Emit(cg, "}\n\n");

    /* Generate exception identity globals */
    Generate_Exception_Globals(cg);

    /* Generate implicit operators for frozen composite types */
    Generate_Implicit_Operators(cg);
    Emit(cg, "\n");

    cg->header_emitted = true;
    }  /* End of header emission block */

    /* Generate extern declarations for WITH'd packages */
    Generate_Extern_Declarations(cg, node);

    /* Generate declarations */
    if (node->compilation_unit.unit) {
        Generate_Declaration(cg, node->compilation_unit.unit);
    }

    /* Emit buffered string constants at module level */
    if (cg->string_const_size > 0) {
        Emit(cg, "\n; String constants\n");
        fprintf(cg->output, "%s", cg->string_const_buffer);
        Emit(cg, "\n");
        cg->string_const_size = 0;  /* Reset buffer for next compilation unit */
    }

    /* Generate main function if this is a main program (library-level procedure).
     * Emit @main() for the LAST parameterless library-level procedure in the file.
     * We track main_candidate and emit at end of Compile_File instead. */
    Syntax_Node *unit = node->compilation_unit.unit;
    if (unit && unit->kind == NK_PROCEDURE_BODY && unit->symbol) {
        Symbol *main_sym = unit->symbol;
        /* Check if this is a library-level procedure (no parameters)
         * and NOT a SEPARATE subunit */
        if (main_sym->parameter_count == 0 && !unit->subprogram_body.is_separate) {
            cg->main_candidate = main_sym;
        }
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §14. INCLUDE PATH & PACKAGE LOADING
 * ═══════════════════════════════════════════════════════════════════════════
 */

static const char *Include_Paths[32];
static int Include_Path_Count = 0;

/* Track loaded package bodies for code generation */
static Syntax_Node *Loaded_Package_Bodies[128];
static int Loaded_Body_Count = 0;

/* Track which package bodies have already been loaded (to avoid duplicates) */
static String_Slice Loaded_Body_Names[128];
static int Loaded_Body_Names_Count = 0;

static bool Body_Already_Loaded(String_Slice name) {
    for (int i = 0; i < Loaded_Body_Names_Count; i++) {
        if (Loaded_Body_Names[i].length == name.length &&
            strncasecmp(Loaded_Body_Names[i].data, name.data, name.length) == 0) {
            return true;
        }
    }
    return false;
}

static void Mark_Body_Loaded(String_Slice name) {
    if (Loaded_Body_Names_Count < 128) {
        Loaded_Body_Names[Loaded_Body_Names_Count++] = name;
    }
}

/* Track packages currently being loaded to detect cycles */
typedef struct {
    String_Slice names[64];
    int count;
} Loading_Set;

static Loading_Set Loading_Packages = {0};

static bool Loading_Set_Contains(String_Slice name) {
    for (int i = 0; i < Loading_Packages.count; i++) {
        if (Loading_Packages.names[i].length == name.length &&
            strncasecmp(Loading_Packages.names[i].data, name.data, name.length) == 0) {
            return true;
        }
    }
    return false;
}

static void Loading_Set_Add(String_Slice name) {
    if (Loading_Packages.count < 64) {
        Loading_Packages.names[Loading_Packages.count++] = name;
    }
}

static void Loading_Set_Remove(String_Slice name) {
    for (int i = 0; i < Loading_Packages.count; i++) {
        if (Loading_Packages.names[i].length == name.length &&
            strncasecmp(Loading_Packages.names[i].data, name.data, name.length) == 0) {
            /* Swap with last and decrement count */
            Loading_Packages.names[i] = Loading_Packages.names[--Loading_Packages.count];
            return;
        }
    }
}

static char *Read_File_Simple(const char *path) {
    FILE *f = fopen(path, "rb");
    if (!f) return NULL;

    fseek(f, 0, SEEK_END);
    long fsize = ftell(f);
    if (fsize < 0) { fclose(f); return NULL; }
    size_t size = (size_t)fsize;
    fseek(f, 0, SEEK_SET);

    char *buffer = malloc(size + 1);
    if (!buffer) { fclose(f); return NULL; }

    size_t read_size = fread(buffer, 1, size, f);
    fclose(f);
    buffer[read_size] = '\0';
    return buffer;
}

/* Find a package source file in include paths */
static char *Lookup_Path(String_Slice name) {
    char path[512], full_path[520];  /* full_path larger for .ads extension */

    for (int i = 0; i < Include_Path_Count; i++) {
        /* Build lowercase filename */
        size_t base_len = strlen(Include_Paths[i]);
        snprintf(path, sizeof(path), "%s%s%.*s",
                 Include_Paths[i],
                 (base_len > 0 && Include_Paths[i][base_len-1] != '/') ? "/" : "",
                 (int)name.length, name.data);

        /* Lowercase the filename part */
        for (char *p = path + base_len; *p; p++) {
            if (*p >= 'A' && *p <= 'Z') *p = *p - 'A' + 'a';
        }

        /* Try .ads extension */
        snprintf(full_path, sizeof(full_path), "%s.ads", path);
        char *src = Read_File_Simple(full_path);
        if (src) return src;

        /* Try .ada extension (ACATS naming convention) */
        snprintf(full_path, sizeof(full_path), "%s.ada", path);
        src = Read_File_Simple(full_path);
        if (src) return src;
    }
    return NULL;
}

/* Check if a precompiled .ll file exists for a package in include paths */
static bool Has_Precompiled_LL(String_Slice name) {
    char path[512], full_path[520];
    for (int i = 0; i < Include_Path_Count; i++) {
        size_t base_len = strlen(Include_Paths[i]);
        snprintf(path, sizeof(path), "%s%s%.*s",
                 Include_Paths[i],
                 (base_len > 0 && Include_Paths[i][base_len-1] != '/') ? "/" : "",
                 (int)name.length, name.data);
        for (char *p = path + base_len; *p; p++) {
            if (*p >= 'A' && *p <= 'Z') *p = *p - 'A' + 'a';
        }
        snprintf(full_path, sizeof(full_path), "%s.ll", path);
        FILE *f = fopen(full_path, "r");
        if (f) { fclose(f); return true; }
    }
    return false;
}

/* Find a package body source file in include paths */
static char *Lookup_Path_Body(String_Slice name) {
    char path[512], full_path[520];

    for (int i = 0; i < Include_Path_Count; i++) {
        size_t base_len = strlen(Include_Paths[i]);
        snprintf(path, sizeof(path), "%s%s%.*s",
                 Include_Paths[i],
                 (base_len > 0 && Include_Paths[i][base_len-1] != '/') ? "/" : "",
                 (int)name.length, name.data);

        /* Lowercase the filename part */
        for (char *p = path + base_len; *p; p++) {
            if (*p >= 'A' && *p <= 'Z') *p = *p - 'A' + 'a';
        }

        /* Try .adb extension */
        snprintf(full_path, sizeof(full_path), "%s.adb", path);
        char *src = Read_File_Simple(full_path);
        if (src) return src;

        /* Try .ada extension (ACATS uses .ada for both specs and bodies) */
        snprintf(full_path, sizeof(full_path), "%s.ada", path);
        src = Read_File_Simple(full_path);
        if (src) return src;
    }
    return NULL;
}

/* Forward declarations for package loading */
static Syntax_Node *Parse_Compilation_Unit(Parser *p);
static void Resolve_Declaration(Symbol_Manager *sm, Syntax_Node *node);

/* Forward declaration for ALI-based loading (defined in §16.7) */
static bool Try_Load_From_ALI(Symbol_Manager *sm, String_Slice name);

/* Load and resolve a package specification */
static void Load_Package_Spec(Symbol_Manager *sm, String_Slice name, char *src) {
    if (!src) return;

    /* Check if already loaded */
    Symbol *existing = Symbol_Find(sm, name);
    if (existing && existing->kind == SYMBOL_PACKAGE && existing->declaration) {
        return;  /* Already loaded */
    }

    /* Check for circular dependency (package currently being loaded) */
    if (Loading_Set_Contains(name)) {
        return;  /* Break cycle - package will be available when outer load completes */
    }

    /* Try to load from cached ALI file first.
     * If successful, we skip parsing entirely. */
    if (Try_Load_From_ALI(sm, name)) {
        return;
    }

    /* Mark package as loading to detect cycles */
    Loading_Set_Add(name);

    /* Parse the package (ALI not available or stale) */
    char filename[256];
    snprintf(filename, sizeof(filename), "%.*s.ads", (int)name.length, name.data);
    Parser p = Parser_New(src, strlen(src), filename);
    Syntax_Node *cu = Parse_Compilation_Unit(&p);

    if (!cu) {
        Loading_Set_Remove(name);
        return;
    }

    /* Recursively load WITH'd packages */
    if (cu->compilation_unit.context) {
        Node_List *withs = &cu->compilation_unit.context->context.with_clauses;
        for (uint32_t i = 0; i < withs->count; i++) {
            Syntax_Node *with_node = withs->items[i];
            for (uint32_t j = 0; j < with_node->use_clause.names.count; j++) {
                Syntax_Node *pkg_name = with_node->use_clause.names.items[j];
                if (pkg_name->kind == NK_IDENTIFIER) {
                    char *pkg_src = Lookup_Path(pkg_name->string_val.text);
                    if (pkg_src) {
                        Load_Package_Spec(sm, pkg_name->string_val.text, pkg_src);
                    }
                }
            }
        }
    }

    /* Resolve the package declarations */
    if (cu->compilation_unit.unit) {
        Syntax_Node *unit = cu->compilation_unit.unit;

        if (unit->kind == NK_PACKAGE_SPEC) {
            Syntax_Node *pkg = unit;

            /* Create package symbol */
            Symbol *pkg_sym = Symbol_New(SYMBOL_PACKAGE, pkg->package_spec.name,
                                         pkg->location);
            Type_Info *pkg_type = Type_New(TYPE_PACKAGE, pkg->package_spec.name);
            pkg_sym->type = pkg_type;
            pkg_sym->declaration = pkg;
            Symbol_Add(sm, pkg_sym);
            pkg->symbol = pkg_sym;

            /* Push package scope */
            Symbol_Manager_Push_Scope(sm, pkg_sym);

            /* Resolve visible declarations */
            Resolve_Declaration_List(sm, &pkg->package_spec.visible_decls);

            /* Populate package exports for qualified access (e.g., SYSTEM.MAX_INT) */
            Populate_Package_Exports(pkg_sym, pkg);

            /* Resolve private declarations */
            Resolve_Declaration_List(sm, &pkg->package_spec.private_decls);

            Symbol_Manager_Pop_Scope(sm);
        }
        else if (unit->kind == NK_GENERIC_DECL) {
            /* Generic unit: create SYMBOL_GENERIC with the inner spec */
            Syntax_Node *inner = unit->generic_decl.unit;
            String_Slice unit_name = {0};

            if (inner && inner->kind == NK_PACKAGE_SPEC) {
                unit_name = inner->package_spec.name;
            } else if (inner && (inner->kind == NK_PROCEDURE_SPEC ||
                                 inner->kind == NK_FUNCTION_SPEC)) {
                unit_name = inner->subprogram_spec.name;
            }

            if (unit_name.data) {
                /* Create generic symbol */
                Symbol *sym = Symbol_New(SYMBOL_GENERIC, unit_name, unit->location);
                sym->declaration = unit;
                sym->generic_unit = inner;

                /* Store formals list for later instantiation */
                if (unit->generic_decl.formals.count > 0) {
                    sym->generic_formals = unit->generic_decl.formals.items[0];
                }

                Symbol_Add(sm, sym);
                unit->symbol = sym;

                /* Resolve the generic package spec's declarations so type/exception
                 * names are available when the body is parsed. Push scope, install
                 * generic formals, then resolve visible/private declarations. */
                if (inner && inner->kind == NK_PACKAGE_SPEC) {
                    Symbol_Manager_Push_Scope(sm, sym);

                    /* Install generic formal parameters */
                    Node_List *formals = &unit->generic_decl.formals;
                    for (uint32_t i = 0; i < formals->count; i++) {
                        Syntax_Node *formal = formals->items[i];
                        if (formal->kind == NK_GENERIC_TYPE_PARAM) {
                            Symbol *type_sym = Symbol_New(SYMBOL_TYPE,
                                formal->generic_type_param.name, formal->location);
                            /* Map def_kind to appropriate Type_Kind */
                            Type_Kind tk = TYPE_PRIVATE;
                            switch (formal->generic_type_param.def_kind) {
                                case 2: tk = TYPE_ENUMERATION; break; /* DISCRETE */
                                case 3: tk = TYPE_INTEGER; break;     /* INTEGER */
                                case 4: tk = TYPE_FLOAT; break;       /* FLOAT */
                                case 5: tk = TYPE_FIXED; break;       /* FIXED */
                                default: tk = TYPE_PRIVATE; break;
                            }
                            Type_Info *type = Type_New(tk, formal->generic_type_param.name);
                            type_sym->type = type;
                            formal->symbol = type_sym;
                            Symbol_Add(sm, type_sym);
                        }
                    }

                    /* Resolve visible declarations */
                    Resolve_Declaration_List(sm, &inner->package_spec.visible_decls);

                    /* Populate package exports for qualified access */
                    Populate_Package_Exports(sym, inner);

                    /* Resolve private declarations */
                    Resolve_Declaration_List(sm, &inner->package_spec.private_decls);

                    Symbol_Manager_Pop_Scope(sm);
                }
            }
        }
    }

    /* Done loading this package */
    Loading_Set_Remove(name);

    /* Also try to load the package body if available.
     * Skip if a precompiled .ll file exists (package provided externally). */
    if (Body_Already_Loaded(name)) {
        return;  /* Body already loaded */
    }
    if (Has_Precompiled_LL(name)) {
        return;  /* Precompiled version will be linked in */
    }
    char *body_src = Lookup_Path_Body(name);
    if (body_src && Loaded_Body_Count < 128) {
        Mark_Body_Loaded(name);
        /* Parse the body */
        char body_filename[256];
        snprintf(body_filename, sizeof(body_filename), "%.*s.adb", (int)name.length, name.data);
        Parser body_parser = Parser_New(body_src, strlen(body_src), body_filename);
        Syntax_Node *body_cu = Parse_Compilation_Unit(&body_parser);

        if (body_cu && body_cu->compilation_unit.unit) {
            Syntax_Node *body_unit = body_cu->compilation_unit.unit;

            /* Recursively load WITH'd packages from body */
            if (body_cu->compilation_unit.context) {
                Node_List *withs = &body_cu->compilation_unit.context->context.with_clauses;
                for (uint32_t i = 0; i < withs->count; i++) {
                    Syntax_Node *with_node = withs->items[i];
                    for (uint32_t j = 0; j < with_node->use_clause.names.count; j++) {
                        Syntax_Node *pkg_name = with_node->use_clause.names.items[j];
                        if (pkg_name->kind == NK_IDENTIFIER) {
                            char *pkg_src = Lookup_Path(pkg_name->string_val.text);
                            if (pkg_src) {
                                Load_Package_Spec(sm, pkg_name->string_val.text, pkg_src);
                            }
                        }
                    }
                }
            }

            if (body_unit->kind == NK_PACKAGE_BODY) {
                /* Look up the package symbol */
                String_Slice body_name = body_unit->package_body.name;
                Symbol *pkg_sym = Symbol_Find(sm, body_name);

                if (pkg_sym && (pkg_sym->kind == SYMBOL_PACKAGE || pkg_sym->kind == SYMBOL_GENERIC)) {
                    /* Link body to spec */
                    body_unit->symbol = pkg_sym;

                    /* For generic packages, store the body for later instantiation */
                    if (pkg_sym->kind == SYMBOL_GENERIC) {
                        pkg_sym->generic_body = body_unit;
                    }

                    /* Resolve the body within package scope */
                    Symbol_Manager_Push_Scope(sm, pkg_sym);

                    /* Install visible and private declarations from package spec
                     * into the body's scope (RM 7.1, 7.2) */
                    Syntax_Node *spec = pkg_sym->declaration;
                    /* For generics, install formals first, then look at the unit */
                    if (spec && spec->kind == NK_GENERIC_DECL) {
                        Node_List *formals = &spec->generic_decl.formals;
                        for (uint32_t i = 0; i < formals->count; i++) {
                            Syntax_Node *formal = formals->items[i];
                            if (formal->symbol) Symbol_Add(sm, formal->symbol);
                            /* For generic type parameters, create type symbol if needed */
                            if (formal->kind == NK_GENERIC_TYPE_PARAM && !formal->symbol) {
                                Symbol *type_sym = Symbol_New(SYMBOL_TYPE,
                                    formal->generic_type_param.name, formal->location);
                                /* Map def_kind to appropriate Type_Kind */
                                Type_Kind tk = TYPE_PRIVATE;
                                switch (formal->generic_type_param.def_kind) {
                                    case 2: tk = TYPE_ENUMERATION; break; /* DISCRETE */
                                    case 3: tk = TYPE_INTEGER; break;     /* INTEGER */
                                    case 4: tk = TYPE_FLOAT; break;       /* FLOAT */
                                    case 5: tk = TYPE_FIXED; break;       /* FIXED */
                                    default: tk = TYPE_PRIVATE; break;
                                }
                                Type_Info *type = Type_New(tk, formal->generic_type_param.name);
                                type_sym->type = type;
                                formal->symbol = type_sym;
                                Symbol_Add(sm, type_sym);
                            }
                        }
                        spec = spec->generic_decl.unit;
                    }
                    if (spec && spec->kind == NK_PACKAGE_SPEC) {
                        /* Helper: install symbols from a declaration */
                        #define INSTALL_DECL_SYMBOLS(decl) do { \
                            if ((decl)->symbol) Symbol_Add(sm, (decl)->symbol); \
                            if ((decl)->kind == NK_OBJECT_DECL) { \
                                for (uint32_t k = 0; k < (decl)->object_decl.names.count; k++) { \
                                    Syntax_Node *n = (decl)->object_decl.names.items[k]; \
                                    if (n->symbol) Symbol_Add(sm, n->symbol); \
                                } \
                            } \
                            if ((decl)->kind == NK_EXCEPTION_DECL) { \
                                for (uint32_t k = 0; k < (decl)->exception_decl.names.count; k++) { \
                                    Syntax_Node *n = (decl)->exception_decl.names.items[k]; \
                                    if (n->symbol) Symbol_Add(sm, n->symbol); \
                                } \
                            } \
                            if ((decl)->kind == NK_TYPE_DECL && (decl)->type_decl.definition && \
                                (decl)->type_decl.definition->kind == NK_ENUMERATION_TYPE) { \
                                Node_List *lits = &(decl)->type_decl.definition->enum_type.literals; \
                                for (uint32_t k = 0; k < lits->count; k++) { \
                                    if (lits->items[k]->symbol) Symbol_Add(sm, lits->items[k]->symbol); \
                                } \
                            } \
                        } while(0)

                        /* Install visible declarations */
                        for (uint32_t i = 0; i < spec->package_spec.visible_decls.count; i++) {
                            Syntax_Node *decl = spec->package_spec.visible_decls.items[i];
                            INSTALL_DECL_SYMBOLS(decl);
                        }
                        /* Install private declarations */
                        for (uint32_t i = 0; i < spec->package_spec.private_decls.count; i++) {
                            Syntax_Node *decl = spec->package_spec.private_decls.items[i];
                            INSTALL_DECL_SYMBOLS(decl);
                        }
                        #undef INSTALL_DECL_SYMBOLS
                    }

                    Resolve_Declaration_List(sm, &body_unit->package_body.declarations);
                    Symbol_Manager_Pop_Scope(sm);

                    /* Store for code generation */
                    Loaded_Package_Bodies[Loaded_Body_Count++] = body_cu;
                }
            }
        }
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §15. MAIN DRIVER
 * ═══════════════════════════════════════════════════════════════════════════
 */

static char *Read_File(const char *path, size_t *out_size) {
    FILE *f = fopen(path, "rb");
    if (!f) return NULL;

    fseek(f, 0, SEEK_END);
    long fsize = ftell(f);
    if (fsize < 0) { fclose(f); return NULL; }
    size_t size = (size_t)fsize;
    fseek(f, 0, SEEK_SET);

    char *buffer = malloc(size + 1);
    if (!buffer) { fclose(f); return NULL; }

    size_t read = fread(buffer, 1, size, f);
    fclose(f);

    buffer[read] = '\0';
    *out_size = read;
    return buffer;
}

/* Forward declaration for ALI file generation (defined in §16) */
static void Generate_ALI_File(const char *output_path,
                              Syntax_Node **units, int unit_count,
                              const char *source, size_t source_size);

static void Compile_File(const char *input_path, const char *output_path) {
    /* Reset loaded bodies for this compilation */
    Loaded_Body_Count = 0;
    Loaded_Body_Names_Count = 0;

    size_t source_size;
    char *source = Read_File(input_path, &source_size);

    if (!source) {
        fprintf(stderr, "Error: cannot read file '%s'\n", input_path);
        return;
    }

    /* Parse all compilation units in the file */
    Parser parser = Parser_New(source, source_size, input_path);
    Syntax_Node *units[64];
    int unit_count = 0;

    while (parser.current_token.kind != TK_EOF && unit_count < 64 && !parser.had_error) {
        units[unit_count++] = Parse_Compilation_Unit(&parser);
    }

    if (parser.had_error) {
        fprintf(stderr, "Parsing failed with %d error(s)\n", Error_Count);
        free(source);
        return;
    }

    /* Semantic analysis for all units */
    Symbol_Manager *sm = Symbol_Manager_New();
    for (int i = 0; i < unit_count; i++) {
        Resolve_Compilation_Unit(sm, units[i]);
    }

    if (Error_Count > 0) {
        fprintf(stderr, "Semantic analysis failed with %d error(s)\n", Error_Count);
        free(source);
        return;
    }

    /* Code generation */
    FILE *out_file;
    bool close_output = false;

    if (output_path) {
        out_file = fopen(output_path, "w");
        if (!out_file) {
            fprintf(stderr, "Error: cannot open output file '%s'\n", output_path);
            free(source);
            return;
        }
        close_output = true;
    } else {
        out_file = stdout;  /* Output to stdout if no -o specified */
    }

    Code_Generator *cg = Code_Generator_New(out_file, sm);
    for (int i = 0; i < unit_count; i++) {
        Generate_Compilation_Unit(cg, units[i]);
    }

    /* Generate code for loaded package bodies (e.g., TEXT_IO) */
    for (int i = 0; i < Loaded_Body_Count; i++) {
        Generate_Compilation_Unit(cg, Loaded_Package_Bodies[i]);
    }

    /* Emit address marker globals for 'ADDRESS attribute on packages/generics */
    for (uint32_t i = 0; i < cg->address_marker_count; i++) {
        Symbol *sym = cg->address_markers[i];
        Emit(cg, "@__addr.");
        Emit_Symbol_Name(cg, sym);
        Emit(cg, " = linkonce_odr constant i8 0\n");
    }

    /* Emit @main() for the last parameterless library-level procedure */
    if (cg->main_candidate) {
        Emit(cg, "\n; C main entry point\n");
        Emit(cg, "define i32 @main() {\n");
        Emit(cg, "  call void @");
        Emit_Symbol_Name(cg, cg->main_candidate);
        Emit(cg, "()\n");
        Emit(cg, "  ret i32 0\n");
        Emit(cg, "}\n");
    }

    if (close_output) {
        fclose(out_file);
        fprintf(stderr, "Compiled '%s' -> '%s'\n", input_path, output_path);

        /* Generate GNAT-compatible .ali file for dependency tracking */
        Generate_ALI_File(output_path, units, unit_count, source, source_size);
    }
    free(source);
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s [-I path] <input.ada> [-o output.ll]\n", argv[0]);
        return 1;
    }

    const char *input = NULL;
    const char *output = NULL;  /* NULL means stdout */

    /* Parse command-line arguments */
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-I") == 0 && i + 1 < argc) {
            /* Add include path */
            if (Include_Path_Count < 32) {
                Include_Paths[Include_Path_Count++] = argv[++i];
            }
        } else if (strncmp(argv[i], "-I", 2) == 0) {
            /* -Ipath format (no space) */
            if (Include_Path_Count < 32) {
                Include_Paths[Include_Path_Count++] = argv[i] + 2;
            }
        } else if (strcmp(argv[i], "-o") == 0 && i + 1 < argc) {
            output = argv[++i];
        } else if (argv[i][0] != '-') {
            input = argv[i];
        }
    }

    if (!input) {
        fprintf(stderr, "Error: no input file specified\n");
        return 1;
    }

    /* Add current directory to include paths by default */
    if (Include_Path_Count < 32) {
        Include_Paths[Include_Path_Count++] = ".";
    }

    Compile_File(input, output);

    Arena_Free_All();
    return Error_Count > 0 ? 1 : 0;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §16. ALI FILE WRITER — GNAT-Compatible Library Information
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Ada Library Information (.ali) files record compilation dependencies and
 * unit metadata. Format follows GNAT's lib-writ.ads specification:
 *
 *   V "version"              -- compiler version
 *   P flags                  -- compilation parameters
 *   U name source version    -- unit entry
 *   W name [source ali]      -- with dependency
 *   D source timestamp       -- source dependency
 *
 * The ALI file enables:
 *   • Separate compilation with dependency tracking
 *   • Binder consistency checking
 *   • IDE cross-reference navigation
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §16.1 Unit_Info — Compilation unit metadata collector
 * ───────────────────────────────────────────────────────────────────────── */

typedef struct {
    String_Slice      unit_name;        /* Canonical Ada name (Package.Child%b) */
    String_Slice      source_name;      /* File name (package-child.adb) */
    uint32_t          source_checksum;  /* CRC32 of source text */
    bool              is_body;          /* spec (false) or body (true) */
    bool              is_generic;       /* Generic declaration */
    bool              is_preelaborate;  /* Pragma Preelaborate */
    bool              is_pure;          /* Pragma Pure */
    bool              has_elaboration;  /* Has elaboration code */
} Unit_Info;

typedef struct {
    String_Slice      name;             /* WITH'd unit name */
    String_Slice      source_file;      /* Source file name */
    String_Slice      ali_file;         /* ALI file name */
    bool              is_limited;       /* LIMITED WITH */
    bool              elaborate;        /* Pragma Elaborate */
    bool              elaborate_all;    /* Pragma Elaborate_All */
} With_Info;

typedef struct {
    String_Slice      source_file;      /* Depended-on source */
    uint32_t          timestamp;        /* Modification time (Unix epoch) */
    uint32_t          checksum;         /* CRC32 */
} Dependency_Info;

/* Exported symbol info for X lines */
typedef struct {
    String_Slice      name;             /* Ada name */
    String_Slice      mangled_name;     /* LLVM symbol name */
    char              kind;             /* T=type, S=subtype, V=variable, C=constant, P=procedure, F=function, E=exception */
    uint32_t          line;             /* Declaration line number */
    String_Slice      type_name;        /* Type name (for typed symbols) */
    String_Slice      llvm_type;        /* LLVM type signature (e.g., "i64", "ptr", "void (i64)") */
    uint32_t          param_count;      /* Parameter count (for subprograms) */
} Export_Info;

typedef struct {
    Unit_Info         units[8];         /* Units in this compilation */
    uint32_t          unit_count;
    With_Info         withs[64];        /* WITH dependencies */
    uint32_t          with_count;
    Dependency_Info   deps[128];        /* Source dependencies */
    uint32_t          dep_count;
    Export_Info       exports[256];     /* Exported symbols */
    uint32_t          export_count;
} ALI_Info;

/* ─────────────────────────────────────────────────────────────────────────
 * §16.2 CRC32 — Fast checksum for source identity
 *
 * Standard CRC-32/ISO-HDLC polynomial: 0xEDB88320 (bit-reversed 0x04C11DB7)
 * ───────────────────────────────────────────────────────────────────────── */

static uint32_t Crc32_Table[256];
static bool Crc32_Table_Initialized = false;

static void Crc32_Init_Table(void) {
    if (Crc32_Table_Initialized) return;
    for (uint32_t i = 0; i < 256; i++) {
        uint32_t crc = i;
        for (int j = 0; j < 8; j++)
            crc = (crc >> 1) ^ (0xEDB88320 & -(crc & 1));
        Crc32_Table[i] = crc;
    }
    Crc32_Table_Initialized = true;
}

static uint32_t Crc32(const char *data, size_t length) {
    Crc32_Init_Table();
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < length; i++)
        crc = Crc32_Table[(crc ^ (uint8_t)data[i]) & 0xFF] ^ (crc >> 8);
    return ~crc;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §16.3 Unit_Name_To_File — GNAT naming convention
 *
 * Maps Ada unit names to file names:
 *   Package_Name      → package_name.ads
 *   Package_Name%b    → package_name.adb
 *   Parent.Child      → parent-child.ads
 * ───────────────────────────────────────────────────────────────────────── */

static void Unit_Name_To_File(String_Slice unit_name, bool is_body,
                              char *out, size_t out_size) {
    size_t j = 0;
    for (size_t i = 0; i < unit_name.length && j < out_size - 5; i++) {
        char c = unit_name.data[i];
        if (c == '.') {
            out[j++] = '-';  /* Dots become hyphens */
        } else if (c >= 'A' && c <= 'Z') {
            out[j++] = c - 'A' + 'a';  /* Lowercase */
        } else {
            out[j++] = c;
        }
    }
    /* Append extension */
    const char *ext = is_body ? ".adb" : ".ads";
    for (int k = 0; ext[k] && j < out_size - 1; k++)
        out[j++] = ext[k];
    out[j] = '\0';
}

/* ─────────────────────────────────────────────────────────────────────────
 * §16.4 ALI_Collect — Gather unit info from parsed AST
 * ───────────────────────────────────────────────────────────────────────── */

static void ALI_Collect_Withs(ALI_Info *ali, Syntax_Node *ctx) {
    if (!ctx) return;

    for (uint32_t i = 0; i < ctx->context.with_clauses.count; i++) {
        Syntax_Node *with_node = ctx->context.with_clauses.items[i];
        if (!with_node) continue;

        /* Each WITH clause may have multiple names */
        for (uint32_t j = 0; j < with_node->use_clause.names.count; j++) {
            Syntax_Node *name = with_node->use_clause.names.items[j];
            if (!name || ali->with_count >= 64) continue;

            With_Info *w = &ali->withs[ali->with_count++];
            w->name = name->kind == NK_IDENTIFIER ?
                      name->string_val.text : (String_Slice){0};
            w->is_limited = false;  /* TODO: detect LIMITED WITH */
            w->elaborate = false;
            w->elaborate_all = false;

            /* Derive file names from unit name */
            char file_buf[256];
            if (w->name.data) {
                Unit_Name_To_File(w->name, false, file_buf, sizeof(file_buf));
                w->source_file = Slice_Duplicate((String_Slice){file_buf, strlen(file_buf)});
                size_t len = strlen(file_buf);
                if (len > 4) {
                    file_buf[len-3] = 'a';
                    file_buf[len-2] = 'l';
                    file_buf[len-1] = 'i';
                }
                w->ali_file = Slice_Duplicate((String_Slice){file_buf, strlen(file_buf)});
            }
        }
    }
}

/* Helper: extract unit name from a subprogram spec/body */
static String_Slice Get_Subprogram_Name(Syntax_Node *node) {
    if (!node) return (String_Slice){"UNKNOWN", 7};
    if (node->kind == NK_PROCEDURE_SPEC || node->kind == NK_FUNCTION_SPEC)
        return node->subprogram_spec.name;
    if (node->kind == NK_PROCEDURE_BODY || node->kind == NK_FUNCTION_BODY) {
        /* Body has spec nested inside */
        if (node->subprogram_body.specification)
            return Get_Subprogram_Name(node->subprogram_body.specification);
    }
    return (String_Slice){"UNKNOWN", 7};
}

/* Forward declaration */
static void ALI_Collect_Exports(ALI_Info *ali, Syntax_Node *unit);

static void ALI_Collect_Unit(ALI_Info *ali, Syntax_Node *cu,
                             const char *source, size_t source_size) {
    if (!cu || ali->unit_count >= 8) return;

    Syntax_Node *unit = cu->compilation_unit.unit;
    if (!unit) return;

    Unit_Info *u = &ali->units[ali->unit_count++];

    /* Extract unit name based on declaration kind */
    switch (unit->kind) {
        case NK_PACKAGE_SPEC:
            u->unit_name = unit->package_spec.name;
            u->is_body = false;
            break;
        case NK_PACKAGE_BODY:
            u->unit_name = unit->package_body.name;
            u->is_body = true;
            break;
        case NK_PROCEDURE_BODY:
        case NK_PROCEDURE_SPEC:
            u->unit_name = Get_Subprogram_Name(unit);
            u->is_body = unit->kind == NK_PROCEDURE_BODY;
            break;
        case NK_FUNCTION_BODY:
        case NK_FUNCTION_SPEC:
            u->unit_name = Get_Subprogram_Name(unit);
            u->is_body = unit->kind == NK_FUNCTION_BODY;
            break;
        case NK_GENERIC_DECL:
            u->is_generic = true;
            if (unit->generic_decl.unit) {
                Syntax_Node *inner = unit->generic_decl.unit;
                if (inner->kind == NK_PACKAGE_SPEC)
                    u->unit_name = inner->package_spec.name;
                else if (inner->kind == NK_PROCEDURE_SPEC || inner->kind == NK_FUNCTION_SPEC)
                    u->unit_name = inner->subprogram_spec.name;
            }
            u->is_body = false;
            break;
        default:
            u->unit_name = (String_Slice){"UNKNOWN", 7};
            u->is_body = false;
    }

    /* Compute source checksum */
    u->source_checksum = Crc32(source, source_size);

    /* Derive source file name */
    char file_buf[256];
    Unit_Name_To_File(u->unit_name, u->is_body, file_buf, sizeof(file_buf));
    u->source_name = Slice_Duplicate((String_Slice){file_buf, strlen(file_buf)});

    /* Check for elaboration pragmas (simplified) */
    u->is_preelaborate = false;
    u->is_pure = false;
    u->has_elaboration = true;  /* Assume has elaboration unless proven otherwise */

    /* Collect WITH dependencies */
    ALI_Collect_Withs(ali, cu->compilation_unit.context);

    /* Collect exported symbols from package specs */
    if (unit && unit->kind == NK_PACKAGE_SPEC) {
        ALI_Collect_Exports(ali, unit);
    }
}

/* Basic LLVM type signature (minimal for now) */
static String_Slice LLVM_Type_Basic(String_Slice ada_type) {
    /* Standard types */
    if (Slice_Equal_Ignore_Case(ada_type, (String_Slice){"integer", 7})) return (String_Slice){"i64", 3};
    if (Slice_Equal_Ignore_Case(ada_type, (String_Slice){"natural", 7})) return (String_Slice){"i64", 3};
    if (Slice_Equal_Ignore_Case(ada_type, (String_Slice){"positive", 8})) return (String_Slice){"i64", 3};
    if (Slice_Equal_Ignore_Case(ada_type, (String_Slice){"boolean", 7})) return (String_Slice){"i1", 2};
    if (Slice_Equal_Ignore_Case(ada_type, (String_Slice){"character", 9})) return (String_Slice){"i8", 2};
    if (Slice_Equal_Ignore_Case(ada_type, (String_Slice){"float", 5})) return (String_Slice){"double", 6};
    if (Slice_Equal_Ignore_Case(ada_type, (String_Slice){"long_float", 10})) return (String_Slice){"double", 6};
    if (Slice_Equal_Ignore_Case(ada_type, (String_Slice){"string", 6})) return (String_Slice){"{ptr,{i64,i64}}", 15};
    /* Default: treat as integer type */
    return (String_Slice){"i64", 3};
}

/* ─────────────────────────────────────────────────────────────────────────
 * §16.4.2 ALI_Collect_Exports — Gather exported symbols from package spec
 * ───────────────────────────────────────────────────────────────────────── */

static void ALI_Collect_Exports(ALI_Info *ali, Syntax_Node *unit) {
    if (!unit || unit->kind != NK_PACKAGE_SPEC) return;

    String_Slice pkg_name = unit->package_spec.name;
    Node_List *decls = &unit->package_spec.visible_decls;

    for (uint32_t i = 0; i < decls->count && ali->export_count < 256; i++) {
        Syntax_Node *decl = decls->items[i];
        if (!decl) continue;

        Export_Info *exp = &ali->exports[ali->export_count];
        exp->line = decl->location.line;
        exp->param_count = 0;
        exp->type_name = (String_Slice){0};
        exp->mangled_name = (String_Slice){0};
        exp->llvm_type = (String_Slice){0};

        switch (decl->kind) {
            case NK_TYPE_DECL:
                exp->name = decl->type_decl.name;
                exp->kind = 'T';
                exp->mangled_name = Mangle_Qualified_Name(pkg_name, exp->name);
                exp->llvm_type = (String_Slice){"i64", 3};  /* Default integer representation */
                ali->export_count++;
                break;

            case NK_SUBTYPE_DECL:
                exp->name = decl->type_decl.name;
                exp->kind = 'S';
                exp->mangled_name = Mangle_Qualified_Name(pkg_name, exp->name);
                if (decl->type_decl.definition) {
                    Syntax_Node *def = decl->type_decl.definition;
                    if (def->kind == NK_IDENTIFIER) {
                        exp->type_name = def->string_val.text;
                        exp->llvm_type = LLVM_Type_Basic(exp->type_name);
                    } else if (def->kind == NK_SUBTYPE_INDICATION && def->subtype_ind.subtype_mark) {
                        if (def->subtype_ind.subtype_mark->kind == NK_IDENTIFIER) {
                            exp->type_name = def->subtype_ind.subtype_mark->string_val.text;
                            exp->llvm_type = LLVM_Type_Basic(exp->type_name);
                        }
                    }
                }
                if (!exp->llvm_type.data) exp->llvm_type = (String_Slice){"i64", 3};
                ali->export_count++;
                break;

            case NK_OBJECT_DECL:
                for (uint32_t j = 0; j < decl->object_decl.names.count && ali->export_count < 256; j++) {
                    Syntax_Node *name = decl->object_decl.names.items[j];
                    if (name && name->kind == NK_IDENTIFIER) {
                        exp = &ali->exports[ali->export_count];
                        exp->name = name->string_val.text;
                        exp->kind = decl->object_decl.is_constant ? 'C' : 'V';
                        exp->line = name->location.line;
                        exp->mangled_name = Mangle_Qualified_Name(pkg_name, exp->name);
                        if (decl->object_decl.object_type && decl->object_decl.object_type->kind == NK_IDENTIFIER) {
                            exp->type_name = decl->object_decl.object_type->string_val.text;
                            exp->llvm_type = LLVM_Type_Basic(exp->type_name);
                        } else {
                            exp->llvm_type = (String_Slice){"i64", 3};
                        }
                        ali->export_count++;
                    }
                }
                break;

            case NK_PROCEDURE_SPEC:
                exp->name = decl->subprogram_spec.name;
                exp->kind = 'P';
                exp->mangled_name = Mangle_Qualified_Name(pkg_name, exp->name);
                for (uint32_t j = 0; j < decl->subprogram_spec.parameters.count; j++) {
                    Syntax_Node *ps = decl->subprogram_spec.parameters.items[j];
                    if (ps && ps->kind == NK_PARAM_SPEC)
                        exp->param_count += ps->param_spec.names.count;
                }
                exp->llvm_type = (String_Slice){"void", 4};
                ali->export_count++;
                break;

            case NK_FUNCTION_SPEC:
                exp->name = decl->subprogram_spec.name;
                exp->kind = 'F';
                exp->mangled_name = Mangle_Qualified_Name(pkg_name, exp->name);
                for (uint32_t j = 0; j < decl->subprogram_spec.parameters.count; j++) {
                    Syntax_Node *ps = decl->subprogram_spec.parameters.items[j];
                    if (ps && ps->kind == NK_PARAM_SPEC)
                        exp->param_count += ps->param_spec.names.count;
                }
                if (decl->subprogram_spec.return_type && decl->subprogram_spec.return_type->kind == NK_IDENTIFIER) {
                    exp->type_name = decl->subprogram_spec.return_type->string_val.text;
                    exp->llvm_type = LLVM_Type_Basic(exp->type_name);
                } else {
                    exp->llvm_type = (String_Slice){"i64", 3};
                }
                ali->export_count++;
                break;

            case NK_EXCEPTION_DECL:
                for (uint32_t j = 0; j < decl->exception_decl.names.count && ali->export_count < 256; j++) {
                    Syntax_Node *name = decl->exception_decl.names.items[j];
                    if (name && name->kind == NK_IDENTIFIER) {
                        exp = &ali->exports[ali->export_count];
                        exp->name = name->string_val.text;
                        exp->kind = 'E';
                        exp->line = name->location.line;
                        exp->mangled_name = Mangle_Qualified_Name(pkg_name, exp->name);
                        exp->llvm_type = (String_Slice){"i8", 2};  /* Exception identity */
                        ali->export_count++;
                    }
                }
                break;

            default:
                break;
        }
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §16.5 ALI_Write — Emit .ali file in GNAT format
 *
 * Per lib-writ.ads, the minimum valid ALI file needs:
 *   V line (version) — MUST be first
 *   P line (parameters) — MUST be present
 *   At least one U line (unit)
 * ───────────────────────────────────────────────────────────────────────── */

#define ALI_VERSION "Ada83 1.0"

static void ALI_Write(FILE *out, ALI_Info *ali) {
    /* V line: Version — must be first per GNAT spec */
    fprintf(out, "V \"%s\"\n", ALI_VERSION);

    /* P line: Parameters/flags — ZX = zero-cost exceptions */
    fprintf(out, "P ZX\n");

    /* Blank line before restrictions */
    fprintf(out, "\n");

    /* R line: Restrictions (minimal) */
    fprintf(out, "RN\n");

    /* U lines: Unit entries */
    for (uint32_t i = 0; i < ali->unit_count; i++) {
        Unit_Info *u = &ali->units[i];

        /* U unit-name source-name version [flags] */
        fprintf(out, "\nU %.*s%s %.*s %08X",
                (int)u->unit_name.length, u->unit_name.data,
                u->is_body ? "%b" : "%s",
                (int)u->source_name.length, u->source_name.data,
                u->source_checksum);

        /* Flags */
        if (u->is_generic) fprintf(out, " GE");
        if (u->is_preelaborate) fprintf(out, " PR");
        if (u->is_pure) fprintf(out, " PU");
        if (!u->has_elaboration) fprintf(out, " NE");
        if (!u->is_body) fprintf(out, " PK");
        else fprintf(out, " SU");
        fprintf(out, "\n");

        /* W lines: WITH dependencies for this unit */
        for (uint32_t j = 0; j < ali->with_count; j++) {
            With_Info *w = &ali->withs[j];
            if (!w->name.data) continue;

            char line_type = w->is_limited ? 'Y' : 'W';
            fprintf(out, "%c %.*s%s",
                    line_type,
                    (int)w->name.length, w->name.data,
                    "%s");  /* Assume spec dependency */

            if (w->source_file.data) {
                fprintf(out, " %.*s %.*s",
                        (int)w->source_file.length, w->source_file.data,
                        (int)w->ali_file.length, w->ali_file.data);
            }

            if (w->elaborate) fprintf(out, " E");
            if (w->elaborate_all) fprintf(out, " EA");
            fprintf(out, "\n");
        }
    }

    /* D lines: Source dependencies */
    fprintf(out, "\n");
    for (uint32_t i = 0; i < ali->unit_count; i++) {
        Unit_Info *u = &ali->units[i];
        /* Self-dependency */
        fprintf(out, "D %.*s 00000000 %08X\n",
                (int)u->source_name.length, u->source_name.data,
                u->source_checksum);
    }
    for (uint32_t i = 0; i < ali->with_count; i++) {
        With_Info *w = &ali->withs[i];
        if (w->source_file.data) {
            fprintf(out, "D %.*s 00000000 00000000\n",
                    (int)w->source_file.length, w->source_file.data);
        }
    }

    /* X lines: Exported symbols (extended format for Ada83 separate compilation)
     *
     * Format: X kind name:line llvm_type @mangled [ada_type] [(params)]
     *
     *   kind: T=type, S=subtype, V=variable, C=constant, P=procedure, F=function, E=exception
     *   llvm_type: LLVM IR type signature (i64, double, void, ptr, etc.)
     *   @mangled: LLVM symbol name for linking
     *   ada_type: Ada type name for typed symbols
     *   (params): Parameter count for subprograms
     *
     * This provides everything needed to compile against the package without source:
     *   - Type checking via ada_type
     *   - Code generation via llvm_type and @mangled
     *   - Linking via @mangled symbol references
     */
    if (ali->export_count > 0) {
        fprintf(out, "\n");
        for (uint32_t i = 0; i < ali->export_count; i++) {
            Export_Info *x = &ali->exports[i];

            /* X kind name:line */
            fprintf(out, "X %c %.*s:%u",
                    x->kind,
                    (int)x->name.length, x->name.data,
                    x->line);

            /* llvm_type */
            if (x->llvm_type.data) {
                fprintf(out, " %.*s", (int)x->llvm_type.length, x->llvm_type.data);
            } else {
                fprintf(out, " i64");
            }

            /* @mangled */
            if (x->mangled_name.data) {
                fprintf(out, " @%.*s", (int)x->mangled_name.length, x->mangled_name.data);
            }

            /* ada_type (for typed symbols) */
            if (x->type_name.data) {
                fprintf(out, " %.*s", (int)x->type_name.length, x->type_name.data);
            }

            /* (params) for subprograms */
            if (x->param_count > 0) {
                fprintf(out, " (%u)", x->param_count);
            }

            fprintf(out, "\n");
        }
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §16.6 Generate_ALI_File — Entry point for ALI generation
 * ───────────────────────────────────────────────────────────────────────── */

static void Generate_ALI_File(const char *output_path,
                              Syntax_Node **units, int unit_count,
                              const char *source, size_t source_size) {
    /* Build ALI path from output path (replace .ll with .ali) */
    char ali_path[512];
    size_t len = strlen(output_path);
    if (len > 3 && strcmp(output_path + len - 3, ".ll") == 0) {
        snprintf(ali_path, sizeof(ali_path), "%.*s.ali", (int)(len - 3), output_path);
    } else {
        snprintf(ali_path, sizeof(ali_path), "%s.ali", output_path);
    }

    FILE *ali_file = fopen(ali_path, "w");
    if (!ali_file) {
        fprintf(stderr, "Warning: cannot create ALI file '%s'\n", ali_path);
        return;
    }

    /* Collect information from all compilation units */
    ALI_Info ali = {0};
    for (int i = 0; i < unit_count; i++) {
        ALI_Collect_Unit(&ali, units[i], source, source_size);
    }

    /* Write ALI file */
    ALI_Write(ali_file, &ali);
    fclose(ali_file);

    fprintf(stderr, "Generated ALI file '%s'\n", ali_path);
}

/* ─────────────────────────────────────────────────────────────────────────
 * §16.7 ALI_Reader — Parse .ali files for dependency management
 *
 * We read ALI files to:
 *   1. Skip recompilation of unchanged units (checksum match)
 *   2. Load exported symbols from precompiled packages
 *   3. Track dependencies for elaboration ordering
 *   4. Find generic templates for instantiation
 * ───────────────────────────────────────────────────────────────────────── */

/* Parsed export from X line */
typedef struct {
    char            kind;            /* T/S/V/C/P/F/E */
    char           *name;            /* Ada symbol name */
    char           *mangled_name;    /* LLVM symbol name for linking */
    char           *llvm_type;       /* LLVM type signature */
    uint32_t        line;            /* Source line */
    char           *type_name;       /* Ada type name (or NULL) */
    uint32_t        param_count;     /* For subprograms */
} ALI_Export;

/* Cached ALI information for loaded units
 * ALI_Cache_Entry is forward declared as ALI_Cache_Entry_Forward in the
 * Load_Package_Spec forward declarations section. */
typedef struct ALI_Cache_Entry_Forward {
    char           *unit_name;       /* Canonical name (e.g., "text_io") */
    char           *source_file;     /* Source file name */
    char           *ali_file;        /* ALI file path */
    uint32_t        checksum;        /* Source checksum from ALI */
    bool            is_spec;         /* true = spec, false = body */
    bool            is_generic;      /* Generic unit */
    bool            is_preelaborate; /* Has Preelaborate pragma */
    bool            is_pure;         /* Has Pure pragma */
    bool            loaded;          /* Symbols already loaded */

    /* With dependencies */
    char           *withs[64];       /* WITH'd unit names */
    uint32_t        with_count;

    /* Exported symbols from X lines */
    ALI_Export      exports[256];
    uint32_t        export_count;
} ALI_Cache_Entry;

/* Global ALI cache */
static ALI_Cache_Entry ALI_Cache[256];
static uint32_t        ALI_Cache_Count = 0;

/* Skip whitespace */
static const char *ALI_Skip_Ws(const char *p) {
    while (*p == ' ' || *p == '\t') p++;
    return p;
}

/* Read until whitespace or newline, return end pointer */
static const char *ALI_Read_Token(const char *p, char *buf, size_t bufsize) {
    p = ALI_Skip_Ws(p);
    size_t i = 0;
    while (*p && *p != ' ' && *p != '\t' && *p != '\n' && i < bufsize - 1) {
        buf[i++] = *p++;
    }
    buf[i] = '\0';
    return p;
}

/* Parse a hex value */
static uint32_t ALI_Parse_Hex(const char *s) {
    uint32_t val = 0;
    while (*s) {
        char c = *s++;
        if (c >= '0' && c <= '9') val = (val << 4) | (c - '0');
        else if (c >= 'A' && c <= 'F') val = (val << 4) | (c - 'A' + 10);
        else if (c >= 'a' && c <= 'f') val = (val << 4) | (c - 'a' + 10);
        else break;
    }
    return val;
}

/* Read and parse an ALI file, returning cache entry or NULL */
static ALI_Cache_Entry *ALI_Read(const char *ali_path) {
    /* Check if already cached */
    for (uint32_t i = 0; i < ALI_Cache_Count; i++) {
        if (ALI_Cache[i].ali_file && strcmp(ALI_Cache[i].ali_file, ali_path) == 0) {
            return &ALI_Cache[i];
        }
    }

    /* Read ALI file */
    FILE *f = fopen(ali_path, "r");
    if (!f) return NULL;

    /* Allocate cache entry */
    if (ALI_Cache_Count >= 256) {
        fclose(f);
        return NULL;
    }
    ALI_Cache_Entry *entry = &ALI_Cache[ALI_Cache_Count++];
    memset(entry, 0, sizeof(*entry));
    entry->ali_file = strdup(ali_path);

    char line[1024];
    char token[256];

    while (fgets(line, sizeof(line), f)) {
        const char *p = line;

        if (line[0] == 'V') {
            /* Version line: V "version" — we accept any version */
            continue;
        }
        else if (line[0] == 'P') {
            /* Parameters line: P flags */
            continue;
        }
        else if (line[0] == 'U') {
            /* Unit line: U name source checksum [flags] */
            p = ALI_Read_Token(p + 1, token, sizeof(token));  /* Skip 'U' */

            /* Unit name (with %s/%b suffix) */
            char *pct = strchr(token, '%');
            if (pct) {
                entry->is_spec = (pct[1] == 's');
                *pct = '\0';
            }
            entry->unit_name = strdup(token);

            /* Source file */
            p = ALI_Read_Token(p, token, sizeof(token));
            entry->source_file = strdup(token);

            /* Checksum */
            p = ALI_Read_Token(p, token, sizeof(token));
            entry->checksum = ALI_Parse_Hex(token);

            /* Parse flags */
            while (*p && *p != '\n') {
                p = ALI_Read_Token(p, token, sizeof(token));
                if (strcmp(token, "GE") == 0) entry->is_generic = true;
                else if (strcmp(token, "PR") == 0) entry->is_preelaborate = true;
                else if (strcmp(token, "PU") == 0) entry->is_pure = true;
            }
        }
        else if (line[0] == 'W' || line[0] == 'Y' || line[0] == 'Z') {
            /* With line: W/Y/Z name [source ali] [flags] */
            p = ALI_Read_Token(p + 1, token, sizeof(token));

            /* Strip %s/%b suffix */
            char *pct = strchr(token, '%');
            if (pct) *pct = '\0';

            if (entry->with_count < 64) {
                entry->withs[entry->with_count++] = strdup(token);
            }
        }
        else if (line[0] == 'D') {
            /* Dependency line: D source timestamp checksum — informational */
            continue;
        }
        else if (line[0] == 'X') {
            /* Export line: X kind name:line llvm_type @mangled [ada_type] [(params)]
             *
             * Example: X F Get_Value:9 i64 @test_exports__get_value Counter
             */
            if (entry->export_count >= 256) continue;

            ALI_Export *exp = &entry->exports[entry->export_count];
            memset(exp, 0, sizeof(*exp));

            p = ALI_Skip_Ws(p + 1);  /* Skip 'X' */

            /* Kind (single char: T/S/V/C/P/F/E) */
            exp->kind = *p++;
            p = ALI_Skip_Ws(p);

            /* Name:line */
            p = ALI_Read_Token(p, token, sizeof(token));
            char *colon = strchr(token, ':');
            if (colon) {
                *colon = '\0';
                exp->name = strdup(token);
                exp->line = (uint32_t)atoi(colon + 1);
            } else {
                exp->name = strdup(token);
                exp->line = 0;
            }

            /* llvm_type */
            p = ALI_Skip_Ws(p);
            if (*p && *p != '\n') {
                p = ALI_Read_Token(p, token, sizeof(token));
                if (token[0]) exp->llvm_type = strdup(token);
            }

            /* @mangled */
            p = ALI_Skip_Ws(p);
            if (*p == '@') {
                p++;  /* Skip '@' */
                p = ALI_Read_Token(p, token, sizeof(token));
                if (token[0]) exp->mangled_name = strdup(token);
            }

            /* Remaining tokens: ada_type and/or (params) */
            while (*p && *p != '\n') {
                p = ALI_Skip_Ws(p);
                if (*p == '(') {
                    /* (params) */
                    p = ALI_Read_Token(p, token, sizeof(token));
                    exp->param_count = (uint32_t)atoi(token + 1);
                } else if (*p && *p != '\n') {
                    /* ada_type */
                    p = ALI_Read_Token(p, token, sizeof(token));
                    if (token[0] && token[0] != '(') {
                        if (exp->type_name) free(exp->type_name);
                        exp->type_name = strdup(token);
                    }
                }
            }

            entry->export_count++;
        }
    }

    fclose(f);
    return entry;
}

/* Check if an ALI file is up-to-date with its source */
static bool ALI_Is_Current(const char *ali_path, const char *source_path) {
    ALI_Cache_Entry *entry = ALI_Read(ali_path);
    if (!entry) return false;

    /* Read source and compute checksum */
    size_t source_size;
    char *source = Read_File(source_path, &source_size);
    if (!source) return false;

    uint32_t current_checksum = Crc32(source, source_size);
    free(source);

    return (current_checksum == entry->checksum);
}

/* Find ALI file for a unit name in include paths */
static char *ALI_Find(String_Slice unit_name) {
    static char path_buf[512];
    char file_buf[256];

    /* Convert unit name to file name (lowercase, dots to hyphens) */
    size_t j = 0;
    for (size_t i = 0; i < unit_name.length && j < sizeof(file_buf) - 5; i++) {
        char c = unit_name.data[i];
        if (c == '.') file_buf[j++] = '-';
        else if (c >= 'A' && c <= 'Z') file_buf[j++] = c - 'A' + 'a';
        else file_buf[j++] = c;
    }
    file_buf[j] = '\0';

    /* Try each include path */
    for (uint32_t i = 0; i < Include_Path_Count; i++) {
        snprintf(path_buf, sizeof(path_buf), "%s/%s.ali", Include_Paths[i], file_buf);
        if (access(path_buf, R_OK) == 0) {
            return path_buf;
        }
    }

    return NULL;
}

/* Load symbols from an ALI file into the symbol manager */
static void ALI_Load_Symbols(Symbol_Manager *sm, ALI_Cache_Entry *entry) {
    if (!entry || entry->loaded) return;
    entry->loaded = true;

    /* Recursively load dependencies first */
    for (uint32_t i = 0; i < entry->with_count; i++) {
        char *dep_ali = ALI_Find((String_Slice){entry->withs[i], strlen(entry->withs[i])});
        if (dep_ali) {
            ALI_Cache_Entry *dep = ALI_Read(dep_ali);
            if (dep) ALI_Load_Symbols(sm, dep);
        }
    }

    /* For specs, create package symbol and exports */
    if (!entry->is_spec || entry->export_count == 0) return;

    String_Slice pkg_name = {entry->unit_name, strlen(entry->unit_name)};

    /* Check if package already exists */
    Symbol *pkg_sym = Symbol_Find(sm, pkg_name);
    if (pkg_sym) return;

    /* Create package symbol */
    Source_Location loc = {entry->source_file, 1, 1};
    pkg_sym = Symbol_New(SYMBOL_PACKAGE, pkg_name, loc);
    pkg_sym->type = Type_New(TYPE_PACKAGE, pkg_name);
    Symbol_Add(sm, pkg_sym);

    /* Allocate exported array for qualified access */
    if (entry->export_count > 0) {
        pkg_sym->exported = Arena_Allocate(entry->export_count * sizeof(Symbol*));
        pkg_sym->exported_count = 0;
    }

    /* Push package scope to add exports */
    Symbol_Manager_Push_Scope(sm, pkg_sym);

    /* Create symbols from exports
     *
     * The mangled_name from ALI becomes external_name on Symbol,
     * enabling direct LLVM references without re-mangling.
     */
    for (uint32_t i = 0; i < entry->export_count; i++) {
        ALI_Export *exp = &entry->exports[i];
        String_Slice name = {exp->name, strlen(exp->name)};
        String_Slice mangled = exp->mangled_name ?
            (String_Slice){exp->mangled_name, strlen(exp->mangled_name)} : (String_Slice){0};
        Source_Location exp_loc = {entry->source_file, exp->line, 1};

        Symbol *sym = NULL;
        switch (exp->kind) {
            case 'T': {
                /* Type: create type symbol with proper bounds later */
                sym = Symbol_New(SYMBOL_TYPE, name, exp_loc);
                Type_Info *t = Type_New(TYPE_INTEGER, name);
                sym->type = t;
                break;
            }
            case 'S': {
                /* Subtype: link to base type */
                sym = Symbol_New(SYMBOL_SUBTYPE, name, exp_loc);
                if (exp->type_name) {
                    String_Slice base = {exp->type_name, strlen(exp->type_name)};
                    Symbol *base_sym = Symbol_Find(sm, base);
                    sym->type = base_sym ? base_sym->type : Type_New(TYPE_INTEGER, base);
                } else {
                    sym->type = Type_New(TYPE_INTEGER, name);
                }
                break;
            }
            case 'V': {
                /* Variable: external reference */
                sym = Symbol_New(SYMBOL_VARIABLE, name, exp_loc);
                sym->is_imported = true;
                sym->external_name = mangled;
                if (exp->type_name) {
                    String_Slice tn = {exp->type_name, strlen(exp->type_name)};
                    Symbol *ts = Symbol_Find(sm, tn);
                    sym->type = ts ? ts->type : Type_New(TYPE_INTEGER, tn);
                }
                break;
            }
            case 'C': {
                /* Constant: external reference */
                sym = Symbol_New(SYMBOL_CONSTANT, name, exp_loc);
                sym->is_imported = true;
                sym->external_name = mangled;
                if (exp->type_name) {
                    String_Slice tn = {exp->type_name, strlen(exp->type_name)};
                    Symbol *ts = Symbol_Find(sm, tn);
                    sym->type = ts ? ts->type : Type_New(TYPE_INTEGER, tn);
                }
                break;
            }
            case 'P': {
                /* Procedure: external subprogram declaration */
                sym = Symbol_New(SYMBOL_PROCEDURE, name, exp_loc);
                sym->is_imported = true;
                sym->external_name = mangled;
                sym->parameter_count = exp->param_count;
                break;
            }
            case 'F': {
                /* Function: external subprogram declaration */
                sym = Symbol_New(SYMBOL_FUNCTION, name, exp_loc);
                sym->is_imported = true;
                sym->external_name = mangled;
                sym->parameter_count = exp->param_count;
                if (exp->type_name) {
                    String_Slice tn = {exp->type_name, strlen(exp->type_name)};
                    Symbol *ts = Symbol_Find(sm, tn);
                    sym->return_type = ts ? ts->type : Type_New(TYPE_INTEGER, tn);
                    sym->type = sym->return_type;  /* For consistency */
                }
                break;
            }
            case 'E': {
                /* Exception: external exception identity */
                sym = Symbol_New(SYMBOL_EXCEPTION, name, exp_loc);
                sym->is_imported = true;
                sym->external_name = mangled;
                break;
            }
        }

        if (sym) {
            sym->parent = pkg_sym;  /* Set parent for proper scoping */
            Symbol_Add(sm, sym);
            /* Also add to package exported list for qualified access */
            if (pkg_sym->exported_count < 256) {
                pkg_sym->exported[pkg_sym->exported_count++] = sym;
            }
        }
    }

    Symbol_Manager_Pop_Scope(sm);
}

/* Try_Load_From_ALI — Called by Load_Package_Spec to attempt ALI-based loading
 *
 * This is the entry point for ALI-based separate compilation:
 *   1. Look for ALI file in include paths
 *   2. Verify checksum against source
 *   3. Load symbols directly from ALI X lines
 *
 * Returns true if successful (caller should skip parsing).
 */
static bool Try_Load_From_ALI(Symbol_Manager *sm, String_Slice name) {
    char *ali_path = ALI_Find(name);
    if (!ali_path) return false;

    /* Build source path from unit name */
    char source_file[256];
    size_t j = 0;
    for (size_t i = 0; i < name.length && j < sizeof(source_file) - 5; i++) {
        char c = name.data[i];
        if (c == '.') source_file[j++] = '-';
        else if (c >= 'A' && c <= 'Z') source_file[j++] = c - 'A' + 'a';
        else source_file[j++] = c;
    }
    strcpy(source_file + j, ".ads");

    /* Find full source path in include paths */
    char full_source_path[512] = {0};
    for (uint32_t i = 0; i < Include_Path_Count; i++) {
        snprintf(full_source_path, sizeof(full_source_path), "%s/%s",
                 Include_Paths[i], source_file);
        if (access(full_source_path, R_OK) == 0) break;
        full_source_path[0] = '\0';
    }

    if (!full_source_path[0]) return false;

    /* Check if ALI is current */
    if (!ALI_Is_Current(ali_path, full_source_path)) {
        return false;  /* Stale - need to recompile */
    }

    /* Read ALI and check for exports */
    ALI_Cache_Entry *entry = ALI_Read(ali_path);
    if (!entry || entry->export_count == 0) return false;

    /* Load symbols from ALI */
    ALI_Load_Symbols(sm, entry);
    return true;
}

/* ═══════════════════════════════════════════════════════════════════════════
 * §17. GENERIC EXPANSION - Macro-style instantiation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * GNAT implements generics via macro expansion (sem_ch12.adb):
 *   1. Parse generic declaration → store template AST
 *   2. On instantiation: clone template, substitute actuals
 *   3. Analyze cloned tree with actual types
 *   4. Generate code for each instantiation separately
 *
 * Key insight: We do NOT share code between instantiations. Each instance
 * gets its own copy with types fully substituted.
 */

/* ─────────────────────────────────────────────────────────────────────────
 * §17.1 Instantiation_Env — Formal-to-actual mapping
 *
 * Instead of mutating nodes, we carry substitution environment through.
 * ───────────────────────────────────────────────────────────────────────── */

typedef struct {
    String_Slice  formal_name;    /* Generic formal parameter name */
    Type_Info    *actual_type;    /* Substituted actual type */
    Symbol       *actual_symbol;  /* Actual symbol (for subprogram formals) */
    Syntax_Node  *actual_expr;    /* Actual expression (for object formals) */
} Generic_Mapping;

typedef struct {
    Generic_Mapping  mappings[32];
    uint32_t         count;
    Symbol          *instance_sym;   /* The instantiation symbol */
    Symbol          *template_sym;   /* The generic template symbol */
} Instantiation_Env;

/* ─────────────────────────────────────────────────────────────────────────
 * §17.2 Instantiation_Env helpers
 * ───────────────────────────────────────────────────────────────────────── */

static Type_Info *Env_Lookup_Type(Instantiation_Env *env, String_Slice name) {
    for (uint32_t i = 0; i < env->count; i++) {
        if (Slice_Equal_Ignore_Case(env->mappings[i].formal_name, name))
            return env->mappings[i].actual_type;
    }
    return NULL;
}

static Symbol *Env_Lookup_Symbol(Instantiation_Env *env, String_Slice name) {
    for (uint32_t i = 0; i < env->count; i++) {
        if (Slice_Equal_Ignore_Case(env->mappings[i].formal_name, name))
            return env->mappings[i].actual_symbol;
    }
    return NULL;
}

static Syntax_Node *Env_Lookup_Expr(Instantiation_Env *env, String_Slice name) {
    for (uint32_t i = 0; i < env->count; i++) {
        if (Slice_Equal_Ignore_Case(env->mappings[i].formal_name, name))
            return env->mappings[i].actual_expr;
    }
    return NULL;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §17.3 Node_Deep_Clone — Deep copy with environment substitution
 *
 * Unlike the existing node_clone_substitute, this:
 *   • ALWAYS allocates new nodes (no aliasing)
 *   • Uses recursion depth tracking with proper error
 *   • Carries environment for type substitution
 * ───────────────────────────────────────────────────────────────────────── */

static Syntax_Node *Node_Deep_Clone(Syntax_Node *node, Instantiation_Env *env,
                                    int depth);

/* Clone a node list */
static void Node_List_Clone(Node_List *dst, Node_List *src,
                            Instantiation_Env *env, int depth) {
    dst->count = 0;
    dst->capacity = 0;
    dst->items = NULL;
    for (uint32_t i = 0; i < src->count; i++) {
        Syntax_Node *cloned = Node_Deep_Clone(src->items[i], env, depth);
        Node_List_Push(dst, cloned);
    }
}

static Syntax_Node *Node_Deep_Clone(Syntax_Node *node, Instantiation_Env *env,
                                    int depth) {
    if (!node) return NULL;

    /* Depth limit with REAL error, not silent aliasing */
    if (depth > 500) {
        Report_Error(node->location, "generic instantiation too deeply nested");
        return NULL;
    }

    /* Allocate fresh node */
    Syntax_Node *n = Arena_Allocate(sizeof(Syntax_Node));
    memset(n, 0, sizeof(Syntax_Node));  /* Zero-init ALL fields */
    n->kind = node->kind;
    n->location = node->location;
    n->type = node->type;
    n->symbol = NULL;  /* Symbols will be re-resolved */

    switch (node->kind) {
        case NK_IDENTIFIER:
            /* Check for expression substitution (formal object parameters) */
            if (env) {
                Syntax_Node *expr_subst = Env_Lookup_Expr(env, node->string_val.text);
                if (expr_subst) {
                    /* Return a clone of the actual expression instead.
                     * The 'n' node becomes garbage but arena will reclaim it. */
                    return Node_Deep_Clone(expr_subst, env, depth + 1);
                }
            }
            n->string_val = node->string_val;
            /* Check for type substitution */
            if (env) {
                Type_Info *subst = Env_Lookup_Type(env, node->string_val.text);
                if (subst) n->type = subst;
            }
            break;

        case NK_INTEGER:
            n->integer_lit = node->integer_lit;
            break;

        case NK_REAL:
            n->real_lit = node->real_lit;
            break;

        case NK_STRING:
        case NK_CHARACTER:
            n->string_val = node->string_val;
            break;

        case NK_BINARY_OP:
            n->binary.op = node->binary.op;
            n->binary.left = Node_Deep_Clone(node->binary.left, env, depth + 1);
            n->binary.right = Node_Deep_Clone(node->binary.right, env, depth + 1);
            break;

        case NK_UNARY_OP:
            n->unary.op = node->unary.op;
            n->unary.operand = Node_Deep_Clone(node->unary.operand, env, depth + 1);
            break;

        case NK_ATTRIBUTE:
            n->attribute.prefix = Node_Deep_Clone(node->attribute.prefix, env, depth + 1);
            n->attribute.name = node->attribute.name;
            Node_List_Clone(&n->attribute.arguments, &node->attribute.arguments, env, depth + 1);
            break;

        case NK_APPLY:
            n->apply.prefix = Node_Deep_Clone(node->apply.prefix, env, depth + 1);
            Node_List_Clone(&n->apply.arguments, &node->apply.arguments, env, depth + 1);
            break;

        case NK_SELECTED:
            n->selected.prefix = Node_Deep_Clone(node->selected.prefix, env, depth + 1);
            n->selected.selector = node->selected.selector;  /* String_Slice, not a node */
            break;

        case NK_AGGREGATE:
            Node_List_Clone(&n->aggregate.items, &node->aggregate.items, env, depth + 1);
            n->aggregate.is_named = node->aggregate.is_named;
            break;

        case NK_ASSOCIATION:
            Node_List_Clone(&n->association.choices, &node->association.choices, env, depth + 1);
            n->association.expression = Node_Deep_Clone(node->association.expression, env, depth + 1);
            break;

        case NK_RANGE:
            n->range.low = Node_Deep_Clone(node->range.low, env, depth + 1);
            n->range.high = Node_Deep_Clone(node->range.high, env, depth + 1);
            break;

        case NK_OBJECT_DECL:
            Node_List_Clone(&n->object_decl.names, &node->object_decl.names, env, depth + 1);
            n->object_decl.object_type = Node_Deep_Clone(node->object_decl.object_type, env, depth + 1);
            n->object_decl.init = Node_Deep_Clone(node->object_decl.init, env, depth + 1);
            n->object_decl.is_constant = node->object_decl.is_constant;
            n->object_decl.is_rename = node->object_decl.is_rename;
            break;

        case NK_TYPE_DECL:
        case NK_SUBTYPE_DECL:
            n->type_decl.name = node->type_decl.name;
            n->type_decl.definition = Node_Deep_Clone(node->type_decl.definition, env, depth + 1);
            Node_List_Clone(&n->type_decl.discriminants, &node->type_decl.discriminants, env, depth + 1);
            break;

        case NK_PROCEDURE_BODY:
        case NK_FUNCTION_BODY:
            n->subprogram_body.specification = Node_Deep_Clone(node->subprogram_body.specification, env, depth + 1);
            Node_List_Clone(&n->subprogram_body.declarations, &node->subprogram_body.declarations, env, depth + 1);
            Node_List_Clone(&n->subprogram_body.statements, &node->subprogram_body.statements, env, depth + 1);
            Node_List_Clone(&n->subprogram_body.handlers, &node->subprogram_body.handlers, env, depth + 1);
            n->subprogram_body.is_separate = node->subprogram_body.is_separate;
            break;

        case NK_PROCEDURE_SPEC:
        case NK_FUNCTION_SPEC:
            n->subprogram_spec.name = node->subprogram_spec.name;
            Node_List_Clone(&n->subprogram_spec.parameters, &node->subprogram_spec.parameters, env, depth + 1);
            n->subprogram_spec.return_type = Node_Deep_Clone(node->subprogram_spec.return_type, env, depth + 1);
            n->subprogram_spec.renamed = Node_Deep_Clone(node->subprogram_spec.renamed, env, depth + 1);
            break;

        case NK_PARAM_SPEC:
            Node_List_Clone(&n->param_spec.names, &node->param_spec.names, env, depth + 1);
            n->param_spec.mode = node->param_spec.mode;
            n->param_spec.param_type = Node_Deep_Clone(node->param_spec.param_type, env, depth + 1);
            n->param_spec.default_expr = Node_Deep_Clone(node->param_spec.default_expr, env, depth + 1);
            break;

        case NK_PACKAGE_SPEC:
            n->package_spec.name = node->package_spec.name;
            Node_List_Clone(&n->package_spec.visible_decls, &node->package_spec.visible_decls, env, depth + 1);
            Node_List_Clone(&n->package_spec.private_decls, &node->package_spec.private_decls, env, depth + 1);
            break;

        case NK_PACKAGE_BODY:
            n->package_body.name = node->package_body.name;
            Node_List_Clone(&n->package_body.declarations, &node->package_body.declarations, env, depth + 1);
            Node_List_Clone(&n->package_body.statements, &node->package_body.statements, env, depth + 1);
            Node_List_Clone(&n->package_body.handlers, &node->package_body.handlers, env, depth + 1);
            break;

        case NK_ASSIGNMENT:
        case NK_CALL_STMT:  /* Reuses assignment.target field */
            n->assignment.target = Node_Deep_Clone(node->assignment.target, env, depth + 1);
            n->assignment.value = Node_Deep_Clone(node->assignment.value, env, depth + 1);
            break;

        case NK_IF:
            n->if_stmt.condition = Node_Deep_Clone(node->if_stmt.condition, env, depth + 1);
            Node_List_Clone(&n->if_stmt.then_stmts, &node->if_stmt.then_stmts, env, depth + 1);
            Node_List_Clone(&n->if_stmt.elsif_parts, &node->if_stmt.elsif_parts, env, depth + 1);
            Node_List_Clone(&n->if_stmt.else_stmts, &node->if_stmt.else_stmts, env, depth + 1);
            break;

        case NK_LOOP:
            n->loop_stmt.label = node->loop_stmt.label;
            n->loop_stmt.iteration_scheme = Node_Deep_Clone(node->loop_stmt.iteration_scheme, env, depth + 1);
            Node_List_Clone(&n->loop_stmt.statements, &node->loop_stmt.statements, env, depth + 1);
            n->loop_stmt.is_reverse = node->loop_stmt.is_reverse;
            break;

        case NK_RETURN:
            n->return_stmt.expression = Node_Deep_Clone(node->return_stmt.expression, env, depth + 1);
            break;

        case NK_BLOCK:
            n->block_stmt.label = node->block_stmt.label;
            Node_List_Clone(&n->block_stmt.declarations, &node->block_stmt.declarations, env, depth + 1);
            Node_List_Clone(&n->block_stmt.statements, &node->block_stmt.statements, env, depth + 1);
            Node_List_Clone(&n->block_stmt.handlers, &node->block_stmt.handlers, env, depth + 1);
            break;

        case NK_CASE:
            n->case_stmt.expression = Node_Deep_Clone(node->case_stmt.expression, env, depth + 1);
            Node_List_Clone(&n->case_stmt.alternatives, &node->case_stmt.alternatives, env, depth + 1);
            break;

        case NK_EXIT:
            n->exit_stmt.loop_name = node->exit_stmt.loop_name;
            n->exit_stmt.condition = Node_Deep_Clone(node->exit_stmt.condition, env, depth + 1);
            break;

        case NK_NULL_STMT:
        case NK_OTHERS:
            /* No fields to copy */
            break;

        default:
            /* For node kinds not explicitly handled, do shallow copy.
             * This is safer than the original which returned aliased nodes. */
            *n = *node;
            n->symbol = NULL;
            break;
    }

    return n;
}

/* ─────────────────────────────────────────────────────────────────────────
 * §17.4 Build_Instantiation_Env — Create mapping from formals to actuals
 * ───────────────────────────────────────────────────────────────────────── */

static void Build_Instantiation_Env(Instantiation_Env *env,
                                    Symbol *template_sym,
                                    Symbol *instance_sym,
                                    Symbol_Manager *sm) {
    env->count = 0;
    env->template_sym = template_sym;
    env->instance_sym = instance_sym;

    if (!template_sym || !template_sym->declaration) return;

    Syntax_Node *gen_decl = template_sym->declaration;
    if (gen_decl->kind != NK_GENERIC_DECL) return;

    Node_List *formals = &gen_decl->generic_decl.formals;

    /* Use pre-resolved actuals from instance symbol */
    for (uint32_t i = 0; i < instance_sym->generic_actual_count && i < 32; i++) {
        Generic_Mapping *m = &env->mappings[env->count++];
        m->formal_name = instance_sym->generic_actuals[i].formal_name;
        m->actual_type = instance_sym->generic_actuals[i].actual_type;
        m->actual_symbol = NULL;
        m->actual_expr = NULL;

        /* For object/subprogram formals, populate additional fields */
        if (i < formals->count) {
            Syntax_Node *formal = formals->items[i];
            if (formal->kind == NK_GENERIC_OBJECT_PARAM) {
                /* Store expression for object formals */
                m->actual_expr = instance_sym->generic_actuals[i].actual_expr;
            } else if (formal->kind == NK_GENERIC_SUBPROGRAM_PARAM) {
                /* Store actual subprogram symbol for substitution during clone */
                m->actual_symbol = instance_sym->generic_actuals[i].actual_subprogram;
            }
        }
    }
}

/* ─────────────────────────────────────────────────────────────────────────
 * §17.5 Expand_Generic_Package — Full instantiation of generic package
 *
 * This implements the GNAT strategy:
 *   1. Clone the package spec with type substitutions
 *   2. Clone the package body (if found)
 *   3. Resolve cloned trees with actual types
 *   4. Store expanded body for code generation
 * ───────────────────────────────────────────────────────────────────────── */

static void Expand_Generic_Package(Symbol_Manager *sm, Symbol *instance_sym) {
    if (!instance_sym || !instance_sym->generic_template) return;

    Symbol *template = instance_sym->generic_template;
    if (!template->generic_unit) return;

    /* Build substitution environment */
    Instantiation_Env env;
    Build_Instantiation_Env(&env, template, instance_sym, sm);

    /* Clone the package spec */
    Syntax_Node *spec_clone = Node_Deep_Clone(template->generic_unit, &env, 0);
    if (spec_clone) {
        /* Rename to instance name */
        if (spec_clone->kind == NK_PACKAGE_SPEC) {
            spec_clone->package_spec.name = instance_sym->name;
        }

        /* Store for later processing */
        instance_sym->expanded_spec = spec_clone;
    }

    /* Try to find and clone the package body */
    String_Slice pkg_name = template->generic_unit->kind == NK_PACKAGE_SPEC ?
                            template->generic_unit->package_spec.name :
                            template->name;

    char *body_src = Lookup_Path_Body(pkg_name);
    if (body_src) {
        /* Parse the body */
        char body_filename[256];
        snprintf(body_filename, sizeof(body_filename), "%.*s.adb",
                 (int)pkg_name.length, pkg_name.data);
        Parser body_parser = Parser_New(body_src, strlen(body_src), body_filename);
        Syntax_Node *body_cu = Parse_Compilation_Unit(&body_parser);

        if (body_cu && body_cu->compilation_unit.unit &&
            body_cu->compilation_unit.unit->kind == NK_PACKAGE_BODY) {

            /* Clone with substitutions */
            Syntax_Node *body_clone = Node_Deep_Clone(
                body_cu->compilation_unit.unit, &env, 0);

            if (body_clone) {
                /* Rename to instance name */
                body_clone->package_body.name = instance_sym->name;

                /* Store expanded body */
                instance_sym->expanded_body = body_clone;
            }
        }
    }
}

/* ═══════════════════════════════════════════════════════════════════════════
 * END OF Ada 83
 * ═══════════════════════════════════════════════════════════════════════════
 */
